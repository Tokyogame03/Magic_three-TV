Microsoft Software c#

使用 Microsoft Visual Studio 2017 编程环境
创建 C#控制台应用程序
理解命名空间的作用
创建一个简单的 C#图形应用程序

Visual Studio 2017 编程环境提供了丰富的工具，能创建在 Windows 上运行的各种规模的C#项目。甚至能在项目中无缝合并用不同语言(比如 C++，Visual Basic 和 F#)写的模块。
Program.cs 文件定义了 Program 类，其中包含 Main 方法。C#的所有可执行代码都必须在方法中定义，而方法必须从属于类或结构。
Main 方法指定程序入口。必须像本例的 Program 类那样把它定义成静态方法，否则应用程序运行时，.NET Framework 可能不把它视为起点。
重要提示 C#区分大小写。Main 首字母必须大写。

前面的例子只是很小的程序，但小程序可能很快变成大程序。程序规模扩大带来两个问题。其一，代码越多，越难理解和维护。其二，更多代码通常意味着更多类和方法，要求跟踪更多名称。随着名称越来越多，极有可能因为两个或多个名称冲突而造成项目无法生成。例如，可能试图创建两个同名的类。如程序引用了其他开发人员写的程序集，后者同样使用了大量名称，这个问题将变得更严重。 
过去，程序员通过为名称添加某种形式的限定符前缀来解决名称冲突问题。但这并不是好的方案，因其不具扩展性。名称变长后，打字时间就增多了，还要花更多时间来反复阅读令人费解的长名字，真正花在写程序上的时间就少了命名空间(namespace)可解决这个问题，它为类这样的项创建容器。同名类在不同命名空间中不会混淆。可用 namespace 关键字在 TestHello 命名空间中创建 Greeting 类，如下所示：
namespace Testhello
{
	class Greeting
	{
		....
	}
}
然后在自己的程序中使用 TestHello.Greeting 引用 Greeting 类。如果有人在不同命名空间(例如 NewNamespace)中也创建了 Greeting 类，并把它安装到你的机器上，你的程序仍能正常工作，因为程序使用的是 TestHello.Greeting类。另一名开发者的 Greeting类要用 NewNamespace.Greeting 进行引用。
作为好习惯，所有类都应该在命名空间中定义，Visual Studio 2017 环境默认使用项目名称作为顶级命名空间。.NET Framework 类库(FCL)也遵循该约定，它的每个类都在一个命名空间中。例如，Console 类在 System 命名空间中。这意味着它的全名实际是 System.Console。 
当然，如果每次都必须写类的全名，似乎还不如添加限定符前缀，或者就用 SystemConsole 之类的全局唯一名称来命名类。幸好，可在程序中使用 using 指令解决该 问题。返回 Visual Studio 2017 中的 TestHello 程序，观察“代码和文本编辑器”窗口中的 Program.cs 文件，会注意到文件顶部的以下语句： 
using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; 
这些都是 using 指令，用于将某个命名空间引入作用域。同一文件的后续代码不再需 要用命名空间限定对象。由于这 5 个命名空间包含的类很常用，所以每次新建项目，Visual Studio 2017 都自动添加这些using 指令。可在源代码文件的顶部添加更多 using 指令。 
使用完全限定名称 
1. 在“代码和文本编辑器”窗口中注释掉 Program.cs 文件顶部第一个 using 指令： 
//using System; 
2. 在“生成”菜单中，选择“生成解决方案”。 
生成失败，“错误列表“窗口显示以下错误信息： 
当前上下文中不存在名称"Console" 
3. 在“错误列表”窗口中双击错误消息。 在 Program.cs 源代码文件中，导致错误的标识符将添加红色波浪线。 
4. 在“代码和文本编辑器”窗口中编辑 Main 方法以使用完全限定名称，即 System.Console。Main方法现在如下所示： 
static void Main(string[] args)
{
	System.Console.WriteLine("hello world");
}
注意 在System后键入句点时，“智能感知”列表将显示 System 命名空间中的所有项的名称
5. 在“生成”菜单中，选择“生成解决方案”。 项目应成功生成。否则请核实 Main 的代码是否与上述代码完全一致并重试。 
6. 在“调试”菜单中选择“开始执行(不调试)”命令来运行应用程序，确定它仍能正 常工作。 
7. 程序运行并显示“Hello World!”，在控制台窗口中按任意键返回 Visual Studio。

命名空间和程序集 
using 将某个命名空间的项引入作用域，这样在代码中就不必对类名进行完全限定。 类编译到程序集中。程序集通常是.dll文件。但严格地说，.exe 可执行文件也是程序集。 
一个程序集可包含许多类。构成.NET Framework 类库的那些类(比如 System.Console) 是在和 Visual Studio 一起安装的程序集中提供的。.NET Framework 类库包含数量众多的类。 都放到同一个程序集中，该程序集必将变得过于臃肿，很难管理。 (想象一下，假如 Microsoft 更新了一个类中的一个方法，就必须将整个类库分发给所有开发人员。) 
因此，.NET Framework 类库被分解成多个程序集，按其中包含的类的功能划分。例如，核心程序集 mscorlib.dll 包含所有常用类，System.Console 便是其中之一。另外还有其他 许多程序集，它们包含的类分别用于处理数据库、访问 Web 服务以及构建 GUI 等。要使用 某个程序集中的某个类，必须在项目中添加对该程序集的引用。随后，可以在代码中添加 using 语句，将程序集中的某个命名空间中的项引入作用域。 
注意，程序集和命名空间并非肯定一对一。程序集可能包含多个命名空间中的类，而 一个命名空间可能跨越多个程序集。例如，System 命名空间中的项实际由多个程序集实现， 包括 mscorlib.dll，System.dll 和 System.Core.dll 等等。这点最初令人困惑，但习惯就好。 
使用 Visual Studio 创建应用程序时，所选的模板自动包含对适当程序集的引用。
例如在 TestHello 项目的“解决方案资源管理器”中展开“引用”文件夹，会发现控制 台应用程序自动包含对 Microsoft.CSharp，System，System.Core，System.Data， System.Data.DataSetExtensions，System.Net.Http，System.Xml 和 System.Xml.Linq 等程序集的引用。核心库 mscorlib.dll 之所以没有包含在其中，是因为所有.NET Framework 应用程序都 必须 使用它(因其包含最基本的运行时功能)。“引用”文件夹只列出 可选 程序 集，可根据需要在此文件夹中增删程序集。 
要添加对其他程序集的引用，右击“引用”文件夹并选择“添加引用”。稍后的练习 将执行这个任务。要删除程序集，右击并选择“删除”。 

 创建图形应用程序 前面使用 Visual Studio 2017 创建并运行了一个基本的控制台应用程序。Visual Studio 2017 编程环境还包含创建 Windows 10 图形应用程序所需的一切。这些模板称为“通用 Windows 平台”(Universal Windows Platform，UWP)，因其创建的应用能在所有 Windows 设备上运行，比如台式机、平板和手机。你可以交互式设计 Windows 应用程序的用户界面 (UI)，Visual Studio 2017 自动生成代码来实现界面。 Visual Studio 2017 允许用两个视图查看图形应用程序：设计视图和代码视图。可在“代 码和文本编辑器”窗口中修改和维护图形应用程序的代码和逻辑；“设计视图”窗口则用 于布置图形用户界面。两个视图可自由切换。
 目标
1 使用 Visual Studio 2017 新建控制台应用程序选择“文件”|“新建”|“项目”打开“新建项目”对话框。在左侧窗 格展开“已安装”|“Visual C#”。在中间窗格单击“控制台应用(.NET Framework)”。在“位置”框中为项目文件选择目录。输入项目名称。 单击“确定” 
2  使用 Visual Studio 2017 新建通用Windows平台应用 选择“文件”|“新建”|“项目”打开“新建项目”对话框。在左侧窗 格展开“已安装”|“Visual C#”|“Windows 通用”。在中间窗格单击 “空白应用(通用 Windows)”。在“位置”框中为项目文件选择目录。 输入项目名称。单击“确定”按钮 

c#.sublime_text.exe

语句、标识符和关键字 ( C#的语法和语义元素，包括语句、关键字和标 识符)
使用基元数据类型 ( C#语言内建的基元数据类型以及每种类型所容纳的值的特)
使用变量存储信息 (如何声明和 使用局部变量(只存在于方法或其他小节内的变量))
使用+和-以及其他算术操作符 ( C#算术操作符)
变量递增递减 (如何使用操作符来处理值,如何控制含有两个或更多操作符的表达)

C#语句遵循良好定义的规则集。这些规则描述语句的格式和构成，统称为语法。对应 地，描述语句做什么的规范统称为语义。
标识符是对程序中的各个元素进行标识的名称。这些元素包括命名空间、类、方法和 变量(后面很快就会讲到变量)。在 C#语言中选择标识符时必须遵循以下语法规则： 
1 只能使用字母(大写和小写)、数字和下划线。(C#区分大小写。例如，footballTeam 和 FootballTeam 是不同的标识符)
2 标识符必须以字母或下划线开头
C#语言保留 77 个标识符供自己使用，程序员不可出于自己的目的而重用这些标识符。 这些标识符称为关键字，每个关键字都有特定含义。
abstract 		do 			in 			protected 			true 
as  			double 		int 		public 				try 
base 			else 		interface 	readonly 			typeof 
bool 			enum 		internal 	ref 				uint 
break 			event 		is 			return 				ulong 
byte 			explicit 	lock 		sbyte 				unchecked 
case 			extern 		long 		sealed 				unsafe 
catch 			false 		namespace 	short 				ushort 
char 			finally 	new 		sizeof 				using 
checked 		fixed 		null 		stackalloc 			virtual 
class 			float 		object 		static 				void 
const 			for 		operator 	string 				volatile 
continue 		foreach 	out 		struct 				while 
decimal 		goto 		override 	switch  
default 		if 			params 		this  
delegate 		implicit 	private 	throw
C#还使用了以下标识符。这些不是 C#保留关键字，可作为自己方法、变量和类的名称 使用，但尽量避免这样做。 
add    global  select alias  group  set ascending  into   value async  join   var await  let   when descending nameof  where dynamic  orderby  yield from   partial get   remove 
变量是容纳值的一个存储位置。可将变量想象成计算机内存中容纳临时信息的容器。 程序每个变量在其使用范围内都必须有无歧义名称。我们用该名称引用变量容纳的值。
1 命名变量 
为变量采用恰当的命名规范来避免混淆。作为开发团队的一员，这一点尤其重要。统 一的命名规范有助于减少 bug。下面是一些常规建议。 
不要以下划线开头。虽然在 C#中合法，但限制了和其他语言(如 Visual Basic)的代 码的互操作性。 
不要创建仅大小写不同的标识符。例如，不要同时使用 myVariable和 MyVariable 变量，它们很易混淆。而且在 Visual Basic 这样不区分大小写的语言中，类的重用 性也会受限。 
名称以小写字母开头。 
在包含多个单词的标识符中，从第二个单词起，每个单词都首字母大写(称为 camelCase 记号法)。 
2  声明变量 
变量容纳值。C#能存储和处理许多类型的值，包括整数、浮点数和字符串等。声明变 量时，必须指定它要容纳的数据的类型。 
变量类型和名称在声明语句中声明。例如，以下语句声明age变量来容纳int值。记
住所有语句必须以分号终止： 
int age; 
int 是 C#基元数据类型之一(后面会讲到其他基元数据类型)。 
注意 Visual Basic 程序员注意，C#不允许隐式变量声明。所有变量在使用之前必须先 进行明确声明。 
变量声明好后就可以赋值。以下语句将值 42 赋给 age。同样，最后的分号必不可少：
age = 42; 
等号(=)是赋值操作符，作用是将右侧值赋给左侧变量。赋值后可在代码中使用名称 age 来引用其容纳的值。以下语句将变量 age 的值写到控制台： 
Console.WriteLine(age); 
3 指定数值 
变量类型决定了变量能容纳什么数据以及数据的处理方式。例如，数值变量显然不能 容纳"Hello"这样的字符串值。但有时赋给变量的值的类型并非总是那么清晰 
以字面值 42 为例①。它是数值。更具体地说是整数，可直接赋给整数类型的变量。但 如果赋给非整型（比如浮点变量）会发生什么？答案是 C#会悄悄地将整数值转换为浮点值。 关系不大，但不推荐。推荐的做法是明确指定你想把字面值 42 当作浮点数，而不是因为不 小心才把它赋给不匹配类型的变量。为数值附加 F 后缀就可以，例如： 
float myVar; // 声明浮点变量 
myVar = 42F; // 将浮点值赋给变量
那么，值 0.42 是什么类型的表达式？含小数点的所有数值都是双精度浮点数，称为
 double 值。 ，double 具有比 float 更大的范围和更高的精度。主动附加 F后 缀才能将值 0.42 赋给 float 变量 (这也是 C#编译器的强制要求)： myVar = 0.42F; C#还有其他数值类型：long，长整数，范围比整数大；decimal，小数，容纳准确小数 值（float 和 double 在计算时可能被取整，所以只能算是一种近似值）。long值用后缀 L 指定，decimal 值用M指定。

使用基元数据类型 
 C#内建许多基元数据类型②，用于存储常用的数值、字符串、字符和 Boolean 值。
sbyte system.Sbyte      -128127
short system.Int16      -32768-32767
int system.Int32        -2147483648-21474883647
long system.Int64       -2^63-2^63-1
byte system.Byte         0-255 
ushort System.UInt16     0-2^16-1
uint System.UInt32       0-2^32-1
ulong System.UInt64      0-2^64-1
decmial System.Decimal   ±1.0*10e-28~7.9*10e28 (10e-28=10^-28)
bool System.Boolean      true/false
char System.Char         U+0000~U+ffff （0-65536）
object System.Object 
string System.String     character string
变量声明时包含随机值，直至被明确赋值。C 和 C++程序的许多 bug 都是由于误用了 未赋值变量。C#不允许使用未赋值变量。变量只有赋值后才能使用，否则程序无法编译。 这就是所谓的明确赋值规则。例如，由于 age 尚未赋值，所以以下语句造成编译错误（错 误 CS0165：使用了未赋值的局部变量 age）： 
int age; 
Console.WriteLine(age); // 编译错误 
显示基元数据类型的值 
练习使用名为 PrimitiveDataTypes 的 C#程序演示几种基元数据类型的工作方式。 
1. 如果还没有运行 Visual Studio 2017，请启动它。 
2. 选择“文件”|“打开”|“项目/解决方案”。 
 随后出现“打开项目”对话框。 
3. 切换到“文档”文件夹下的\Microsoft Press\VCSBS\Chapter 2\PrimitiveDataTypes 子文件夹。  
4. 选择解决方案文件 PrimitiveDataTypes，单击“打开”。 
 随后将加载解决方案。“解决方案资源管理器”将显示 PrimitiveDataTypes 项目。
 注意 解决方案文件使用.sln 扩展名，例如 PrimitiveDataTypes.sln。解决方案可包含一个 或多个项目。项目文件使用.csproj 扩展名。如果打开项目而不是解决方案，Visual Studio 2017 自动为它创建新的解决方案文件。不注意的话可能造成困扰，你可能 不慎为同一个项目生成多个解决方案。 
5. 在“调试”菜单中选择“开始调试”。 
 可能在 Visual Studio 中看到一些警告。暂时忽略警告(将在下个练习纠正)。
6. 在 Choose a data type(选择数据类型)列表中单击 string 类型。 
 forty two这个值会出现在 Sample value(示例值)文本框中。 
7. 单击列表中的 int 类型。 
 Sample value 文本框显示值 to do，表明用于显示 int 值的语句还没有写好。 
8. 单击列表中的每种数据类型。确定用于double和bool类型的代码都还没有实现。 
9. 返回 Visual Studio 2017，选择“调试”|“停止调试”。也可关闭窗口来停止调试。 
 在代码中使用基元数据类型 
1. 在“解决方案资源管理器”中展开 PrimitiveDataTypes 项目，双击 MainPage.xaml 文件。 
 应用程序的窗体将出现在“设计视图”窗口中。 
 2. 在 XAML 窗格向下滚动，找到 ListBox 控件的标记。该控件在窗体左侧显示数据 类型列表，其代码如下(省略了一些属性)： 
<ListBox x:Name="type" ... SelectionChanged="typeSelectionChanged"> 
 <ListBoxItem>int</ListBoxItem>  
 <ListBoxItem>long</ListBoxItem>  
 <ListBoxItem>float</ListBoxItem>  
 <ListBoxItem>double</ListBoxItem>   
 <ListBoxItem>decimal</ListBoxItem> 
 <ListBoxItem>string</ListBoxItem>
 <ListBoxItem>char</ListBoxItem>
 <ListBoxItem>bool</ListBoxItem>
</ListBox> 
ListBox 控件将每个数据类型显示成单独的 ListBoxItem。应用程序运行时单击 列表项会发生 SelectionChanged 事件(有点像第 1 章描述的单击按钮时发生 Click 事件)。本程序是在发生该事件时调用 MainPage.xaml.cs 文件中定义的 typeSelectionChanged 方法。
3. 选择“视图”|“代码”或者按 F7。 
 将在“代码和文本编辑器”窗口中显示 MainPage.xaml.cs 文件的内容。 
 注意 记住可用“解决方案资源管理器”访问代码，展开 MainPage.xaml 后双击 MainPage.xaml.cs。 
4. 在文件中找到 typeSelectionChanged 方法。 
5. 向下滚动代码，找到 showFloatValue 方法，如下所示： 
private void showFloatValue()
{
	float floatVar;
	floatVar = 0.42F;
	value.Text = float.ToString();
}	
 方法主体包含三个语句。第一个声明 float 类型的变量 floatVar。 
 第二个将值 0.42F 赋给变量 floatVar。 第三个语句在窗体的 value 文本框显示该变量的值。多留意一下该语句。
 6. 在“代码和文本编辑器”窗口中找到如下所示的 showIntValue 方法： 
 private void showIntVlue()
 {
 	value. Text = “to do”;
 }
在列表框中单机int类型时会调用showIntValue方法。
7. 在 showIntValue 方法开头(起始大括号后另起一行)输入以下加粗的两个语句： 
private void showIntValue()
{
	int intVar;
	intVar = 42;
	value.Text = "to do";
}
第一个语句创建变量 intVar 来容纳 int 值。第二个将值 42 赋给变量。 
8. 在方法的原始语句中，将字符串"to do"改成 intVar.ToString()。方法现在像下 面这样
private void showIntValue()
{
	int intVar;
	intVar = 42;
	value.Text = intVar.ToString();
}
 在“调试”菜单中选择“开始调试”。 
 窗体再次出现。 
10. 从列表框选择int类型。确定Sample value框显示值 42。 
11. 返回 Visual Studio 2017，在“调试”菜单中选择“停止调试”命令。 
12. 在“代码和文本编辑器”窗口中找到 showDoubleValue 方法。 
13. 编辑 showDoubleValue 方法，添加加粗的代码： 
private void showIntValue()
{
	int intVar;
	intVar = 42;
	value.Text = intVar.ToString();
}
代码和 showIntValue 方法相似，只是创建 double 变量 doubleVar，赋值 0.42。
 14. 在“代码和文本编辑器”窗口中找到 showBoolValue方法。 
 15. 编辑 showBoolValue 方法： 
private void showBoolValue() 
{
	boolVar;
	boolVar = false;
	value.Text = bool.ToString();
} 
 代码和之前的例子相似，不过 boolVar 变量只能容纳布尔值 true 或 false。本例 赋值 false。 
 16. 在“调试”菜单中选择“开始调试”。 
17. 从 Choose a data type 列表中选择 int、double和 bool类型。在每一种情况下， 都验证 Sample value 框中显示的是正确的值。 
18. 返回 Visual Studio 2017，在“调试”菜单中选择“停止调试”

使用算术操作符
C#支持我们小时候学过的常规算术操作符：加号(+)、减号(-)、星号(*)和正斜杠(/)分 别执行加、减、乘、除。它们称为操作符或运算符，对值进行“操作”或“运算”来生成 新值。在下例中，moneyPaidToConsultant变量最终容纳的是值 750(每天的费用)和值 20(天 数)的乘积，结果就是要付给顾问的钱。 
long moneyPaidToConsultant; 
moneyPaidToConsultant = 750 * 20; 
注意 操作符或运算符操作/运算的是操作数或运算子。在表达式 750 * 20 中，*是操 作符，750 和 20 是操作数。
不是所有操作符都适合所有数据类型。操作符能不能应用于某个值要取决于值的类型。 例如，可对 char，int，long，float，double 或 decimal 类型的值使用任何算术操作符。 但除了加法操作符(+)，不能对 string 类型的值使用其他任何算术操作符。对于 bool 类型 的值，则什么算术操作符都不能用。所以以下语句是不允许的，因为 string 类型不支持减 法操作符(从一个字符串减另一个字符串没有意义)： 
// 编译时错误
Console.WriteLine("Gillingham" - "Forest Green Rovers"); 
操作符+可用于连接字符串值。使用需谨慎，因为可能得到出乎意料的结果。例如，以 下语句在控制台中写入"431"(而不是"44")： 
Console.WriteLine("43" + "1");
提示 .NET Framework 提供了 Int32.Parse 方法。要对作为字符串存储的值执行算术 运算，可先用 Int32.Parse 将其转换成整数值。
字符串插值 
C#的一项新功能是字符串插值(string interpolation)有了它就基本上不用+操作符连接字符串了。 
连接字符串通常是为了生成插入变量值的字符串。第1章创建图形应用程序时演示过 一个例子。okClick 方法添加过下面这行代码： 
MessageDialog msg = new MessageDialog("Hello " + userName.Text); 
字符串插值则允许这样写： 
MessageDialog msg = new MessageDialog($"Hello {userName.Text}"); 
开头的$符号表明这是插值字符串，{和}之间的任何表达式都要求值并置换。无前置$符 号，字符串{username.Text}将按字面处理。 
字符串插值比+操作符高效得多。由于.NET Framework 处理字符串的方式，用+来连接 字符串可能消耗大量内存。字符串插值还更具可读性和减少犯错机会(虽然这一点有争议)。
还要注意，算术运算的结果类型取决于操作数类型。例如，表达式 5.0 / 2.0 的值是 2.5。两个操作数的类型均是 double，结果也是 double。(在 C#中，带小数点的字面值肯 定是 double 值，而不是 float 值，目的是保留尽可能高的精度。)但表达式 5 / 2 的结果 是 2。两个操作数的类型均是 int，结果也是 int。C#在这种情况下总是对值进行向下取 整。另外，混用不同的操作数类型，情况会变得更复杂。例如，表达式 5 / 2.0 包含 int 值和 double 值。C#编译器检测到这种不一致的情况，自动生成代码将 int 转换成 double 再执行计算。所以，以上表达式的结果是 double 值(2.5)。能这样写，但不建议。
C#还支持你或许不太熟悉的一个算术操作符，即取模(余数)操作符。它用百分号(%)表 示。x % y的结果就是用 x 除以 y所得的余数。例如，9 % 2结果是 1，因为 9除以 2，结 果是 4 余 1。 
注意 如熟悉 C 和 C++，就知道它们不允许对float和double值使用取模操作符。但 C#允许。取模操作符适用于所有数值类型，而且结果不一定为整数。例如，表达式7.0% 2.4 结果是 2.2。
数值类型和无穷大 
C#语言的数字还有另两个特性是你必须了解的。例如，任何数除以0所得的结果是无 穷大，超出了 int，long 和 decimal 类型的范围。所以计算 5 / 0 这样的表达式会出错。 但 double 和 float 类型实际上有一个可以表示无穷大的特殊值，因此表达式 5.0 / 0.0 的值是 Infinity(无穷大)。该规则唯一的例外是表达式 0.0 / 0.0。通常，如果0除以任何数，结果都是 0，但任何数除以0结果是无穷大。表达式 0.0 / 0.0 会陷入一种自相矛盾 的境地：值既是0，又是无穷大。针对这种情况，C#语言提供了另一个值 NaN，即“not a number”。所以，如果计算表达式 0.0 / 0.0，则结果为 NaN。NaN和 Infinity可在表达 式中使用。计算 10 + NaN，结果是NaN。计算 10 + Infinity，结果是 Infinity。规则唯 一的例外是 Infinity * 0，结果是 0。而 NaN * 0 的结果仍是 NaN。 
演示如何对 int 类型的值使用算术操作符。 
运行 MathsOperators 项目 
1. 如果还没有运行 Visual Studio 2017，请启动它。 
2. 打开 MathsOperators 解决方案 ， 它位于“ 文档” 文 件 夹 下 的 \Microsoft Press\VCSBS\Chapter 2\MathsOperators 子文件夹。 
3. 在“调试”菜单中选择“开始调试”命令。 
4. 在 Left Operand(左操作数)框中输入 54。 
5. 在 Right Operand(右操作数)框中输入 13。 
 随后，可以向两个文本框中的值应用任意操作符。 
6. 单击–Subtraction(减)单选钮，再单击 Calculate(计算)按钮。 
 Expression(表达式)框中的文本变成 54-13，Result(结果)框显示0。这明显是错的。 
7. 单击/ Division(除)，再单击 Calculate。 
 Expression 框中的文本变成 54 / 13，Result 框再次显示0。 
8. 单击% Remainder(取模)，再单击 Calculate。 
 Expression 框中的文本变成 54 % 13，Result 框再次显示0。测试其他数字和操作 符组合，证实目前结果都显示 0。 
 注意 输入任何非整数的操作数，应用程序检测到错误并显示消息“Input string was not in a correct format.”。
9. 返回 Visual Studio 并选择“调试”|“停止调试”。 
MathsOperators 应用程序目前没有实现任何计算。下个练习将进行改进。 
在 MathsOperators 应用程序中执行计算 
1. 在设计视图窗口中显示 MainPage.xaml 窗体，如有必要，在“解决方案资源管理 器”的 MathsOperators 项目中双击 MainPage.xaml。 
2. 选择“视图”|“其他窗口”|“文档大纲”。 
 随后将打开如下图所示的“文档大纲”窗口，其中列出了窗体上各个控件的名称和 类型。“文档大纲”窗口提供一个简单的方式在复杂的窗体中定位并选择控件。 控件分级显示，最顶级的是构成窗体的 Page。如第 1 章所述，UWP 应用的“页” 包含一个 Grid 控件，其他控件都放在该 Grid 中。在“文档大纲”中展开 Grid 节点就会看到其他控件。其他控件以另一个 Grid 开始(外层 Grid 作为 frame 使用，内层 Grid 包含窗体上出现的控件)。展开内层 Grid 将列出窗体上的所有控件。 单击任何控件，对应元素在设计视图中突出显示。类似地，在设计视图中选中控件，对应控件在“文档大纲”窗口中突出显示。单击“文档大纲”窗口右上角的图钉按钮来固定窗口，更好地体验这个功能。
3. 在窗体上单击供用户输入数字的两个 TextBox 控件。在“文档大纲”窗口中，确认它们分别命名为 lhsOperand 和 rhsOperand。 
 窗体运行时，每个控件的 Text 属性都容纳了用户输入的值。 
4. 在窗体底部，确认用于显示表达式的 TextBlock 控件命名为 expression，用于显示计算结果的 TextBlock 控件命名为 result。 
5. 关闭“文档大纲”窗口。 
6. 选择“视图”|“代码”，在“代码和文本编辑器”窗口中显示 MainPage.xaml.cs 文件的代码。 
7. 在“代码和文本编辑器”窗口中找到 addValues 方法，如下所示： 
 prite void addvalue()
 {
 	int lhs = int.Parse(lhsOperand.Text);
 	int rhs =int.Parse(rhsOperand.Text); 
 	int outcome = 0;
 	//TODO: Add rhs to lhs and store the result in outcome 
 	expression.Text = $"{lhsOperand.Text} + {rhsOperand.Text}";      result.Text = outcome.ToString();
 }
第一个语句声明名为 int 变量 lhs，初始化为用户在 lhsOperand 框中输入的整数。记住TextBox控件的Text属性包含字符串，但lhs是int，所以必须先将字符串转换为整数，然后才能赋给 lhs。int 数据类型提供了 int.Parse 方法来执 行这个转换。 
第二个语句声明 int 变量 rhs。rhsOperand 框中的值转换为 int 之后赋给它。 
第三个语句声明 int 变量 outcome。 
一条注释指出要将 lhs 和 rhs 加到一起，结果存储到 outcome 中。这将在下个步骤实现。 
第五个语句利用字符串插值构造一个字符串来显示要执行的计算，并将结果赋给 expression.Text 属性，导致字符串在窗体的 expression 框中显示。 
最后一个语句将计算结果赋给 result 框的 Text 属性以显示。记住 Text 属性的 值是字符串，而计算结果是 int，所以必须先转换成字符串才能赋给 Text 属性。 这正是 int 类型的 ToString 方法的作用。 
8.在 addValues 方法中部的注释下添加加粗的语句： 
private void addValues() 
{
	 int lhs = int.Parse(lhsOperand.Text);
	 int rhs = int.Parse(rhsOperand.Text);      
	 int outcome=0;      
	 // TODO: Add rhs to lhs and store the result in outcome      
	 outcome = lhs + rhs;      
	 expression.Text = $"{lhsOperand.Text} + {rhsOperand.Text}";      
	 result.Text = outcome.ToString();
}
该语句对表达式 lhs + rhs 进行求值，结果存储到 outcome 中。
9. 检查 subtractValues 方法。该方法遵循相似的模式，需要添加语句计算从 lhs 减去 rhs 的结果，并存储到 outcome 中。在方法中添加以下加粗显示的语句： 
private void addValues() 
{
	 int lhs = int.Parse(lhsOperand.Text);
	 int rhs = int.Parse(rhsOperand.Text);      
	 int outcome=0;      
	 // TODO: Add rhs to lhs and store the result in outcome      
	 outcome = lhs - rhs;      
	 expression.Text = $"{lhsOperand.Text} + {rhsOperand.Text}";      
	 result.Text = outcome.ToString();
}
10. 检查 mutiplyValues，divideValues 和 remainderValues 方法。它们同样缺失 了执行指定计算的关键语句。添加缺失的语句(加粗显示)： 
private void addValues() 
{
	 int lhs = int.Parse(lhsOperand.Text);
	 int rhs = int.Parse(rhsOperand.Text);      
	 int outcome=0;      
	 // TODO: Add rhs to lhs and store the result in outcome      
	 outcome = lhs * rhs;      
	 expression.Text = $"{lhsOperand.Text} + {rhsOperand.Text}";      
	 result.Text = outcome.ToString();
}
private void addValues() 
{
	 int lhs = int.Parse(lhsOperand.Text);
	 int rhs = int.Parse(rhsOperand.Text);      
	 int outcome=0;      
	 // TODO: Add rhs to lhs and store the result in outcome      
	 outcome = lhs / rhs;      
	 expression.Text = $"{lhsOperand.Text} + {rhsOperand.Text}";      
	 result.Text = outcome.ToString();
}
private void addValues() 
{
	 int lhs = int.Parse(lhsOperand.Text);
	 int rhs = int.Parse(rhsOperand.Text);      
	 int outcome=0;      
	 // TODO: Add rhs to lhs and store the result in outcome      
	 outcome = lhs % rhs;      
	 expression.Text = $"{lhsOperand.Text} + {rhsOperand.Text}";      
	 result.Text = outcome.ToString();
}
 测试 MathsOperators 应用程序 
1. 在“调试”菜单中选择“开始调试”以生成并运行应用程序。 
2. 在 Left Operand 框中输入 54，在 Right Operand 框中输入 13。单击+ Addition，单击Calculate。 Result 框显示值 67。 
3. 单击–Subtraction，单击 Calculate。验证结果是 41。 
4. 单击* Multiplication，单击 Calculate。验证结果是 702。 
5. 单击/ Division，单击 Calculate。验证结果是 4。 在现实生活中，54 / 13 的结果应该是 4.153846…(如此重复)。但这不是现实生活；这是 C#！正如前面解释的，在C#中整数除以整数结果也是整数。 
6. 单击% Remainder，单击 Calculate。验证结果是 2。 处理整数时，54 除以 13，余数是 2。计算机求值过程是 54–((54/13) * 13) = 2。每一步都向下取整。 
7. 返回 Visual Studio 并停止调试。 

控制优先级 
优先级控制表达式中各个操作符的求值顺序。例如以下表达式，它使用了操作符+和*： 2 + 3 * 4 
没有优先级规则，该表达式会造成歧义。先加还是先乘？不同求值顺序造成不同结果。 
如果先加后乘，那么加法运算(2 + 3)的结果将成为操作符*的左操作数，所以整 个表达式的结果是 5 * 4，即 20。 
假如先乘后加，那么乘法运算(3 * 4)的结果将成为操作符+的右操作数，所以整 个表达式的结果是 2 + 12，即 14。 
在 C#中，乘法类操作符(*，/和%)的优先级高于加法类操作符(+和-)。所以 2 + 3 * 4 的结果是 14。以后讨论每种新操作符时，都会指出它的优先级。 
可用圆括号覆盖优先级规则，强制操作数按你希望的方式绑定到操作符。例如在以下 表达式中，圆括号强迫 2和 3 绑定到操作符+(得 5)，结果成为操作符*的左操作数，最终结 果是 20： (2 + 3) * 4 
使用结合性对表达式进行求值 
操作符优先级只能解决部分问题。如果表达式中的多个操作符具有相同优先级怎么办？ 这就要用到结合性的概念。结合性是指操作数的求值方向(向左或向右)。例如，以下表达式 同时使用操作符/和*： 4 / 2 * 6 
该表达式仍有可能造成歧义。是先除还是先乘？两个操作符优先级相同，但求值顺序 至关重要，因为可能获得两个不同的结果。 
1. 如果先除，除法运算(4 / 2)的结果成为操作符*的左操作数，整个表达式的结果 是 (4/2) * 6，即 12。 
2. 如果先乘，乘法运算的结果(2 * 6)成为操作符/的右操作数，整个表达式的结果是 4/(2 * 6)，即 4/12。 
在这种情况下，操作符的结合性决定表达式如何求值。操作符*和/都具有左结合性，即操作数从左向右求值。在本例中，4/2 在乘以 6之前求值，所以正确结果是 12。 
结合性和赋值操作符
C#的等号(=)是赋值操作符。所有操作符都依据它们的操作数返回一个值。赋值操作符也不例外。它取两个操作数；右操作数被求值，结果保存到左操作数中。赋值操作符返回 的就是赋给左操作数的值。例如，以下语句的赋值操作符返回值 10，这也是赋给变量myInt 的值： 
int myInt; myInt = 10; // 赋值表达式的值是10 
一切都甚合逻辑，但你同时也会感到不解，这到底有什么意义？意义在于，由于赋值操作符返回一个值，所以可在另一个赋值语句中使用该值，例如： 
int myInt; 
int myInt2; 
myInt2 = myInt = 10; 
赋给变量 myInt2 的值就是赋给 myInt 的值。赋值语句把同一个值赋给两个变量。要将多个变量初始化为同一个值，这个技术十分有用。它使任何读代码的人清楚理解所有变量都具有相同的值。 
myInt5 = myInt4 = myInt3 = myInt2 = myInt = 10; 
通过这些讨论，你可能已推断出赋值操作符具有从右向左的结合性。最右侧的赋值最先发生，被赋的值从右向左，在各个变量之间传递。任何变量之前有过值，就用当前赋的值覆盖。 
但是，使用这样的语法构造时要小心。新手 C#程序员易犯的错误是试图将赋值操作符 的这种用法与变量声明一起使用，例如： 
int myInt, myInt2, myInt3 = 10; 
语法没有错误(能通过编译)，但做的事情可能跟你想的不同。它实际是声明变量 myInt，myInt2和 myInt3，并将 myInt3 初始化为 10。然而，不会初始化 myInt 或者 myInt2。如 果尝试在以下表达式中使用 myInt 或者 myInt2： 
myInt3 = myInt / myInt2; 
编译器会报告以下错误： 
使用了未赋值的局部变量 "myInt" 使用了未赋值的局部变量 "myInt2" 
变量递增和递减 
使变量加 1 可以使用+操作符： 
count = count + 1; 
然而使变量加 1 是 C#的一个非常普遍的操作，所以专门为这个操作设计了++操作符。 例如，使变量 count 递增 1可以像下面这样写： 
count++;       
对应地，--操作符从变量中减 1： 
count--; 
++和--是一元操作符，即只有一个操作数。它们具有相同的优先级和左结合性。 
前缀和后缀 
(++)和递减(--)操作符与众不同之处在于，它们既可以放在变量前，也可以放在变量后。在变量前使用，称为这个操作符的前缀形式；在变量之后使用，则称为这个操作符 的后缀形式。如下面几个例子所示： 
count++; // 后缀递增 
++count; // 前缀递增 
count--; // 后缀递减 
--count; // 前缀递减 
对于被递增或递减的变量，++或--的前缀和后缀形式没有区别。例如，count++使count的值递增1，++count也会使其递增1。那么为何还要提供两种不同的形式？为了理解这个问题，必须记住一点：++和--都是操作符，而所有操作符都要返回值。count++返回递增前 的 count 值，而++count 返回递增后的 count 值。例如： 
int x; 
x = 42; 
Console.WriteLine(x++);  // 执行这个语句后，x等于 43，但控制台上输出的是42 x = 42; Console.WriteLine(++x); // 执行这个语句后，x等于 43，控制台上输出的也是43 
其实很好记，只需看表达式各个元素(操作符和操作数)的顺序即可。在表达式 x++中， 变量x先出现，所以先返回它现在的值，然后再递增；在表达式++x中，++操作符先出现，所以先对x进行递增，再将新值作为表达式的值返回。 
声明隐式类型的局部变量
前面通过指定数据类型和标识符来声明变量，如下所示： 
int myInt; 
以前说过，变量使用前必须赋值。可在同一个语句中声明并初始化变量，如下所示： 
int myInt = 99; 
还可像下面这样做(假定 myOtherInt 是已初始化的整数变量)： 
int myInt = myOtherInt * 99; 
记住，赋给变量的值必须具有和变量相同的类型。例如，只能将int值赋给int变量。C#编译器可迅速判断变量初始化表达式的类型，如果和变量类型不符，就会明确告诉你。除此之外，还可要求C#编译器根据表达式推断变量类型，并在声明变量时自动使用该类型。 为此，只需用 var 关键字代替类型名称，如下所示： 
var myVariable = 99; 
var myOtherVariable = "Hello"; 
两个变量 myVariable 和 myOtherVariable 称为隐式类型变量。var 关键字告诉编译 器根据变量的初始化表达式推断变量类型。在本例中，myVariable 是 int 类型，而 myOtherVariable是 string 类型。必须注意，var 只是在声明变量时提供一些方便。但变 量一经声明，就只能将编译器推断的那种类型的值赋给它。例如，不能再将 float，double， string值赋给 myVariable。还要注意，只有提供了初始化表达式，才能使用关键字 var。 以下声明非法，会导致编译错误： 
var yetAnotherVariable;  // 错误 - 编译器不能推断类型 
重要提示  如果用 Visual Basic 写过程序，就可能非常熟悉 Variant 类型，该类型可在变量中保存任意类型的值。这里要强调的是，应该忘记当年用 VB 编程时学 到的有关 Variant 变量的一切。虽然两个关键字貌似有联系，但 var 和 Variant 完全是两码事。在 C#中用 var 关键字声明变量之后，赋给变量的 值的类型就固定下来，必须是初始化变量的值的类型，不能随便改变！ 

方法和作用域 
声明和调用方法 
向方法传递数据 
从方法返回数据 
定义局部和类作用域 
使用集成调试器逐语句和逐过程调试方法 
（如何利用实参和形参向方法传递数 据，如何利用 return语句从方法返回数据，如何利用 Microsoft Visual Studio 2017 集成调试器来调试方法。如果方法的工作不符合预期，就可利用这个技术跟踪方法执行情况。如何让方法获取可选参数，以及如何用具名参数调用方法。）

创建方法 
方法是具名的语句序列。如果以前用过其他编程语言，如 C，C++或者 Visual Basic， 就可将方法视为与函数或者子程序相似的东西。每个方法都有名称和主体。方法名应该是 一个有意义的标识符，它用英语描述了方法的用途(例如用于计算所得税的方法可命名为 calculateIncomeTax)。方法主体包含方法被调用时实际执行的语句。此外，还可向方法提 供数据供处理，并让它返回处理结果。方法是一个基本的、强大的编程机制。 
声明方法 声明C#方法的语法如下所示： 
returnType methodName (parmeterlist)
{
	//这里添加方法主体语句
}
returnType(返回类型)是类型名称，指定方法返回的数据类型。可以是任何类型， 如 int 或 string。要写不返回值的方法，必须用关键字 void 取代 returnType。
methodName(方法名)是调用方法时所用的名称。方法名和变量名遵循相同的标识符命名规则。例如，addValues 是有效方法名，而add$Values不是。应该为方法 名采用camelCase 命名风格，例如 displayCustomer(显示客户)。 
parameterList(参数列表)是可选的，描述了允许传给方法的数据的类型和名称。 在圆括号内填写参数列表时，要像声明变量那样，先写类型名，再写参数名。两个或更多参数必须以逗号分隔。 
方法主体语句是调用方法时要执行的代码。必须放到大括号({})中。 
重要提示  C，C++和Microsoft Visual Basic 程序员注意，C#不支持全局方法。所有方法必须在类的内部，否则无法编译。 
以下是 addValues 方法的定义，它返回 int 值，获取两个 int 参数 leftHandSide 和 rightHandSide： 
int addValues(int leftHandSide, int rightHandSide)
{
	//....
	//这里添加主体语句
	//
}
注意 必须显式指定方法的参数类型和返回类型。不能使用 var 关键字。
以下是 showResult 方法的定义，它不返回任何值，获取名为answer的一个int参数： 
void showResult(int answer)
{
	//.....
}
注意，要用关键字 void 来指定方法不返回任何值。 
重要提示 Visual Basic 程序员注意，C#不允许使用不同的关键字来区分返回值的方法(VB称为函数)和不返回值的方法(VB称为过程、子例程或者子程序)。C#要么显式指定返回类型，要么指定 void。 
从方法返回数据 
如果希望方法返回数据(返回类型不是 void)，必须在方法内部写 return 语句。为此，请先写关键字return，然后添加计算返回值的表达式，最后写分号。表达式的类型必须与方法指定的返回类型相同。也就是说，假如函数返回 int值，则 return 语句必须返回 int，否则程序无法编译。下面是一个例子：
int addValues(int leftHandSide)
{
	//.....
	return leftHandSides + rightHandSides;
}
return 通常放到方法尾部，因其导致方法结束，控制权返回调用方法的那个语句， return 后的任何语句都不执行(如果 return 语句之后有其他语句，编译器会发出警告)。 
如果不希望方法返回数据(返回类型 void)，可利用 return 语句的一个变体立即从方 法中退出。为此，请先写关键字 return，紧跟一个分号。如下所示： 
void showResult(int answer)
{
	//显示answer
	//Console.WriteLine($"The answer is {answer}");
	return;
}
如果方法什么都不返回，甚至可以省略 return 语句，因为一旦执行到方法尾部的结束 大括号(})，方法就会自动结束。可以这样写，但不推荐。 
使用表达式主体方法 
有的方法十分简单，就是执行单一任务或返回计算结果，不涉及任何额外逻辑。C#允 许以一种简化的形式写由单个表达式构成的方法。这种方法仍然可以获取参数并返回值， 和以前见过的方法并无二致。以下代码是 addValues 和 showResult 方法的简化版本： 
int addValues(int leftHandSide, int rightHandSide) => leftHandSide + rightHandSide; 
void showResult(int answer) => Console.WriteLine($"The answer is {answer}"); 
主要区别是使用=>操作符引用构成方法主体的表达式，而且没有 return 语句。表达式 的值自动作为返回值。如表达式不返回值，则为 void 方法。 
表达式主体方法和普通方法在功能上实际并无区别，只是语法简化了。类似这样的设 计称为语法糖。以后会看到表达式主体方法省略了大量多余的{和}字符，使代码更易读， 使程序更清晰。 
分析方法定义 
1. 如果 Visual Studio 2017 尚未运行，请启动它。 
2. 打开“文档”文件夹中的\Microsoft Press\VCSBS\Chapter 3\Methods 子文件夹中的 Methods 解决方案。 
3. 在“调试”菜单中选择“开始调试”。 
4.  Visual Studio 2017 生成并运行应用程序。显示结果和第 2 章的应用程序一样。 重新熟悉一下这个应用程序，体会它如何工作。最后返回 Visual Studio 2017，选择 “调试”|“停止调试”。 
5. 在“代码和文本编辑器”窗口中显示 MainPage.xaml.cs 文件的代码。(在“解决方 案资源管理器”中展开 MainPage.xaml，再双击 MainPage.xaml.cs。) 
6. 在“代码和文本编辑器”窗口中找到 addValues 方法，如下所示
private int addValues(int leftHandSide, int rightHandSide)
{
	expression.Text = $"{leftHandSide}"+"{rightHandSide}";
	return leftHandSide +  rightHandSide;
}
addValues方法包含两个语句。第一个在窗体上的 expression 框中显示算式。 
第二个语句使用+操作符的 int 版本计算 int 变量 leftHandSide 和 rightHandSide 之和，并返回结果。记住两个 int 相加结果也是 int，所以 addValues方法的返回类型是 int。 
subtractValues，multiplyValues，divideValues 和 remainderValues方法采 用的是类似的模式。 
7. 在“代码和文本编辑器”窗口中找到 showResult 方法，如下所示： 
private void showResult(int answer) => result.Text = answer.ToString(); 
这是一个表达式主体方法，作用是在 result 框中显示 answer 参数值的字符串形 式。由于不返回值，所以方法返回类型是 void。 
提示 方法最小长度没有限制。能用方法避免重复，并使程序更易读，就应毫不犹豫使 用方法——不管该方法有多小。同样，方法最大长度也没有限制。但应该保持方 法代码的精炼，足够完成一项任务就可以了。如果方法长度超过一个屏幕，就考 虑分解成更小的方法来增强可读性。
调用方法 
方法终极目的就是被调用！用方法名调用方法，指示它执行既定任务。如方法要获取 数据(由参数决定)，就必须提供这些数据。要返回数据(由返回类型决定)，就应以某种方式 捕捉返回的数据。 
方法的调用语法 
调用 C#方法的语法如下： 
result = methodName ( argumentList ) 
methodName(方法名)必须与要调用的方法的名称完全一致。记住 C#区分大小写。
result =这个部分可选。如指定，result 变量将包含方法返回值。如果返回类型 是 void(不返回任何值)，就必须省略 result =。如果省略 result，同时方法返回 值，那么方法虽会运行，但返回值会被丢弃。 
argumentList(实参列表)提供由方法接收的数据。必须为每个参数(形参)提供参 数值(实参)，而且每个实参都必须兼容于形参的类型。如果方法有两个或更多参 数，那么提供实参时必须以逗号分隔不同实参。 
重要提示  每个方法调用都必须包含一对圆括号，即使调用无参方法。 
为加深印象，下面再次列出 addValues 方法： 
int addValues(int leftHandSide, int rightHandSide)
{
 	//
}
addValues 方法有两个 int 参数，所以调用时必须提供两个以逗号分隔的 int 实参， 如下所示： 
addValues(39, 3); // 正确方式 
还可将 39 和 3替换成 int 变量名。int 变量值会作为实参传给方法，如下所示： 
int arg1 = 99; int arg2 = 1; addValues(arg1, arg2); 
下面列举了错误的 addValues 调用方式： 
addValues;     // 编译错误，无圆括号 
addValues();     // 编译错误，无足够实参 
addValues(39);    // 编译错误，无足够实参 
addValues("39", "3");  // 编译错误，类型错误 
addValues方法返回 int 值，可在允许使用 int 值的任何地方使用它。例如： 
int result = addValues(39, 3);   // 作为赋值操作符的右操作数 
showResult(addValues(39, 3));   // 作为实参传给另一个方法调用 
使用 Methods 应用程序,分析方法调用 
1. 返回 Methods 项目。如果刚完成上一个练习，该项目应该已经在 Visual Studio 2017 中打开；否则从“文档”文件夹的\Microsoft Press\VCSBS\Chapter 3\Methods 子文 件夹中打开。 
2. 在“代码和文本编辑器”窗口中显示 MainPage.xaml.cs 文件的代码。  
3. 找到 calculateClick 方法，观察 try{之后的两个语句。 
int leftHandSide = System.Int32.Parse(lhsOperand.Text); int rightHandSide = System.Int32.Parse(rhsOperand.Text); 
这两个语句声明 int 变量 leftHandSide 和 rightHandSide。注意变量的初始化方式。两个语句都调用了 System.Int32 结构的 Parse 方法(System 是命名空间，Int32 是该命名空间中的结构)。以前见过该方法，它获取一个 string 并把它转 换成 int。执行这两个语句后，用户在窗体上的 lhsOperand 和 rhsOperand 文本 框中输入的任何内容都会转换成 int 值。 
4. 观察 calculateClick 方法的第 4 个语句(在 if 语句和另一个起始大括号之后)： 
calculatedValue = addValues(leftHandSide, rightHandSide); 
该语句调用 addValues 方法，将 leftHandSide 和 rightHandSide 变量值作为实 参传递。addValues 方法的返回值将存储到 calculatedValue 变量中。 
5. 再看下一个语句： 
showResult(calculatedValue); 
该语句调用 showResult 方法，将 calculatedValue 变量值作为实参传递。 showResult方法不返回值。 
6. 在“代码和文本编辑器”窗口中找到前面讨论过的 showResult 方法。该方法只有一个语句，如下所示： 
result.Text = answer.ToString(); 
注意，即使无参，调用 ToString 方法也要添加圆括号。 
提示 调用其他对象的方法时，要在方法名前面附加对象名前缀。在上例中，表达式 answer.ToString()调用 answer对象的 ToString 方法。 
从方法返回多个值 
有时想从方法返回多个值。例如在Methods项目中，divideValues和remainderValues 这两个操作可合并成单个方法，一次性返回两个操作数的商和余。 
这可通过返回元组（tuple）来实现。元组其实就是一个小的值的集合。在方法定义中 指定一个类型列表即可指示它返回元组。与此同时，方法主体中的 return 语句也要指定返 回一个值列表。注意类型必须一一对应。 
(int, int) returnMultipleValues(...) 
{
	int val1;
	int val2;
	...//计算val1和val2的值
	return
}
调用方法时需提供对应的变量列表来容纳结果。
int retVal1,retVal2;
(retVal1,retVal2) = returnMultipleValues(...);

演示如何创建和调用返回元组的方法。 
创建和调用返回元组的方法 
1. 返回 Methods 项目。在“代码和文本编辑器”窗口中显示 MainPage.xaml.cs  
2. 找到 divideValues 和remainderValues 方法并将它们删除。 
3. 添加以下方法： 
private (int, int) divide(int leftHandSide, int rightHandSide)
{
} 
该方法返回两个值的一个元组，对应 leftHandSide 和 rightHandSide 变量的商和余。
4. 在方法主体添加以下加粗的代码，计算并返回包含结果的元组： 
private (int, int) divide(int leftHandSide, int rightHandSide) 
{
	expression.Text = $"{leftHandSide} / {rightHandSide}";     
	int division = leftHandSide / rightHandSide;     
	int remainder = leftHandSide % rightHandSide;     
	return (division, remainder); 
}
5. 在 calculateClick 方法中找到比较靠后的以下代码：
else if (division.IsChecked.HasValue && division.IsChecked.Value) 
{    
 calculatedValue = divideValues(leftHandSide, rightHandSide);     
 showResult(calculatedValue); 
} 
else if (remainder.IsChecked.HasValue && remainder.IsChecked.Value) 
{   
 calculatedValue = remainderValues(leftHandSide, rightHandSide);     
 showResult(calculatedValue); 
} 
6. 删除这些代码。divideValues 和 remainderValues 方法不复存在，被替换成了单 个 divide 方法。 
7. 将删除的内容替换成以下代码
else if (division.IsChecked.HasValue && division.IsCheck.Value)
{
	int  division, remainder;
	(divison,remainder) = divide(leftHandSide);
	result.Text = $"{division} remainder {remainder}";
}
代码调用divide方法，在result文本框显示返回值。
8. 在解决方案资源管理器中双击 MainPage.xaml，在设计视图中显示窗体。 
9. 单击% Remainder 单选钮，按 Delete 键从窗体上删除。 
10. 选择“工具”|“NuGet 包管理器”|“管理解决方案的 NuGet 程序包”。 
 “NuGet 包管理器”允许为项目安装额外的包和库。我们需要安装元组支持包。 
11. 单击“浏览”标签。 
12. 在搜索框中输入 ValueTuple。 
13. 在搜索结果中单击 System.ValueTuple(应该是第一项)。 
14. 在右侧窗格勾选“项目”，单击“安装”。 
15. 在“预览更改”对话框中单击“确定”，确认想要安装这个包。 
16. 包安装好之后，选择“调试”｜“开始调试”来生成并运行应用程序。 
17. 在 Left Operand 框中输入 59，在 Right Operand 框中输入 13，单击/ Division，再单 击 Calculate。 
18. 验证 Result 框显示消息“4 remainder 7”（商 4 余 7）。 

使用作用域 
创建变量目的是容纳值。可在应用程序的多个位置创建变量。例如，Methods 项目的 calculateClick方法创建 int 变量 calculatedValue，把它初始化为 0。如下所示：
private void calculateClick(object sender,RoutedEventArgs e)
{
	int calculatedValue = 0;
	......
} 
变量有效期(生存期)始于定义位置，终于方法结束时。换言之，在同一个方法内，后续 语句都可使用该变量(变量创建并赋值后才能使用)。方法执行完毕，变量随之消失，不可在 别的地方使用。 
如某变量能在程序特定位置使用，就说该变量在那个位置“处于作用域内”或者说“在范围中”。calculatedValue变量具有方法作用域，能在calculateClick方法内访问，但在方法外部不能。还可定义其他作用域的变量；例如可定义在方法外部，但在类内 部的变量，该变量可由类内的所有方法访问。我们说该变量具有类作用域。 
换言之，变量作用域或范围是指该变量能起作用的程序区域。除了变量有作用域，方 法也有。标识符(无论代表变量还是方法)的作用域和它的声明位置有关，稍后会具体解释。
定义局部作用域 
界定方法主体的大括号({})定义了方法作用域。方法主体声明的任何变量都具有那个方法的作用域；方法结束，它们也随之消失。另外，它们只能由方法内部的代码访问。这种变量称为局部变量，因其局限于声明它们的方法，不在其他任何方法的作用域中。换言之，不能利用局部变量在不同方法之间共享信息。例如：
class Example 
{
	void firstMethod()
	{
		int myVar;
		....
	}
	void anotherMethod()
	{
		myVar = 42;
	}
}
上述代码无法编译，因为 anotherMethod 方法试图使用不在其作用域内的 myVar 变 量。myVar 变量只供 firstMethod 方法中的语句使用，而且必须是声明 myVar 变量之后的 语句。
定义类作用域 
界定类主体的大括号({})定义了类作用域。在类主体中(但不能在某个方法中)声明的任 何变量都具有那个类的作用域。类定义的变量称为字段。和局部变量相反，可用字段在不同方法之间共享信息。例如： 
class Example
{
	void firstMethod()
	{
		myField = 42;//ok
		...
	}
	void atotherMethod()
	{
		myField ++; //ok
	}
	int myField = 0;
}
变量 myField 在类内部定义，而且位于 firstMethod 和 anotherMethod 方法外部，所 以具有类作用域，可由类的所有方法使用。 
这个例子还有一点要注意。方法中的变量必须先声明再使用，但字段不同，可在类的任何位置定义。可先在方法中使用字段，再在方法后声明字段，让编译器来打点一切。
重载方法 
两个标识符同名，而且在同一个作用域中声明，就说它们被重载(overloaded)。重载的标识符通常是bug，会在编译时捕捉到并报错。例如，在同一个方法中声明两个同名局部变量会报告编译错误。类似地，在同一个类中声明两个同名字段，或者在同一个类中声明两个完全一样的方法，也会报告编译错误。这表面上似乎不值一提，因为反正编译时都会报错。但确实有一个办法能真正地、不报错地重载标识符。这种重载不仅有用，而且必要。 以 Console 类的 WriteLine方法为例，以前曾用该方法向屏幕输出字符串。但在“代码和文本编辑器”窗口中键入WriteLine后，会自动弹出“智能感知”列表，其中列出了19个不同的版本！每个版本都获取一组不同的参数。其中有个版本不获取任何参数只是输出空行；有个版本获取一个bool参数并输出它的字符串形式(True 或 False)还有一个版本获取一个decimal参数并输出它的字符串形式，等等。程序编译时，编译器检查实参类型并调用与之匹配的版本。下面是一个例子：    
 static void Main()
 {
 	Console.WriteLine("The answer is");
 	Console.WriteLine(42);
 }
要针对不同数据类型或不同信息组别执行相同的操作，重载是一项十分有用的技术。 如方法有多个实现，每个实现都有不同的参数集，就可重载该方法。这样每个版本都有相同的方法名，但有不同的参数数量或者/以及不同的参数类型。调用方法时，提供以逗号分 隔的实参列表，编译器根据实参数量和类型来选择匹配的重载版本。但要注意，虽然能重 载方法的参数，但不能重载方法的返回类型。也就是说，不能声明仅返回类型有别的两个 方法(编译器虽然很聪明，但还没有聪明到那种程度)。
编 写 方 法 
练习创建方法来计算一名顾问的收费金额，假定该顾问每天收取固定费用。首先 制定程序逻辑，再利用“生成方法存根向导”写出符合该逻辑的方法。接着在控制台应用 程序中运行方法，以便对程序有一个印象。最后用 Visual Studio 调试器检查方法调用。 
制定应用程序逻辑
1. 在 Visual Studio 2017 中打开“文档”文件夹下的\Microsoft Press\VCSBS\Chapter 3\DailyRate 子文件夹中的 DailyRate 解决方案。 
2. 在“解决方案资源管理器中”双击 Program.cs 文件，在“代码和文本编辑器”窗 口中显示代码。该程序只是作为代码的测试床使用。应用程序运行时会调用 run 方法。方法中包含要测试的代码。
3. 在 run 方法主体的大括号之间添加以下加粗显示的语句： 
void run()
{
	double dailyRate = readDouble("Enter your daily rate:");
	int noOfDays = readInt("Enter the number of the days:");
	write3Fee(calculateFee(dailyRate,noOfDays));
}
第一个语句调用 readDouble 方法(马上写)，要求用户输入顾问每天收费金额。下 个语句调用 readInt 方法(也是马上写)来获取天数。最后调用 writeFee 方法(马 上写)在屏幕上显示结果。注意传给 writeFee 的是 calculateFee 方法(最后一个 要写的方法)的返回值，后者获取每天收费金额和天数，计算要支付的总金额。 
使用“生成方法存根向导”编写方法 
1. 在“代码和文本编辑器”窗口中右击 run 方法中的 readDouble 方法调用。 
2. 从弹出菜单选择“快速操作和重构”。 (Visual Studio 发现 readDouble 方法不存在，所以打开一个向导允许你生成该方法 的存根。它会根据 readDouble 调用来确定参数和返回值类型，并 推荐一个默认实现)。
3. 单击“生成方法"Program.readDouble"”，Visual Studio 随后会在代码中添加以下方法： 
private double readDouble(string v)
{
	throw new NotImplementedException();
}
 新方法使用 private 限定符创建，方法主体目前 只是抛出 NotImplementedException 异常。将在下一步将 主体替换成自己的代码。 
 4. 从 readDouble 方法中删除 throw 语句，替换成以下加粗显示的代码： 
private double readDouble(string v)
{
	Console.Write(v);
	string line = Console.ReadLine();
	return double.Parse(line);
}
上述代码将变量 v 中的字符串输出到屏幕。v 是调用方法时传递的字符串参数， 其中包含提示输入每日收费金额的消息。 
注意 Console.Write 方法与前几个练习中的 Console.WriteLine 方法很相似，只是 最后不输出换行符。 
用户输入一个值，该值被 ReadLine 方法读入一个字符串中，并通过 double.Parse 方法转换成 double 值。结果作为方法调用的返回值传回。 
注意 ReadLine 方法是与 WriteLine 配对的方法；它读取用户的键盘输入，并在用户 按 Enter 键时结束读取。用户输入的文本作为 String 值返回。 
5. 在 run 方法中右击 readInt 方法调用，从弹出菜单中选择“快速操作和重构”。 用同样的方式生成如下所示的 readInt 方法： 
private double readDouble(string v)
{
	throw new NotImplementedException();
}
6. 将 readInt 方法主体中的 throw 语句替换成以下加粗的代码
private double readDouble(string v)
{
	Console.Write(v);
	string line = Console.ReadLine();
	return double.Parse(line);
}
这个代码块和 readDouble 方法很相似。唯一区别是返回 int 值，所以要用 int.Parse方法将用户输入的字符串转换成整数。 
7. 在 run 方法中右击 calculateFee 方法调用，从弹出菜单中选择“快速操作和重 构”。用同样的方式生成如下所示的 calculateFee 方法： 
private double readDouble(string v)
{
	throw new NotImplementedException();
}
注意，Visual Studio 根据传递的实参来生成形参名称。觉得不合适可以更改。更让 人感兴趣的是，方法的返回类型是 object。这表明 Visual Studio 无法根据当前上 下文判断方法返回什么类型的值。object 类型意味着可能返回任何“对象”；在方法中添加具体的代码时，应把它修改成自己需要的类型。
8. 修改 calculateFee 方法定义使它返回一个 double：
private double readDouble(string v)
{
	throw new NotImplementedException();
}
9. 修改 calculateFee 方法主体，把它变成表达式主体方法。删除大括号，用=>指定 方法主体。该表达式计算两个参数值的乘积。 
private double calculateFee(double dailyRate, int noOfDays) => dailyRate * noOfDays; 
10. 右击 run 方法中的 writeFee 方法调用，选择“快速操作和重构”，单击“生成方 法"Program.writeFee"”。 
注意，Visual Studio 根据 calculateFee 方法的定义推断 writeFee 方法的参数应 该是一个 double。另外，由于方法调用没有使用返回值，所以返回类型是 void：
private void writeFee(double v)
{
	...
}
11. 将 writeFee 方法主体替换成以下加粗语句，计算费用，增加 10%佣金。同样改成 表达式主体方法。 
private void writeFee(double v) => Console.WriteLine($"The consultant's fee is: {v * 1.1}"); 
12. 在“生成”菜单中选择“生成解决方案”。 

 嵌套方法 
大方法有时需要分割成小的辅助方法，以测试复杂功能，并验证大方法的每一部分都 能良好工作。这还有助于增强可读性，并使大方法更容易维护。 
注意 “大方法”和“辅助方法”并非 C#的官方术语。我只是说一个方法（大方法）可以分解成更小的部分（辅助方法）方法（无论大方法还是辅助方法）默认可在定义它的类中访问，并可从类的其他任何方法中调用。但由于辅助方法仅由一个大方法使用，所以有必要使它们局部于调用它们的大方法。这样可确保辅助方法在给定上下文中工作，防止不慎被别的方法使用。这是实现封装的一个好的实践，大方法（包括它调用的辅助方法）的内部工作方式在别的方法那里 是看不见的。这个实践减少了大方法之间的依赖性，可安全修改大方法及其调用的辅助方 法的实现，不至于影响到应用程序的其他元素。 
如下个练习所示，为了创建辅助方法，需要把它们嵌套到大方法内部。该练习计算阶 乘。可以用阶乘（factorial）计算 n 个项有多少排列方式。正整数 n 的阶乘用递归方式定义 成 n * factorial (n – 1)，其中 1 的阶乘是 1.例如，3 的阶乘是 3 * factorial(2)，后者等于 2 * factorial(1)，后者等于 1。所以计算结果是 3 * 2 * 1 = 6。包含 3 项的一个集合可以有6种不同的排列组合。类似地，4项有24种排列组合(4*factorial(3))；5 项则有 120 种排列组合 (5 * factorial(4))。 
计算阶乘 
1. 如果 Visual Studio 2017 尚未运行，请启动它。  
2. 打开位于“文档”文件夹下的\Microsoft Press\VCSBS\Chapter 3\Factorial 子文件夹中的 Factorial 解决方案。
3. 双击 Program.cs 显示代码。 
4. 在 run 方法中添加以下加粗语句： 
void run()
{
	Console.Write("Please enter a positive intenger:");
	string inputValue = Console.ReadLine();
	long factorialValue = CalculateFactorial(inputValue);
	Console.WriteLine($"Factorial({inputValue}))is {factorialValue}");
}
代码提示输入一个正整数，把它传给 CalculateFactorial 方法再显示结果。 
5. 在 run 方法后添加新方法 CalculateFactorial，获取字符串参数 input，返回一个long：
long CalculateFactorial(string input)
{
}
6. 在 CalculateFactorial 方法起始大括号后添加加粗的语句
long CalculateFactorial(string input)
{
	int intputValue = int.Parse(input);
}
语句将输入的字符串值转换为整数。
7. 在 CalculateFactorial 方法中添加嵌套方法 factorial，获取一个 int，返回一个long。该方法负责实际的阶乘计算。 
long CalculateFactorial(string input)
{
	int inputValue = int.Parse(input);
	long factorial (int dataValue);
	{
	}
}
8. 在 factorial 方法主体中添加以下加粗的语句。代码用之前描述的递归算法计算 输入值的阶乘。
long CalculateFactorial(string input)
{
	int inputValue = int.Parse(input);
	long factorial (int dataValue);
	{
		if (dataValue == 1)
		{
			return 1;
		}
		else
		{
			return dataValue*factorial(data\Value - 1);
		}
	}
}
9. 在 CalculateFactorial 方法中调用 factorial 方法，传递输入值并返回结果：
long CalculateFactorial(string input)
{
	int inputValue = int.Parse(input);
	long factorial (int dataValue);
	{
		if (dataValue == 1)
		{
			return 1;
		}
		else
		{
			return dataValue*factorial(data\Value - 1);
		}
	}
	long factorialValue = factorial(inputValue);
	return factorialValue;
}
10. 在“调试”菜单中选择“开始执行(不调试)”。 
 Visual Studio 2017 生成并运行程序，显示控制台窗口。 
11. 在 Please enter a positive integer (输入正整数)提示之后输入 4 并按 Enter 键。 
 程序在控制台窗口显示以下消息： 
Factorial(4) is 24 
12. 按 Enter 键关闭应用程序并返回 Visual Studio 2017。 
void run()
13. 再次运行程序并输入 5，这次显示： 
Factorial(5) is 120 
14. 请自行尝试其他值。如输入的数字太大（例如 60），结果会超出 long 的范围，所 以会看到不正确的结果。

使用可选参数和具名参数 
开发人员完全可能采用其他语言和技术生成 Windows 应用程序和组件，那些语言和技术可能并不遵守这些规则。C#和其他.NETFramework语言的一个重要特点是能与使用其他技术开发的应用程序和组件进行互操作。“组件对象模型”(Component Object Model， COM)是在.NET Framework 外部运行的 Windows 应用程序和服务所使用的一项基本技术。 (事实上，.NET Framework 使用的公共语言运行时也严重依赖于 COM，Windows 10 的 Windows Runtime 也是如此。)COM不支持重载方法；相反，它允许方法获取可选参数。为了方便在 C#解决方案中集成 COM 库和组件，C#也支持可选参数。
可选参数在其他情况下也很有用。有时参数类型的差异不足以使编译器区分不同的实现，造成无法使用重载技术。这时可选参数能提供一个简单、好用的解决方案。例如以下方法：
public void DoWorkWithData(int intData, float floatData, int moreIntData)
{
	...
}
DoWorkWithData方法获取三个参数，包括两个 int 和一个 float。现在，假定要提供 只获取两个参数(intData 和 floatData)的一个实现： 
public void DoWorkWithData(int intData, float floatData) 
{
	...
}
调用 DoWorkWithData 方法时，可提供恰当类型的两个或三个参数，编译器根据参数 类型判断调用哪个重载版本： 
int arg1 = 99;
float arg2 = 100.0F;
int args = 101;
DoWorkWithData = (arg1, arg2, arg3); //调用三个参数的重载版本
DoWorkWithData = (arg1, arg2);   // 调用两个参数的重载版本
到目前为止一切还好。但要实现 DoWorkWithData 的另外两个版本，只获取第一个参数和第三个参数，那么或许会草率地写出以下重载版本：
public void DoWorkWithData(int intData)
{
	...
}
public void DoWorkWithData(int moreIntData)
{
	...
}
问题在于，对于编译器，这两个重载版本完全一样，程序无法编译。编译器报告以下 错误：“类型"typename"已定义了一个名为"DoWorkWithData"的具有相同参数类型的成员。” 
定义可选参数 
指定可选参数是在定义方法时使用赋值操作符为该参数提供默认值。以下 optMethod 方法的第一个参数是必需的，因其没有提供默认值，但第二个和第三个参数可选： 
void optMethod(int first,double second 0.0,string third = "Hello")
{
	...
}
可选参数只能放在必需参数之后。 
含可选参数的方法在调用方式上与其他方法无异。都是指定方法名，提供任何必需参数(实参)。区别在于，与可选参数对应的实参可以省略，方法运行时会为省略的实参使用默认值。下例第一个optMethod方法调用为三个参数都提供了值。第二个调用只提供了两个值，对应第一个和第二个参数。方法运行时，第三个参数使用默认值"Hello"： 
optMethod(99, 123.45, "World");  // 全部三个参数都提供了实参 
optMethod(100, 54.321);   // 只为前两个参数提供了实参
传递具名参数 
C#默认根据每个实参在方法调用中的位置判断对应形参。所以在上一节第二个示例方法调用中，两个实参分别传给optMethod方法的first和second形参，因为它们在方法声明中的顺序如此。C#还允许按名称指定参数。这样就可按照不同顺序传递实参。要将实 参作为具名参数传递，必须输入参数名，一个冒号，然后是要传递的值。下例执行和上一 节的例子相同的功能，只是参数按名称指定： 
optMethod(first : 99, second : 123.45, third : "World"); 
optMethod(first : 100, second : 54.321); 
具名参数允许实参按任意顺序传递。可像下面这样重写 optMethod 方法调用： 
optMethod(third : "World", second : 123.45, first : 99); 
optMethod(second : 54.321, first : 100); 
还允许省略实参。例如，调用 optMethod 方法时，可以只指定 first 和 third这两个 参数的值，second 参数使用默认值。如下所示： 
optMethod(first : 99, third : "World"); 
还可兼按位置和名称指定实参。但要求先指定按位置的实参，再指定具名的实参： 
optMethod(99, third : "World");  // 第一个实参按位置来定 

消除可选参数和具名参数的歧义 
使用可选参数和具名参数可能造成歧义。需要知道编译器如何解决歧义，否则可能得 到出乎预料的结果。假定 optMethod 被定义成重载方法
void optMethod(int first, double second = 0.0, string third = "Hello") 
{
	...
}
void optMethod(int first, double second = 1.0, string third = "Goodbye", int fourth = 100 ) 
{
	...
}
这是完全合法的 C#代码，符合方法重载规则。编译器能区分两个方法，因为两者的参 数列表不同。但如果调用 optMethod 方法，忽略与一个或多个可选参数对应的实参，就可能出问题:
	optMethod(1, 2.5, "World"); 
同样合法，但应该调用哪个版本？答案是和方法调用最匹配的。所以，最后选择获取3 个参数的版本，而不是获取4个参数的版本。这确实说得通。再来看看以下调用： 
optMethod(1, fourth : 101); 在上述代码中，对optMethod的调用省略了second和third参数的实参，但通过具名参数的形式为fourth参数提供了实参。optMethod只有一个版本能匹配这个调用，所以这不是问题。但下面这个调用就有点儿伤脑筋了：  
	optMethod(1, 2.5); 
这次 optMethod 的两个版本都不能完全匹配提供的实参。两个版本中，second，third 和 fourth 都是可选参数。所以，应该选择获取3个参数的版本，为third参数使用默认值，还是选择获取4个参数的版本，为third和fourth 参数使用默认值？答案是两个都 不选。编译器认为这是有歧义的方法调用，所以不允许编译。以下 optMethod 方法调用都有歧义：
 optMethod(1,third : "World");
 optMethod(1);
 optMwthod(second: 2.5,first :1);
 定义并调用获取可选参数的方法  
1. 在 Visual Studio 2017 中打开“文档”文件夹下的\Microsoft Press\VCSBS\Chapter 3\DailyRate Using Optional Parameters 子文件夹中的 DailyRate 解决方案。 
2. 在“解决方案资源管理器”中双击 Program.cs，在“代码和文本编辑器”窗口中 显示代码。目前基本是空白的，只有 Main 方法以及 run 方法的架子。 
3. 在 Program 类的 run 方法后添加 calculateFee 方法。它和上一组练习实现的方 法相似，只是要获取两个具有默认值的可选参数。还要打印一条消息，指出调用的是哪个版本的calculateFee。(将在后续步骤中添加方法的重载实现。)
private double calculateFee(double dailyRate = 500.0, int noOfDays = 1) 
{
	Console.WriteLine("calculateFee using two optional parameters"); 
	int  defaultNoOfDays = 1; 
	return dailyRate * defaultNoOfDays; 
}
5. 添加 calculateFee 的第三个实现。该版本无参，使用硬编码的每日费率(400 元) 和收费天数(1天）。
private double calculateFee(double dailyRate = 500.0, int noOfDays = 1) 
{
	Console.WriteLine("calculateFee using hardcoded values");
	double defaultDailyRate = 400.0;
	int  defaultNoOfDays = 1; 
	return dailyRate * defaultNoOfDays; 
}
6. 在 run 方法中添加以下加粗语句来调用 calculateFee 并显示结果。 
public void run() 
{     
	double fee = calculateFee();     
	Console.WriteLine($"Fee is {fee}"); 
} 
7. 在“调试”菜单中选择“开始执行(不调试)”来生成并运行程序。程序在控制台窗 口中运行，显示以下消息： 
 calculateFee using hardcoded values Fee is 400 
 run 方法调用的是 calculateFee 的无参版本，而不是任何获取可选参数的版本。 这是由于该版本和方法调用最匹配。 
 按任意键关闭控制台窗口并返回 Visual Studio。 
8. 在 run 方法中修改调用 calculateFee 的语句(加粗部分)： 
public void run() 
{     
	double fee = calculateFee(650.0); 
	Console.WriteLine($"Fee is {fee}"); 
} 
9. 在“调试”菜单中选择“开始执行(不调试)”生成并运行程序。程序在控制台窗口 中运行，显示以下消息： 
calculateFee using one optional parameter Fee is 650 
 这次调用 calculateFee 获取一个可选参数的版本，仍然和方法调用最匹配。 
 按任意键关闭控制台窗口并返回 Visual Studio。 
10. 在 run 方法中再次修改调用 calculateFee 的语句： 
public void run() 
{     
	double fee = calculateFee(500.0, 3);     
	Console.WriteLine($"Fee is {fee}"); 
} 
11. 在“调试”菜单中选择“开始执行(不调试)”来生成并运行程序。程序在控制台窗 口中运行，显示以下消息： 
calculateFee using two optional parameters Fee is 1500 
 这次调用 calculateFee 获取两个可选参数的版本。 
 按任意键关闭控制台窗口并返回 Visual Studio。 
12. 在 run方法中修改调用 calculateFee的语句，通过名称指定 dailyRate参数值： 
 
public void run() 
{     
	double fee = calculateFee(dailyRate : 375.0);     
	Console.WriteLine($"Fee is {fee}"); 
} 
13. 在“调试”菜单中选择“开始执行(不调试)”来生成并运行程序。程序在控制台窗 口中运行，显示以下消息： 
calculateFee using one optional parameter Fee is 375 
 和步骤 8 一样，调用的是 calculateFee 获取一个可选参数的版本。虽然使用了具 名参数，但编译器对方法调用进行解析的方式没有发生改变。 
 按任意键关闭控制台窗口并返回 Visual Studio。 
14. 在 run 方法中修改调用 calculateFee 的语句，通过名称指定 noOfDays 参数值：
public void run() 
{ 
	 double fee = calculateFee(noOfDays : 4);     
	 Console.WriteLine($"Fee is {fee}"); 
} 
15. 在“调试”菜单中选择“开始执行(不调试)”来生成并运行程序。程序在控制台窗 口中运行，显示以下消息： 
calculateFee using two optional parameters Fee is 2000 
 这次调用 calculateFee 获取两个可选参数的版本。调用中省略了第一个参数 (dailyRate)，并通过名称指定了第二个参数的值。获取两个可选参数的 calculateFee 是唯一匹配的版本。 
 按任意键关闭控制台窗口并返回 Visual Studio。 
16. 修改获取两个可选参数的 calculateFee 方法的实现。将第一个参数的名称更改 为 theDailyRate，并更新 return 语句，如以下加粗的部分所示： 
private double calculateFee(double theDailyRate = 500.0, int noOfDays = 1) 
{     
	Console.WriteLine("calculateFee using two optional parameters");     
	return theDailyRate * noOfDays; 
} 
17. 在 run 方法中修改调用 calculateFee 的语句，然后通过名称指定 theDailyRate 参数值： 
public void run() 
{     
	double fee = calculateFee(theDailyRate: 375.0);     
	Console.WriteLine($"Fee is {fee}"); 
} 
18. 在“调试”菜单中选择“开始执行(不调试)”来生成并运行程序。程序在控制台窗 口中运行，显示以下消息： 
calculateFee using two optional parameters Fee is 375 
这次调用获取两个可选参数的版本，仍然最匹配，因为只有该版本有 theDailyRate 参数名。提供具名参数，编译器会将参数名和方法声明中指定的参 数名比较，并选择参数名称匹配的方法。如调用时提供的实参是 aDailyRate: 375.0，程序就无法编译了，因为找不到和该名称匹配的参数。 
按任意键关闭控制台窗口并返回 Visual Studio。 

声明方法 
在类内部写方法。指定方法名，参数列表和返回类型。后面是 一对大括号中的方法主体。示例如下： 
int addValues(int leftHandSide, int rightHandSide) 
{     
	... 
} 
从方法返回值
在方法内部写return语句。示例如下： 
return leftHandSide + rightHandSide;
从方法提前返回 
使用单独的 return语句： 
return; 
定义表达式主体方法 
用=>加表达式来定义方法主体，最后添加分号。示例如下： 
double calculateFee(double dailyRate, int noOfDays) 
=> dailyRate * noOfDays; 
调用方法 
写方法名，在圆括号中添加必要的实参。示例如下： 
addValues(39, 3); 
调用返回元组的方法 
还是像上面那样调用方法，但将结果赋给一组圆括号中的变 量。返回的元组中的每个值都对应一个变量。示例如下：  
int division, remainder; 
(division, remainder) = divide(leftHandSide, rightHandSide); 
使用“生成方法存根向导”
右击方法调用，从弹出菜单中选择“快速操作和重构” 
创建嵌套方法 
在方法主体中定义另一个方法。示例如下： 
long CalculateFactorial(string input) 
{   
	...   
	long factorial (int dataValue)   
		{     
			if (dataValue == 1)     
				{        
					return 1;      
				}      
			else      
				{        
					return dataValue * factorial(dataValue - 1);      
				}   
		} 
	... 
} 
显示“调试”工具栏 
选择“视图”|“工具栏”，勾选“调试” 
跳入方法并逐语句调试(Step into) 
单击“调试”工具栏中的“逐语句”按钮，或者从菜单栏选择 “调试”|“逐语句”，或者按 F11 
跳出方法，忽略对方法中的其他语句的 调试，一路执行到方法尾(Step out)
单击“调试”工具栏中的“跳出”按钮，或者从菜单栏选择“调 试”|“跳出”，或者按组合键 Shift+F11 
直接执行所调用的方法，不进入其中调试(Step over) 
单击“调试”工具栏中的“逐过程”按钮，或者从菜单栏中选 择“调试”|“逐过程”，或者按 F10 
为方法指定可选参数 
在方法声明中为参数提供默认值。示例如下：  
void optMethod(int first, double second = 0.0,string third = "Hello") 
{     
	... 
} 
利用具名参数向方法提供实参 
在方法调用中指定参数名。示例如下： 
optMethod(first : 100, third : "World"); 

使用判断语句 
声明布尔变量 
使用布尔操作符创建结果为 true 或 false的表达式
使用 if 语句，依据布尔表达式的结果做出判断 
使用 switch 语句做出更复杂的判断 

声明布尔变量 
Visual C#支持 bool 数据类型。bool 变量只能容纳两个值之一：true 或 false。例如 以下语句声明 bool 变量 areYouReady，将 true 值赋给它，并在控制台上输出其值： 
bool areYouReady; 
areYouReady = true;
Console.WriteLine(areYouReady); // 控制台输出 True 
使用布尔操作符 
布尔操作符是求值为 true或 false的操作符。C#提供了几个非常有用的布尔操作符， 其中最简单的是 NOT(求反)操作符，它用感叹号(!)表示。!操作符求布尔值的反值。如变量 areYouReady 为 true，则表达式!areYouReady 求值为 false。 
理解相等和关系操作符 
两个更常用的布尔操作符是相等(==)和不等(!=)操作符。这两个二元操作符判断一个值 是否与相同类型的另一个值相等，结果是 bool 值。
操作符 	含义 		示例 			结果(假定 age = 42) 
==    	等于  	  age  == 100 		false 
!=    	不等于 	  age != 0 			true 
不要混淆相等操作符(==)和赋值操作符(=)。表达式 x==y 比较 x和 y，两个值相等就返 回 true。而表达式 x=y 是将 y的值赋给 x。 
与==和!=密切相关的是关系操作符，它们判断一个值是小于还是大于同类型的另一个值。下表演示了这些操作符
操作符 		含义 		示例 		结果(假定 age = 42) 
< 		小于 			age < 21 		false 
<= 		小于或等于 		age <= 18 		false 
> 		大于 			age > 16 		true 
>= 		大于或等于 		age >= 42 		true 
理解条件逻辑操作符 
C#还提供了另两个布尔操作符：逻辑 AND(逻辑与)操作符(用&&表示)和逻辑 OR(逻辑 或)操作符(用||表示)。这两个操作符统称条件逻辑操作符，作用是将两个布尔表达式或值 合并成一个布尔结果。这两个二元操作符与相等/关系操作符相似的地方是结果也为 true 或 false。不同的地方是操作的值(操作数)本身必须是 true 或 false。 
只有作为操作数的两个布尔表达式都为 true，&&操作符的求值结果才为 true。例如， 只有在 percent 大于或等于 0，并且小于或等于 100 的前提下，以下语句才会将 true 值 赋给 validPercentage： 
bool validPercentage;    // 有效百分数 
validPercentage = (percent >= 0) && (percent <= 100); 
提示 新手常犯错误是在合并两个测试时，只对 percent 变量命名一次，就像下面这样：
 	percent >= 0 && <= 100 // 该语句不能编译 
 	使用圆括号有助于避免这种错误，同时也有助于澄清表达式。例如，可对比以下 两个表达式： 
 	validPercentage = percent >= 0 && percent <= 100 
 	validPercentage = (percent >= 0) && (percent <= 100) 
两个表达式结果一样，因为操作符&&优先级低于>=和<=。但第二个更清晰。 
两个操作数任何一个为 true，操作符||的求值结果就为 true，它 判断两个条件是否有 任何一个成立。例如，以下语句在 percent 小于 0 或大于 100 的情况下将值 true 赋给 invalidPercentage： 
bool invalidPercentage;  
invalidPercentage = (percent < 0) || (percent > 100); 
短路求值 
操作符&&和||都支持短路求值。有时根本没必要两个操作数都求值。例如，假定操作符&&的左操作数求值为false，整个表达式的结果肯定是false，无论右操作数的值是什么。类似地，如果操作符||的左操作数求值为true，整个表达式的结果肯定是 true。这时 操作符&&和||将跳过对右侧布尔表达式的求值。下面是一些例子： 
(percent >= 0) && (percent <= 100) 
在这个表达式中，如 percent 小于 0，那么操作符&&左侧的布尔表达式求值为 false。 该值意味着整个表达式的结果肯定是 false，所以不对右侧表达式求值。再如下例： 
(percent < 0) || (percent > 100) 
在这个表达式中，如 percent 小于 0，那么操作符||左侧的布尔表达式求值为 true。 该值意味着整个表达式的结果肯定是 true。所以不对右侧表达式求值。 
精心设计使用了条件逻辑操作符的表达式，可避免不必要的求值以提升代码性能。将 容易计算、简单的布尔表达式放到条件逻辑操作符左边，将较复杂的放到右边。许多情况 下，程序并不需要对更复杂的表达式进行求值。 
操作符的优先级和结合性总结 
下表总结了迄今为止学过的所有操作符的优先级和结合性。同一类别的操作符具有相 同优先级。各类别按优先级从高到低排列。 
类别 			操作符 			描述 			结合性 
				 ()           覆盖优先级 		  
主要(Primary) 	 ++ 			后递增 			 左 
 				 -- 			后递减 


 				 ! 			   逻辑 NOT 				
一元(Unary) 		 + 				加 								
				 - 				减 				 左
				 ++            前递增 
				 -- 		   前递减 
					
				 * 				乘  
乘               /				除               左
				 %			    求余

				 + 				加
加(Additive) 	 - 				减				 左 
 
				 < 				小于
关系(Relational) <= 				小于或等于		 左
				 > 				大于 
				 >= 			大于或等于 
 
  				 == 			等于 
相等(Equality)   != 				不等于			 左
 
 
条件 AND 		 && 			逻辑 AND         左 

条件 OR          || 				逻辑 OR 			 左 

赋值(Assignment) = 				右操作数赋给左操   右
								作数, 返回所赋的值
注意，操作符&&和||的优先级不同，前者高于后者。 

使用 if 语句做出判断 
if 语句根据布尔表达式的结果选择执行两个不同的代码块。 
if 语句的语法如下所示(if 和 else 是 C#关键字)： 
if ( booleanExpression )     
	statement1;  // 语句 1 
else     
	statement2;  // 语句 2 
如果 booleanExpression(布尔表达式)求值为 true，就运行 statement1；否则运行 statement2。else 关键字和后续的 statement2 可选。如果没有 else 子句，而且 booleanExpression为 false，那么什么事情都不会发生，程序继续执行 if 语句之后的代 码。注意，布尔表达式必须放在圆括号中，否则无法编译。 
以下 if 语句递增秒表的秒针(暂时忽略分钟)。如 seconds 值是 59，就重置为 0；否则就用操作符++来递增： 
int seconds; 
... 
if (seconds == 59)     
	seconds = 0; 
else     
	seconds++;
if 语句中的表达式必须放在一对圆括号中。此外，表达式必须是布尔表达式。另一些语言(尤其是C和 C++)允许使用整数表达式，编译器自动将整数值转换成 true(非 0 值)或 false(0)。C#不允许这样做，看到这样的表达式会报告编译错误。 
如果在 if 语句中不慎写了赋值表达式，而不是执行相等性测试，C#编译器也能识别出 这个错误。例如： 
 int seconds;  
 ...  
 if (seconds = 59) // 编译错误    
 ...  
 if (seconds == 59) // 正确 
在本该用==的地方用了=，是 C/C++程序容易出现bug的另一个原因。在C和C++中，会将所赋的值(59)悄悄转换成布尔值(任何非 0 值都被视为 true)，造成每次都执行 if 语句 之后的代码。 
另外，布尔变量可作为 if 语句的表达式使用，但必须放在圆括号中： 
 bool inWord; 
 ...  
 if (inWord == true) // 可以这样写，但不常见  
 ...  
 if (inWord) // 更常见的写法 
使用代码块分组语句 
在前面的 if 语法中，if (booleanExpression)后面只有一个语句，关键字 else 后 面也只有一个语句。但经常要在布尔表达式为 true 的前提下执行两个或更多语句。这时可将要运行的语句分组到新方法中，然后调用方法。但更简单的做法是将语句分组到代码块 中。代码块是用大括号封闭的一组语句。 
下例两个语句将 seconds 重置为 0，并使 minutes 递增。这两个语句被放到代码块中。 如果 seconds 的值等于 59，整个代码块都会执行： 
int seconds = 0; 
int minutes = 0;
... 
if (seconds == 59) 
{     
	seconds = 0;    
 	minutes++;
} 
else 
{     
	seconds++; 
} 
遗漏大括号造成两个严重后果。首先，C#编译器只将第一个语句(seconds = 0;)与 if 语句关联，下个语句(minutes++;)不再成为 if 语句的一部分。其 次，当编译器遇到else关键字时，不会将它与前一个if语句关联，所以会 报告一个语法错误。因此，一个好习惯是用代码块定义 if 语句的每个分支， 即使其中只有一个语句。这样以后添加代码更省心。 
代码块还界定了一个新的作用域。可在代码块内部定义变量，这些变量在代码块结束 时消失。如以下代码所示： 
if (...) 
{    
	int myVar = 0;    
	... // myVar 能在这里使用 
} // myVar 在这里消失 
else 
{    // 这里不能使用 myVar 了    
	... 
} // 这里不能使用myVar 了 
嵌套 if 语句 
可在一个 if 语句中嵌套其他if语句。这样可以链接一系列布尔表达式。它们依次测试，直至其中一个求值为true。在下例中，假如day值为0，则第一个测试的值为true，值"Sunday"将被赋给dayName变量。假如day值不为0，则第一个测试失败，控制传递给 else 子句。该子句运行第二个if测试为 false，才执行第二个if语句。类似地，只有第一个if测试和第二个if测试为false，才执行第三个if。 
 语句，将day的值与1进行比较。注意，只有第一个 if
 if (day == 0) 
 {     
 	dayName = "Sunday"; 
 } 
 else if (day == 1) 
 {     
 	dayName = "Monday"; 
 } 
 else if (day == 2) 
 {     
 	dayName = "Tuesday"; 
 } 
 else if (day == 3) 
 {     
 	dayName = "Wednesday"; 
 } 
 else if (day == 4) 
 {     
 	dayName = "Thursday"; 
 } 
 else if (day == 5) 
 {     
 	dayName = "Friday"; 
 } 
 else if (day == 6) 
 {     
 	dayName = "Saturday"; 
 } 
 else 
 {     
 	dayName = "unknown"; 
 }
练习要写一个方法，使用嵌套 if 语句比较两个日期。 
1. 如果尚未运行，请先启动 Microsoft Visual Studio 2017。 
2. 打开 Selection 解 决 方 案 ， 它 位 于 “ 文档” 文 件 夹 下 的 \Microsoft Press\VCSBS\Chapter 4\Selection 子文件夹。 
3. 在“调试”菜单中选择“开始调试”。 
 Visual Studio 2017 生成并运行应用程序。窗体显示两个 DatePicker 控件，名为 firstDate 和 secondDate。两个控件都显示了当前日期， 
4. 单击 Compare。 
窗口下半部分的文本框显示以下内容： 
firstDate == secondDate : False 
firstDate != secondDate : True 
firstDate <  secondDate : False 
firstDate <= secondDate : False 
irstDate >  secondDate : True 
firstDate >= secondDate : True 
结果显然有问题。布尔表达式 firstDate == secondDate 应该为 true，因为 firstDate 和 secondDate 都被设为今天的日期。事实上，在上述结果中，似乎只 有<和>=的结果才是正确的。
5. 返回 Visual Studio 2017 并停止调试。 
6. 在“代码和文本编辑器”窗口中显示 MainPage.xaml.cs 的代码。 
7.  找到 compareClick 方法，如下所示： 
private void compareClick(object sender, RoutedEventArgs e) 
{    
	int diff = dateCompare(firstDate.Date.LocalDateTime, secondDate.Date.LocalDateTime);    
	info.Text = "";    
	show("firstDate == secondDate", diff == 0);    
	how("firstDate != secondDate", diff != 0);    
	show("firstDate < secondDate", diff < 0);    
	show("firstDate <= secondDate", diff <= 0);    
	show("firstDate > secondDate", diff > 0);    
	show("firstDate >= secondDate", diff >= 0); 
} 
 单击窗体上的 Compare 按钮将执行该方法。firstDate.Date.LocalDateTime 和 secondDate.Date.LocalDateTime 这两个表达式容纳DateTime值，代表在firstDate和secondDate控件上显示的日期。DateTime数据类型和 int或float等数据类型相似，只是包含子元素以便访问日期的不同组成部分，如年、月或日。 
 compareClick方法向 dateCompare方法传递两个 DateTime值，后者比较两个值。 如果相同返回 int 值 0，第一个小于第二个返回-1，第一个大于第二个返回+1。 日历上靠后的日期较大(同一年的1月2日大于1月1日。将在下个步骤讨论 dateCompare 方法。 show 方法在窗体下半部分的info文本框控件中汇总比较结果。
8. 找到 dateCompare 方法，如下所示： 
private int dateCompare(DateTime leftHandSide, DateTime rightHandSide) {    // TO DO    return 42; } 
 方法目前返回固定值，而不是通过比较实参返回 0，-1 或+1。这解释了为什么应 用程序不像预期的那样工作！ 需要在方法中实现正确比较两个日期的逻辑。 
9. 在 dateCompare 方法中删除// TO DO 注释和 return 语句。 
10. 在 dateCompare 方法主体添加以下加粗的代码： 
private int dateCompare(DateTime leftHandSide, DateTime rightHandSide) 
{    
	int result = 0; 
    if (leftHandSide.Year < rightHandSide.Year)    
    {       
    	result = -1;    
    }    
    else if (leftHandSide.Year > rightHandSide.Year)    
    {       
    	result = 1;    
    } 
} 
 暂时不要生成应用程序。dateCompare 方法尚未完成，生成会失败。 
如表达式 leftHandSide.Year < rightHandSide.Year求值为true ，则leftHandSide 中的日期肯定早于rightHandSide 中的日期，所以程序将 result 变量设为-1。否则，如表达式 leftHandSide.Year > rightHandSide.Year 求值 为 true，则 leftHandSide 中的日期肯定晚于 rightHandSide 中的日期，所以程 序将 result 变量设为 1。 如leftHandSide.Year < rightHandSide.Year 和 leftHandSide.Year > rightHandSide.Year 两个表达式都求值为 false，两个日期的 Year 属性值肯定 相同，所以接着比较两个日期中的月份。 
11. 在 dateCompare 方法主体添加以下加粗的代码(放到上个步骤添加的代码之后)： 
private int dateCompare(DateTime leftHandSide, DateTime rightHandSide) 
{     
	...     
	else if (leftHandSide.Month < rightHandSide.Month)     
	{         
		result = -1;     
	}     
	else if (leftHandSide.Month > rightHandSide.Month)     
	{        
		result = 1;     
	} 
} 
这些语句使用和比较年份相似的逻辑来比较月份。 如leftHandSide.Month < rightHandSide.Month 和 leftHandSide.Month >rightHandSide.Month两个表达式都求值为false，两个日期的Month属性值肯定相同，所以最后比较两个日期中的天数。 
12. 在 dateCompare 方法主体添加以下加粗代码(放到之前添加的代码之后)： 
private int dateCompare(DateTime leftHandSide, DateTime rightHandSide) 
{     
	...     
	else if (leftHandSide.Day < rightHandSide.Day)     
	{         
		result = -1;     
	}     
	else if (leftHandSide.Day > rightHandSide.Day)     
	{         
		result = 1;     
	}     
	else     
	{         
		result = 0;     
	} 
    return result; 
} 
如 leftHandSide.Day < rightHandSide.Day 和 leftHandSide.Day >rightHandSide.Day两个表达式均求值为false，两个日期的Day属性值肯定相同。按目前的逻辑，Month和Year值已经相同，所以两个日期肯定相同，所以将 result 的值设为 0。最后一个语句返回 result 变量当前存储的值。 
13. 在“调试”菜单中选择 “开始调试”。 
应用程序将重新生成和启动。 
14. 单击 Compare。 
 文本框显示以下内容： 
firstDate == secondDate : True firstDate != secondDate : False firstDate < secondDate: False firstDate <= secondDate: True firstDate > secondDate: False firstDate >= secondDate: True 
 这些结果对于相同的两个日期是正确的。 
15. 为第二个 DatePicker 控件选择一个靠后的日期再单击 Compare 按钮。 
文本框显示以下内容： 
firstDate == secondDate: False 
firstDate != secondDate: True 
firstDate < secondDate: True 
firstDate <= secondDate: True 
firstDate > secondDate: False 
firstDate >= secondDate: False 
当第一个日期早于第二个日期时，上述结果是正确的。 
16. 测试其他日期，验证结果都符合预期。完成后返回 Visual Studio 2017 并停止调试。 
实际应用程序中的日期比较 
在体验了如何使用一系列长和复杂的 if 和 else 语句之后，我有责任提醒大家，在实 际的应用程序中，并不以这种方式比较日期。练习中的 dateCompare 方法有两个参数，即 leftHandSide和 rightHandSide，它们都是 DateTime 值。程序逻辑只比较日期，没有比 较时间(也没有显示)。两个 DateTime值要真正“相等”，不仅日期要一样，时间也要一样。 比较日期和时间是很常见的操作，所以 DateTime 类型内建了 Compare 方法。Compare 方 法获取两个 DateTime实参并进行比较。返回小于 0的值表明第一个实参小于第二个实参， 返回大于 0的值表明第一个实参大于第二个，返回 0表明两个实参代表相同日期和时间。 

使用 switch 语句 
使用嵌套 if 语句时，有时所有if语句看起来都相似，因为都在对完全相同的表达式 进行求值，唯一区别是每个 if 语句都将表达式的结果与不同的值进行比较。例如以下代码块，它用 if 语句判断 day 变量的值对应星期几： 
if (day == 0) 
{    
	dayName = "Sunday"; 
}
else if (day == 1) 
{    
	dayName = "Monday"; 
} 
else if (day == 2) 
{    
	dayName = "Tuesday";
} 
... 
else 
{    
	dayName = "Unknown"; 
} 

理解 switch 语句的语法 
switch 语句语法如下(switch，case 和 default 是 C#关键字)： 
switch ( controllingExpression ) 
{ 
	case constantExpression :     
		statements     
		break; 
	case constantExpression :     
		statements     
		break; 
	... 
	default :     
		statements     
		break; 
} 
controllingExpression(控制表达式)只求值一次，而且必须包含在圆括号中。然后逐 个检查 constantExpression(常量表达式)
， 找到和 controllingExpression 值相等的
， 就执行由它标识的代码块(constantExpression 称为 case 标签)。进入代码块后，将一直 执行到 break;语句。遇到 break;后，switch 语句结束，程序从 switch 语句结束大括号 之后的第一个语句继续执行。没有找到任何匹配的 case 标签，就运行由可选的 default标 签所标识的代码块。 
注意 每个 constantExpression 值都必须唯一，使 controllingExpression 只能与它们当中的一个匹配 。 如果 controllingExpression 的值和任何 constantExpression的值都不匹配，也没有default标签，程序就从switch的 结束大括号之后的第一个语句继续执行。 
所以，前面的嵌套 if 语句可改写成以下 switch 语句：  
switch (day)
{    
	case 0 :       
		dayName = "Sunday";       
		break;    
	case 1 :       
		dayName = "Monday";       
		break;    
	case 2 :       
		dayName = "Tuesday";       
		break;    
	...    
	default :       
		dayName = "Unknown";       
		break; 
} 
遵守 switch 语句的规则 
switch 语句很有用，但使用须谨慎。switch 语句要严格遵循以下规则。 
switch 语句的控制表达式只能是某个整型(int，char，long 等)或 string。其他 任何类型(包括 float 和 double类型)只能用 if 语句。 
case 标签必须是常量表达式，如 42(控制表达式是 int)，'4'(控制表达式是 char) 或"42"(控制表达式是 string)。要在运行时计算 case 标签的值，就只能用if语句。 
case 标签必须唯一，不允许两个 case 标签具有相同的值。 
可以连续写多个 case 标签(中间不间插额外的语句)，指定在多种情况下都运行相 同的语句。如果这样写，最后一个 case 标签之后的代码将适用于所有 case。但 如果两个标签之间有额外的代码，就不能从第一个标签贯穿(也称直通)到第二个 标签，编译器会报错。例如： 
 switch (trumps)  
 {     
 	case Hearts :     
 	case Diamonds :   // 允许直通——标签之间无额外代码        
 		color = "Red";   // Hearts 和Diamonds 两种情况都执行相同的代码       
 		 break;     
 	case Clubs :        
 		color = "Black";     
 	case Spades :    // 出错——标签之间有额外代码        
 		color = "Black";       
 		break; 
 }
 注意 break 语句是阻止直通的最常见方式，也可用 return 或 throw 语句代替。return 从 switch 语句所在的方法退出，throw 抛出异常并中止 switch 语句。
 switch 语句的直通规则 
如果间插了额外语句，就不能从一个 case 直通到下个 case。所以，我们可以自由安 排 switch 语句的各个区域，不用担心会改变其含义(就连 default 标签都能随意摆放；它通常放在最后，但并非必须)。 
C 和 C++程序员注意，C#要求为 switch 语句的每个 case(包括 default)提供 break 语句。这是好事；在 C 和 C++程序中，很容易因为忘记添加 break 语句而直通到后面的标签，造成不易发现的 bug。 
但如果真的需要，也可在 C#中模拟 C++的直通行为，具体做法是用 goto 语句转到下 个 case 或 default标签。但这是不推荐的，本书也不打算介绍具体怎么做！ 
练习要完成一个程序来读取字符串中的字符，将每个字符映射成对应的 XML 形 式。例如，<字符在 XML 中具有特殊含义(用于构成元素)，所以要正确显示就必须转换成 "&lt;"，使 XML 处理器知道这是数据而不是 XML 指令的一部分。类似规则也适用于>， & '和"等字符。要写 switch 语句来测试字符的值，将特殊 XML 字符作为 case 标签使 用。
编写 switch 语句 
1. 如果尚未运行 Visual Studio 2017，请启动它。 
2. 打开 SwitchStatement 项目，它位于“ 文档” 文件夹下的\Microsoft Press\VCSBS\Chapter 4\SwitchStatement 子文件夹。 
3. 在“调试”菜单中选择“开始调试”。 
 Visual Studio 2017 生成并运行应用程序。窗体包含两个文本框，中间用 Copy 按钮 分开。 
4. 在上方文本框中键入以下示例文本： 
inRange = (lo <= number) && (hi >= number); 
5. 单击 Copy 按钮。 
6. 返回 Visual Studio 2017 并停止调试。 
7. 在“代码和文本编辑器”窗口中显示 MainPage.xaml.cs 的代码，从中找到 copyOne 方法，如下所示： 
private void copyOne(char current) 
{    
	switch (current)    
		{       
			default:          
				target.Text += current;         
				 break;    
		} 
} 
 copyOne 方法将作为参数指定的字符附加到下方文本框显示的文本末尾。方法目前包含一个 switch 语句，其中只有一个 default 操作。下面将修改 switch 语句 来转换 XML 特殊字符，例如将字符<转换成字符串"&lt;"。 
8. 在 switch 语句的{之后、default 标签之前添加以下加粗显示的语句： 
switch (current) 
{    
	case '<' :       
		target.Text += "&lt;";       
		break;    
	default:       
		target.Text += current;       
		break; 
} 
 如果当前复制的字符是<，上述代码将字符串"&lt;"附加到正在输出的文本末尾。
9. 在新加的 break 语句之后、default 标签之前添加以下语句：   
case '>' :     
	target.Text += "&gt;";     
	break; 
case '&' :     
	target.Text += "&amp;";     
	break; 
case '\"' :     
	target.Text += "&#34;";    
 	break; 
case '\'' :     
 	target.Text += "&#39;";     
 	break; 
注意 在 C#语言和 XML 中，单引号(')和双引号(")有特殊含义，分别用于界定字符和 字符串常量。最后两个 case 中的反斜杠(\)是转义符，指示 C#编译器把这些字符当作字面值，而不是当作定界符。 
10. 在“调试”菜单中选择“开始调试”。 
11. 在上方文本框中键入以下文本： 
inRange = (lo <= number) && (hi >= number); 
12. 单击 Copy。 
语句被复制到下方文本框。这次每个字符都会在 switch 语句中进行 XML 映射处 理。target 文本框显示以下转换结果： 
inRange = (lo &lt;= number) &amp;&amp; (hi &gt;= number); 
13. 再用其他字符串做试验，验证所有特殊字符(<，>，&，"和')都得到正确处理。 
14. 返回 Visual Studio 并停止调试。 

使用复合赋值和循环语句 
使用复合赋值操作符更新变量值 
使用 while、for 和 do 循环语句 
单步执行do语句，观察变量值的变化 
使用复合赋值操作符 
前面讲过如何用算术操作符创建新值。例如以下语句使用操作符+创建比变量answer大42的值，新值在控制台显示： 
Console.WriteLine(answer + 42); 
还讲过如何用赋值语句更改变量值。以下语句使用赋值操作符=将answer的值变成42：
answer = 42; 
要在变量的值上加 42，可在同一个语句中使用赋值和加法操作。例如，以下语句在answer上加42，新值再赋给 answer。换言之，在运行该语句之后，answer 的值比之前大 42： 
answer = answer + 42;  
虽然这是有效的语句，但有经验的程序员不这样写。在变量上加一个值是常见操作，所以 C#专门提供了+=操作符来简化。在 answer 上加 42，有经验的程序员会这样写： 
answer += 42; 
任何算术操作符都可以像这样与赋值操作符合并，从而获得复合赋值操作符。 

不这样写                            这么写
variable = variable * number; 	variable *= number; 
variable = variable / number; 	variable /= number; 
variable = variable % number; 	variable %= number; 
variable = variable + number; 	variable += number; 
variable = variable - number; 	variable -= number; 
提示 复合赋值操作符具有和简单赋值操作符(=)一样的优先级和右结合性。 
操作符+=可作用于字符串；从而将一个字符串附加到另一个字符串末尾。例如，以下 代码在控制台上显示"Hello John"： 
string name = "John"; 
string greeting = "Hello "; 
greeting += name; 
Console.WriteLine(greeting); 
但其他任何复合赋值操作符都不能作用于字符串。 
注意 变量递增或递减 1 不要使用复合赋值操作符，而是使用操作符++和--。例如，不这样写： 
  count += 1; 
  而是这样写： 
  count++;

编写 while 语句 
以下 while 语法允许在条件为 true 时反复运行一个语句： 
while ( booleanExpression )     statement 
先求值 booleanExpression(布尔表达式，注意必须放在圆括号中)，为 true 就运行语 句(statement)。再次求值 booleanExpression，仍为 true 就再次运行语句。再次求值…… 如此反复，直至求值为 false，此时 while 语句退出，从 while 构造后的第一个语句继续。 while 语句在语法上和 if 语句相似 (事实上，除关键字不同，语法完全一样)，具体如下。
表达式必须是布尔表达式。 
布尔表达式必须放在圆括号中。 
首次求值布尔表达式为 false，语句不运行。 
要在 while 的控制下执行两个或更多语句，必须用大括号将语句分组成代码块。
以下 while 语句向控制台写入值 0～9。一旦变量 i的值变成 10，while 语句中止，不 再运行代码块。 
int i = 0; 
while (i < 10) 
{     
	Console.WriteLine(i);     
	i++; 
}
所有 while 语句都应在某个时候终止。新手常犯错误是忘记添加最终造成布尔表达式 求值为 false 的语句来终止循环。在上例中，这个语句就是 i++;。 
注意 while 循环的变量 i 控制循环次数。这是常见的设计模式，具有这个作用的变量 有时也称为哨兵变量。还可创建嵌套循环，这种情况下一般延续该命名模式来使 用 j，k甚至 l等作为哨兵变量名。 
提示 和 if 语句一样，建议总是为 while 语句使用代码块，即使其中只有一个语句。 这样以后添加代码更省心。不这样做，只有while后的第一个语句才会与之关联， 造成难以发现的 bug。例如以下代码： 
        int i = 0;       
        while (i < 10)             
        Console.WriteLine(i);             
        i++; 
将无限循环，无限显示零，因为只有Console.WriteLine语句才和while关联，i++;语句虽然缩进但那只是给人看的，编译器并不把它视为循环主体的一部分练习写一个while循环，每次从源文件读取一行内容，将其写入文本框。编写 while 语句 
1. 在 Visual Studio 2017 中打开 WhileStatement 解决方案，它位于“文档”文件夹下 的\Microsoft Press\VCSBS\Chapter 5\WhileStatement 子文件夹。 
2. 在“调试”菜单中选择“开始调试”。 
 Visual Studio 2017 生成并运行应用程序。应用程序本身是一个简单的文本文件查 看器，用于打开文件并查看内容。 
3. 单击 Open File。 
 随后将显示“打开”对话框并显示“文档”文件夹的内容,可利用该对话框切换到一个文件夹并选择要显示的文件。 
4. 切 换 到 “ 文档” 文 件 夹 下 的 \Microsoft Press\VCSBS\Chapter 5\WhileStatement\WhileStatement 子文件夹。 
5. 选择 MainPage.xaml.cs 文件，单击“打开”。 
 文件名 MainPage.xaml.cs 在小文本框显示，但文件内容没有在大文本框中显示。 这是由于尚未实现代码来读取并显示源文件内容。下面的步骤将添加这个功能。 
6. 返回 Visual Studio 2017 并停止调试。 
7. 在“代码和文本编辑器”窗口中打开MainPage.xaml.cs文件，找到openFileClick 方法。一旦在“打开”对话框中选择文件并单击“打开”就会调用该方法。目前 不需要理解方法的细节，只需知道方法提示用户指定文件(通过 FileOpenPicker 或OpenFileDialog 窗口)并打开指定文件以进行读取。 
openFileClick 方法的最后两个语句很重要： 
TextReader reader = new StreamReader(inputStream.AsStreamForRead()); 
displayData(reader); 
第一个语句声明 TextReader 变量 reader。TextReader 是.NET Framework 提供 的类，用于从文件等来源读取字符流。它在 System.IO 命名空间中。该语句确保 用户指定文件中的数据可供 TextReader 对象使用，然后就可通过该对象从文件 读取数据。最后一个语句调用 displayData 方法，将 reader 作为参数传递。方 法使用 reader 对象读取数据并在屏幕上显示，稍后将实现该方法。 
8. 找到 displayData 方法。它目前如下所示： 
private void displayData(TextReader reader) 
{     
	// TODO: add while loop here 
} 
主体仅一行注释，马上就要添加代码来获取并显示数据。 
9. 将//TODO注释替换成以下语句： 
source.Text = ""; 
source 对象是窗体上最大的那个文本框。把它的 Text 属性设为空字符串("")，就可清除当前显示的任何文本。 
10. 继续输入以下语句： 
string line = reader.ReadLine(); 
    上述语句声明 string 变量 line，调用 reader.ReadLine 方法把文件中的第一行 文本读入变量。方法要么返回读取的一行文本；要么返回特殊值 null 来表明没有 更多的行可供读取。 
11. 继续输入以下代码： 
while (line != null) 
{     
	source.Text += line + '\n';     
	line = reader.ReadLine(); 
} 
该 while 循环依次读取文件每一行，直至没有更多行。 while 循环判断 line 变量值。不为 null 就显示读取的行，具体做法是将该行附 加到 source 文本框的 Text 属性，并在行末添加换行符('\n')。TextReader 对象 的 ReadLine方法读取行时会自动删除换行符，所以要手动添加。在下次迭代之 前，while 循环读取下一行文本。如此反复。没有更多文本，ReadLine 将返回 null 值，造成 while 循环终止。 
12. 在 while 循环的结束大括号(})之后添加以下语句： 
reader.Dispose(); 
  这将释放与文件关联的资源并关闭文件。这是一个好习惯。除了释放访问文件所 需的内存和其他资源，还使其他应用程序能使用该文件。 
13. 在“调试”菜单中选择“开始调试”。 
14. 窗体出现之后单击 Open File。 
15. 在“打开”对话框中切换到“文档”文件夹下的\Microsoft Press\VCSBS\Chapter 5\WhileStatement\WhileStatement 子文件夹，选择 MainPage.xaml.cs 文件，单击“打开”。 这次所选文件的内容在文本框中完整显示，可看到刚才输入的代码。
16. 在文本框中滚动文本，找到 displayData 方法。验证方法包含刚才添加的代码。 
17. 返回 Visual Studio 2017 并停止调试。 
编写 for 语句 
C#大多数 while 循环语句都具有以下常规结构： 
initialization while (Boolean expression) 
{   
	statement   
	update control variable 
} 
for 语句提供了这种结构的更正式版本，它将 initialization(初始化)、Boolean expression(布尔表达式)与 update control variable(更新控制变量)合并到一起。用过 for 语句就能体会到它的好处，其中包括防止遗漏初始化和更新控制变量的代码，减小写 出无限循环代码的机率。以下是 for 语句的语法： 
for (initialization; Boolean expression; update control variable)      
	statement 
其中，statement(语句)是 for 循环主体，要么是一个语句，要么是用大括号{}封闭的代码块。 
前面展示过 while 循环的一个例子，它显示 0～9的整数。下面用 for 循环改写： 
 
for (int i = 0; i < 10; i++) 
{      
	Console.WriteLine(i); 
} 
初始化(int i = 0)只在循环开始时发生一次。如布尔表达式(i < 10)求值为 true，就 运行语句(Console.WriteLine(i);)。随后，控制变量更新(i++)，布尔表达式重新求值，如仍为true，语句再次执行，控制变量更新，布尔表达式重新求值……如此反复。 
注意三点：初始化只发生一次；初始化后先执行循环主体语句，再更新控制变量； 更新控制变量后再重新求值布尔表达式。
提示 和 while 语句一样，建议总是为 for 循环主体使用代码块，即使其中只有一个语 句。这样以后添加代码更省心。 
for 语句的三个部分都可省略。如省略布尔表达式，布尔表达式就默认为 true。以下 for 语句将一直运行： 
for (int i = 0; ;i++) 
{    
	Console.WriteLine("简直停不下来!"); 
}  
省略初始化和更新部分会得到一个看起来很奇怪的 for 循环，如下所示： 
int i = 0; for (; i < 10; ) 
{     
	Console.WriteLine(i);     
	i++; 
}  
注意 for 语句的初始化、布尔表达式和更新控制变量这三个部分必须用分号分隔，即 使某个部分的实际内容并不存在。 
如有必要，可在 for 循环中提供多个初始化语句和多个更新语句(布尔表达式只能有一个)。为此，请用逗号分隔不同的初始化和更新语句，如下例所示： 
for (int i = 0, j = 10; i <= j; i++, j--) 
{      
	... 
} 
最后用 for 循环重写上个练习的 while 循环： 
for (string line = reader.ReadLine(); line != null; line = reader.ReadLine()) 
{     
	source.Text += line + ‘\n’; 
} 
理解 for 语句作用域 
前面说过，可在 for 语句的“初始化”部分声明新变量。这种变量的作用域限于 for 语句主体。for语句结束，变量消失。该规则造成两个重要后果。首先，不能在for语句结束后使用变量，因为它已不在作用域中。下面是一个例子： 
for (int i = 0; i < 10; i++) 
{      
	...
} 
Console.WriteLine(i); // 编译错误 
其次，可在两个或更多 for 语句中使用相同变量名，因为每个变量都在不同作用域中。 下面是一个例子：  
for (int i = 0; i < 10; i++) 
{      
	... 
} 
for (int i = 0; i < 20; i += 2) // okay 
{     
	 ... 
}
编写 do 语句 
while 和 for 语句都在循环开始时测试布尔表达式，意味着如果首次测试布尔表达式为false，循环主体一次都不运行。do 语句则不同，它的布尔表达式在每次循环之后求值， 所以主体至少运行一次。 
do 语句的语法如下(不要忘记最后的分号)： 
do     
	statement 
while (booleanExpression); 
多个语句构成的循环主体必须是放在{}中的代码块。以下语句向控制台输出 0～9，这 次使用 do 语句： 
int i = 0; 
do
{     
	Console.WriteLine(i);     
	i++; 
} 
while (i < 10);
break 和 continue 语句 
前面使用 break 语句跳出 switch 语句。还可用它跳出循环。执行 break 后，系统立 即终止循环，并从循环之后的第一个语句继续执行。在这种情况下，循环的“更新”和“继 续”条件都不会重新判断。 相反，continue 语句造成当前迭代结束，立即开始下一次迭代(在重新求值布尔表达式 之后)。下面是在控制台上输出 0～9的例子的另一个版本，这次使用 break语句和 continue 语句： 
 int i = 0;  while (true)  
 {      
 	Console.WriteLine("continue " + i);      
 	i++;      
 	if (i < 10)          
 		continue;      
 	else          
 		break;  
 } 
代码看起来令人难受。在许多编程守则中，都建议慎用 continue 语句，或者根本不 用，因为它很容易造成难以理解的代码。continue 语句的行为还让人捉摸不透。例如，在 for 语句中执行 continue 语句，会在运行 for 语句的“更新(控制变量)”部分之后，才开 始下一次迭代。 
下例写 do 语句将正的十进制数转换成八进制的字符串形式。伪代码如下： 
将十进制数存储到变量dec 中 
do以下事情：     
	dec 除以 8，存储余数     
	将dec 设为上一步得到的商 
while dec 不等于 0     
	按相反顺序合并每一次得到的余 
例如，将十进制数 999 转换成八进制的步骤如下。 
1. 999 除以 8，商 124 余 7。 
2. 124 除以 8，商 15，余 4。 
3. 15 除以 8，商 1 余 7。 
4. 1 除以 8，商 0，余 1。 
5. 反序合并每一步的余，结果是 1747。这就是 999 转换成八进制的结果。 
写 do 语句 
1. 在 Visual Studio 2017 中打开 DoStatement 解决方案，它位于“文档”文件夹下的 \Microsoft Press\VCSBS\Chapter 5\DoStatement 子文件夹。 
2. 在设计视图中显示 MainPage.xaml 窗体。 
 窗体左侧是 number 文本框。用户在此输入十进制数。单击 Show Steps 按钮后，会 生成该数字的八进制形式。右侧 steps 文本框显示每个计算步骤的结果。 
3. 在 “ 代 码 和 文 本 编 辑 器 ” 窗口中显示 MainPage.xaml.cs 的 代 码 。 找 到 showStepsClick 方法。该方法在单击 Show Steps 按钮后运行，目前为空。 
4. 将以下加粗的代码添加到 showStepsClick 方法： 
private void showStepsClick(object sender, RoutedEventArgs e) 
{     
	int amount = int.Parse(number.Text);     
	steps.Text = "";     
	string current = ""; 
} 
 第一个语句使用 int 类型的 Parse方法将 number文本框的 Text 属性中存储的字 符串值转换成 int 值。 
 第二个语句将右侧文本框 steps 的 Text 属性设为空字符串，清除显示的文本。 
 第三个语句声明 string 变量 current，初始化为空字符串。该字符串存储每一次 迭代生成的八进制数位。 
5. 将以下加粗的 do 语句添加到 showStepsClick 方法： 
private void showStepsClick(object sender, RoutedEventArgs e) 
{     
	int amount = int.Parse(number.Text);     
	steps.Text = "";     
	string current = ""; 

    do     
    {         
    	int nextDigit = amount % 8;         
    	amount /= 8;         
    	int digitCode = '0' + nextDigit;         
    	char digit = Convert.ToChar(digitCode);         
    	current = digit + current;         
    	steps.Text += current + "\n";     
    }     
    while (amount != 0); } 
该算法反复计算amount变量除以8所得的余数。每次得到的余数都是正在构造的新字符串的下一个数位。最终，amount变量将减小至0，循环结束。注意循环主体至少执行一次。这个“至少执行一次”的行为正是我们需要的，因为即使是数字0，也是有一个八进制数位的。 
进一步研究代码，do 循环的第一个语句如下： 
int nextDigit = amount % 8; 
该语句声明 int 变量 nextDigit 并初始化为 amount 的值除以 8 之余。该值范围 是 0～7。 
第二个语句如下： 
amount /=8;
这是复合赋值语句，相当于 amount = amount / 8;。如果 amount 的值是 999， 那么在执行这个语句之后，amount 的值就是 124。 
下一个语句是： 
int digitCode = '0' + nextDigit; 
该语句要稍微解释一下！每个字符都有唯一代码，具体由操作系统使用的字符集 决定。在 Windows 常用的字符集中，字符'0'的代码是整数值48。字符'1'的代码是49，字符'2'的代码是50，以此类推，直到字符'9'，它的代码是 57。C#允许 将字符当作整数处理，允许对它们执行算术运算。但这样做会将字符码作为值使用。所以，表达式'0' + nextDigit的结果是 48～55 之间的值(记住，nextDigit 的值在 0～7之间)，对应等价的八进制数位的代码。 
do 语句的第四个语句如下： 
char digit = Convert.ToChar(digitCode);  
该语句声明char 变量digit 并初始化为 Convert.ToChar(digitCode)方法调用 的结果。Convert.ToChar方法获取字符码(一个整数)，返回与之对应的字符。所以，假如digitCode的值是54，Convert.ToChar(digitCode)返回字符'6'。 
总之，do 循环的前 4个语句计算与用户输入的数字对应的最低有效八进制数位(最 右边的数位)。下个任务是将这个数位附加到要输出的字符串的前面，如下所示：
current = digit + current; 
 do 循环的下一个语句是： 
steps.Text += current + "\n"; 
 该语句将迄今为止得到的八进制数位添加到 steps 文本框，还为每次输出都附加 换行符，使每次输出在文本框中都单独占一行。 
 最后，do 循环末尾用 while 子句对循环条件进行求值： 
while (amount != 0); 
 如 amount 的值目前不为 0，就开始下一次循环。 
最后一个练习使用 Visual Studio 2017 调试器单步执行上述 do 语句，以理解工作原理。

单步执行 do 语句 
1. 在打开了 MainPage.xaml.cs 文件的“代码和文本编辑器”窗口中，将光标移到 showStepsClick 方法的第一个语句： 
int amount = int.Parse(number.Text); 
2. 右击该语句，从弹出菜单选择“运行到光标处”。 
3. 窗体出现后，在左侧文本框中键入 999，单击 Show Steps。 
 程序暂停运行，Visual Studio 2017 进入调试模式。“代码和文本编辑器”窗口左侧出现一个黄色箭头，标记当前要执行的语句。 
4. “代码和文本编辑器”窗口下方的窗格中单击“局部变量”标签。
5. 如“调试”工具栏不可见，请显示它(选择“视图”|“工具栏”|“调试”)。注意， 工具栏上的命令在“调试”菜单中均有对应。 
6. 在“调试”工具栏上单击“逐语句”按钮(或者按 F11)。 
 调试器将运行当前语句： 
int amount = int.Parse(number.Text); 
 在“局部变量”窗格中，amount 的值变成 999，黄色箭头指向下一个语句。 
7. 再次单击“逐语句”按钮。 
 调试器运行以下语句： 
steps.Text = ""; 
 该语句不影响“局部变量”窗格的显示，因为 steps 是窗体控件，不是局部变量。 黄色箭头指向下一个语句。 
8. 再次单击“逐语句”按钮。 
 调试器运行以下语句： 
string current = ""; 
 黄色箭头指向 do 循环起始大括号。do 循环主体有三个局部变量：nextDigit， digitCode和 digit。注意它们在“局部变量”窗口中显示，值均为 0。 
9. 单击“逐语句”按钮。 
 黄色箭头指向 do 循环主体的第一个语句。 
10. 单击“逐语句”按钮。 
 调试器运行以下语句： 
int nextDigit = amount % 8; 
 在“局部变量”窗口中，nextDigit 的值变成 7，这是 999 除以 8之余。 
11. 单击“逐语句”按钮。 
 调试器运行以下语句： 
amount /= 8; 
 在“局部变量”窗口中，amount 的值变成 124。 
12. 单击“逐语句”按钮。 
 调试器运行以下语句： 
int digitCode = '0' + nextDigit; 
 在“局部变量”窗口中，digitCode变量的值变成 55。这是'7'的字符码(48 + 7)。 
13. 单击“逐语句”按钮。 
 调试器运行以下语句： 
char digit = Convert.ToChar(digitCode); 
 在“局部变量”窗口中，digit 的值变成'7'。“局部变量”窗口同时显示 char 值的数值形式(本例是 55)和字符形式(本例是'7')。 
 注意在“局部变量”窗口中，current 变量的值仍是""。 
14. 单击“逐语句”按钮。 
 调试器运行以下语句： 
current = current + digit; 
在“局部变量”窗口中，current 的值变成"7"。  
15. 单击“逐语句”按钮。 
 调试器运行以下语句： 
steps.Text += current + "\n"; 
 该语句在 steps 文本框中显示文本"7"，后跟换行符，确保以后的输出从文本框的 下一行开始(窗体隐藏在 Visual Studio 后面，所以看不到)。黄色箭头移至 do 循环 末尾的结束大括号。 
16. 单击“逐语句”按钮。 
 黄色箭头指向 while 语句，准备求值 while 条件，判断是结束还是继续 do 循环。
17. 单击“逐语句”按钮。 
 调试器运行以下语句： 
while (amount != 0); 
 amount 的值是 124，表达式 124 != 0 求值结果是 true，所以进行下一次循环。 黄色箭头跳回 do 循环的起始大括号。 
18. 单击“逐语句”按钮。 
 黄色箭头再次指向 do 循环的第一个语句。        
19. 连续单击“逐语句”按 钮，重复三次 do 迭代，观察变量值在“局部变量”窗口中 的变化。 
20. 第 4 次迭代结束时，amount 值变成 0，current 值变成"1747"。黄色箭头指向 do 循环的 while 条件： 
while (amount != 0); 
 amount 目前是 0，所以表达式 amount != 0 求值结果是 false，do 循环终止。 
21. 单击“逐语句”按钮。 
 调试器运行以下语句： 
while (amount != 0); 
 和预期一样，do 循环终止，黄色箭头移至 showStepsClick 方法的结束大括号。 
22. 单击工具栏上的“继续”按钮或者按 F5。 
 窗体随后出现，显示为创建 999 的八进制形式所经历的 4 个步骤：7，47，747和 1747
23. 返回 Visual Studio 2017 并停止调试。

管理错误和异常 
使用 try，catch 和 finally 语句处理异常 
使用 checked 和 unchecked关键字控制整数溢出 
使用 throw 关键字从方法中抛出异常 
使用 finally 块写总是运行的代码(即使在发生异常之后) 
早期系统(如 UNIX)采用的典型方案要求在每次方法 出错时都由操作系统设置一个特殊全局变量。每次调用方法后都检查全局变量，判断方法 是否成功。和大多数面向对象编程语言一样，C#没有用这种痛苦的、折磨人的方式处理错 误。相反，它使用异常。为了写健壮的 C#应用程序，必须很好地掌握异常。 

尝试执行代码和捕捉异常 
错误任何时候都可能发生，使用传统技术为每个语句手动添加错误检测代码，不仅劳神费力，还容易出错。另外，如果每个语句都需要错误处理逻辑来管理每个阶段都可能发生的每个错误，会很容易迷失方向，失去对程序主要流程的把握。幸好，在 C#中利用异常 和异常处理程序①，可以很容易地区分实现程序主逻辑的代码与处理错误的代码。为了写支 持异常处理的应用程序，要做下面两件事。 
1. 代码放到 try 块中(try 是 C#关键字)。代码运行时，会尝试执行 try 块内的所有 语句。如果没有任何语句产生异常，这些语句将一个接一个运行，直到全部完成。 但一旦出现异常，就跳出 try 块，进入一个 catch 处理程序中执行。 
2. 紧接着 try 块写一个或多个 catch 处理程序(catch 也是 C#关键字)来处理可能发 生的错误。每个 catch 处理程序都捕捉并处理特定类型的异常，可在 try 块后面 写多个 catch 处理程序。try 块中的任何语句造成错误，“运行时”都会生成并 抛出异常。然后，“运行时”检查 try 块之后的 catch 处理程序，将控制权移交 给匹配的处理程序。
下面在 try 块中尝试将文本框中的内容转换成整数值，调用方法计算值，将结果写入 另一个文本框。为了将字符串转换成整数，要求字符串包含一组有效的数位，而不能是一 组随意的字符。如果字符串包含无效字符，int.Parse 方法抛出 FormatException 异常， 并将控制权移交给对应的 catch 处理程序。catch 处理程序结束后，程序从整个 try/catch 块之后的第一个语句继续。注意，如果没有和异常对应的处理程序，就说异常未处理(稍后 会讨论这种情况)。 
try  
{     
	int leftHandSide = int.Parse(lhsOperand.Text);      
	int rightHandSide = int.Parse(rhsOperand.Text);      
	int answer = doCalculation(leftHandSide, rightHandSide);      
	result.Text = answer.ToString(); 
} 
catch (FormatException fEx) 
{     
	// 处理异常 ... 
} 
catch 处理程序采用与方法参数相似的语法指定要捕捉的异常。在前例中，一旦抛出FormatException异常，fEx变量就会被填充一个对象，其中包含了异常的细节。FormatException类型提供大量属性供检查造成异常的确切原因。不少属性是所有异常通 用的。例如，Message 属性包含错误的文本描述。处理异常时可利用这些信息，例如可以把细节记录到日志文件，或者向用户显示有意义的消息，并要求重试。 

未处理的异常 
如果 try 块抛出异常，但没有对应的 catch 处理程序，那么会发生什么？在前例中， lhsOperand 文本框可能确实包含一个整数，但该整数超出了 C#允许的整数范围(例如"2147483648")。在这种情况下，int.Parse语句会抛出OverflowException异常，而catch处理程序目前只能捕捉FormatException异常。如果try块是某个方法的一部分，那个方法将立即退出，并返回它的调用方法。如果它的调用方法有 try 块，“运行时”会尝试定 位 try 块之后的一个匹配 catch 处理程序并执行。如果调用方法没有try块，或者没有找到匹配的catch处理程序，调用方法退出，返回它的更上一级的调用方法……以此类推。如果最后找到了匹配的catch处理程序，就运行它，然后从捕捉(到异常的)方法的 catch 处理程序之后的第一个语句继续执行。 
重要提示 捕捉异常后，将从“捕捉方法”中的 catch处理程序之后的第一个语句继续， 这个 catch 处理程序是实际捕捉到异常的 catch 块。控制 不会 回到造成异常 的方法。 
由内向外遍历了所有调用方法之后，如果还是找不到匹配的 catch 处理程序，整个程 序终止，报告发生了未处理的异常。 
可以很容易地检查应用程序生成的异常。以“调试”模式运行应用程序(选择“调 试”|“开始调试”)并发生异常，会出现如下图所示的对话框。应用程序暂停，便于判断造 成异常的原因。 
应用程序在抛出异常并导致调试器介入的语句停止。此时可检查变量值，可更改变量 的值，还可使用“调试”工具栏和各种调试窗格，从抛出异常的位置单步调试代码。 
使用多个 catch 处理程序 
通过前面的讨论，我们知道不同错误可能抛出不同类型的异常。为了解决这个问题， 可以提供多个 catch 处理程序。所有 catch 处理程序依次列出，像下面这样： 
try 
{    
	int leftHandSide = int.Parse(lhsOperand.Text);     
	int rightHandSide = int.Parse(rhsOperand.Text);     
	int answer = doCalculation(leftHandSide, rightHandSide);     
	result.Text = answer.ToString(); 
} 
	catch (FormatException fEx) 
{    
	//... 
} 
	catch (OverflowException oEx) 
{     
	//... 
} 
try 块中的代码抛出 FormatException 异常，和 FormatException 对应的 catch 块 开始运行。抛出 OverflowException 异常，和 OverflowException 对应的 catch 块开始运行。 
注意 如果FormatException catch块的代码自己又抛出了OverflowException异常， 不会造成相邻的那个 OverflowException catch 块的运行。相反，异常会传给 调用当前代码的方法。换言之，该异常会“传播”至调用栈的上一级。
捕捉多个异常 
C#和 Microsoft .NET Framework 的异常捕捉机制相当完善。.NET Framework 定义了许 多异常类型，包括程序可能抛出的大多数异常。一般不可能为每个可能的异常都写对应的 catch 处理程序——某些异常可能在写程序时都没有想到。那么，如何保证所有可能的异常都被捕捉并处理呢？这个问题的关键在于各个异常之间的关系。异常用继承层次结构进行组织。该继承层次结构由多个“家族”构成。FormatException 和 OverflowException异常都属于SystemException家族。该家族还包含其他许多异常。SystemException本身又是Exception家族的成员，而Exception是所有异常的“老祖宗”。捕捉Exception相当于捕捉所有可能发生的异常。 
注意 Exception 包含众多异常，其中许多异常是专供.NET Framework 的各种组件使用的。虽然一些异常较难理解，但知道如何捕捉它们总是没错。 
以下代码演示如何捕捉所有可能的异常： 
try 
{     
	int leftHandSide = int.Parse(lhsOperand.Text);     
	int rightHandSide = int.Parse(rhsOperand.Text);     
	int answer = doCalculation(leftHandSide, rightHandSide);     
	result.Text = answer.ToString(); 
} 
catch (Exception ex)  // 这是常规catch 处理程序，能捕捉所有异常 
	{     
		//... 
	} 
提示 如果真的决定捕捉 Exception，可以从 catch 处理程序中省略它的名称，因为默认捕捉的就是 Exception： 
   catch    
   {        
   		// …    
   } 
但不推荐这样做。传入 catch 处理程序的异常对象可能包含异常的重要信息。使用这个无参 catch 构造可能无法利用这些信息。 
最后还有一个问题：异常与 try 块之后的多个 catch 处理程序匹配会发生什么？假如 一个处理程序捕捉 FormatException，另一个捕捉 Exception，最终运行哪一个(还是两个 都运行)？  
异常发生后将运行由“运行时”发现的第一个匹配的异常处理程序，其他处理程序会 被忽略。如果让一个处理程序捕捉 Exception，后面又让另一个捕捉 FormatException， 后者永远都不会运行。因此，在 try 块之后，应将较具体的 catch 处理程序放在较常规的 catch 处理程序之前。没有发现较具体的，就运行较常规的。 
筛选异常 
用 when 关键字加一个布尔表达式，可筛选与 catch 处理程序匹配的异常，确保异常 处理程序仅在满足额外条件时才触发。例如： 
bool catchErrors = ...; 
try 
{     
	... 
} 
catch (Exception ex) when (catchErrors == true) 
{ 
// 仅在 catchErrors 变量为true 时才处理异常 
} 
本例依据 catchErrors 变量值选择性地处理所有异常（Exception 类型）。值为 false 不处理，将运行默认异常处理机制。值为 true 才运行 catch 块中的代码。 
以下练习演示当应用程序抛出未处理的异常时会发生什么，然后写try块捕捉异常。 
观察 Windows 如何报告未处理的异常 
1. 如果尚未运行，请启动 Visual Studio 2017。 
2. 打开 MathsOperators 解决方案，它位于“文档”文件夹下的\Microsoft Press \VCSBS\Chapter 6\MathsOperators 子文件夹。 
3. 在“调试”菜单中选择“开始执行(不调试)”。 在随后出现的窗体中，要在 Left Operand(左操作数)文本框中故意输入会造成异常 的文本，证明程序的这个版本健壮性①不足。 
4. 在 Left Operand 框输入 John，在 Right Operand 框输入2，单击+ Addition，再单击 Calculate。 
 这个无效输入会触发Windows默认异常处理机制。应用程序直接终止并返回桌面。
 了解 Windows 如何捕捉和报告未处理异常之后，接着练习处理无效输入和防止发生未处理异常，使应用程序更健壮。 
写 try/catch块 
1. 返回 Visual Studio 2017。 
2. 选择“调试”|“开始调试”。 
3. 窗体出现后，在 Left Operand 框中输入 John，在 Right Operand 框中输入2，单击 + Addition，再单击 Calculate。 
这会抛出与前面相同的异常，但由于以调试模式运行，Visual Studio 会捕捉并报告异常。 
如下图所示，Visual Studio 突出显示导致异常的语句，在一个对话框中描述异常，本例显示的是“Input string was not in a correct format” (输入字符串的格式不正确)。 可看出 addValues 方法内部的 int.Parse 调用抛出了一个 FormatException 异常。现在的问题是方法不能将文本"John"解析成有效数字。 
4. 在异常对话框中单击“查看详细信息”。 
 随后出现“快速监视”对话框，展开异常后可看到如所示的信息。
5. 关闭“快速监视”对话框，在 Visual Studio 中选择“调试”|“停止调试”。 
6. 在“代码和文本编辑器”窗口显示 MainPage.xaml.cs。找到 addValues 方法。 
7. 添加 try 块，把方法内部的语句包围起来。在 try 块后添加针对 FormatException 的 catch 块。新增的代码加粗显示： 
try 
{    
	int lhs = int.Parse(lhsOperand.Text);    
	int rhs = int.Parse(rhsOperand.Text);    
	int outcome = 0; 
 
   outcome = lhs + rhs;    
   expression.Text = $"{lhs} + {rhs}";    
   result.Text = outcome.ToString(); 
} 
   catch (FormatException fEx)
   {
   	result.Text = fF.Message;
   }
 发生 FormatException 异常，它的处理程序会将异常对象的 Message 属性中的文本写入窗体底部的 result 文本框。 
 8. 在“调试”菜单中选择“开始调试”。 
9. 窗体出现后，在 Left Operand 框中输入 John，在 Right Operand 框中输入 2，单击 + Addition，再单击 Calculate。 
 catch 处理程序成功捕捉 FormatException，Result 文本框显示消息：“Input string was not in a correct format”。应用程序的健壮性现在稍微增强了。  
 10. 用数字 10 替换 John，在 Right Operand 框中输入 Sharp，单击 Calculate。 
 由于 try 块将对这两个文本框进行解析的语句都包围起来了，所以同一个异常处 理程序能处理两个文本框的用户输入错误。 
11 用数字 20 替换 Right Operand 框中的 Sharp，单击 Calculate。 
 应用程序像预期的那样工作，在 Result 文本框中显示 30。 
12 在 Left Operand 框中用 John 替换数字 10，单击–Subtraction单选钮。 
 Visual Studio 启动调试器并再次报告 FormatException 异常。这次错误在 subtractValues 方法中发生，它还没有添加 try/catch 块。 
13 选择“调试”|“停止调试”。
传播异常 
为 addValues方法添加 try/catch 块使其变得更健壮，但同样的异常处理机制还要应 用于其他方法，包括 subtractValues ，multiplyValues ，divideValues 和remainderValues。所有代码都很相似，每个方法都要重复大量一样的代码。由于每次单击 Calculate 都是通过 calculateClick 方法来调用这些方法。所以为了避免重复的异常处理代码，有必要将异常处理机制放到 calculateClick 方法中。根据 “未处理的异常”的描述，任何算术运算方法发生 FormatException 异常，都会传回 calculateClick 方法进行处理。 
将异常传回调用方法 
1. 在“代码和文本编辑器”窗口中显示MainPage.xaml.cs 文件的代码，找到 addValues方法。 
2. 删除 addValues方法中的 try 块和 catch处理程序，恢复其原始状态，如下所示。 
private void addValues() 
{    
	int leftHandSide = int.Parse(lhsOperand.Text);    
	int rightHandSide = int.Parse(rhsOperand.Text);    
	int outcome = 0; 
 
   outcome = lhs + rhs;    
   expression.Text = $"{lhs} + {rhs}";    
   result.Text = outcome.ToString(); 
} 
3. 找到 calculateClick 方法并添加 try/catch 块，如以下加粗的代码所示。 
 
private void calculateClick(object sender, RoutedEventArgs e) 
{    
	try    
	{       
		if ((bool)addition.IsChecked)       
			{          
				addValues();       
			}       
		else if ((bool)subtraction.IsChecked)       
		{          
			subtractValues();       
		}       
		else if ((bool)multiplication.IsChecked)       
		{          
			multiplyValues();       
		}       
		else if ((bool)division.IsChecked)       
		{          
			divideValues();       
		}       
		else if ((bool)remainder.IsChecked)       
		{          
			remainderValues();       
		}    
	}    
	catch (FormatException fEx)    
	{        
		result.Text = fEx.Message; 
	}
}
4. 选择“调试”菜单中的“开始调试”命令。 
5. 窗体出现后，在 Left Operand 框中输入 John，在 Right Operand 框中输入 2，单击 + Addition，再单击 Calculate。 
 和之前一样，catch 处理程序成功捕捉 FormatException，Result文本框显示消 息：“Input string was not in a correct format”。但异常是在 addValues 方法中抛 出，由 calculateClick 方法的 catch 块捕捉。 
6. 单击–Subtraction，再单击 Calculate。 
 这次是 subtractValues 方法抛出的异常传回 calculateClick 方法进行处理。 
7. 测试* Multiplication，/ Division 和% Remainder 等算术运算，验证 FormatException 异常都被正常捕捉和处理。 
8. 返回 Visual Studio 并停止调试。 
注意 是否在方法中捕捉某个异常取决于应用程序的本质。有时需要尽可能当场捕捉， 有时需要传回上级调用方法捕捉。 
使用 checked 和 unchecked 整数运算 
提示 要使用 int 的最小或最大值，用 int.MinValue 和 int.MaxValue 属性更佳。 
int 固定大小引起一个问题。例如，在当前值已经是 2147483647 的一个 int 上加 1 会 发生什么？答案取决于应用程序如何编译。C#编译器默认允许悄悄溢出。换言之，将得到 一个错误答案(事实上，在最大值上加 1，会溢出至最大的负数值，结果是-2147483648)。 这是出于对性能的考虑：在几乎所有程序中，整数算术都是常见的运算，每个整数表达式 都进行溢出检查将严重影响性能。为此承担的风险大多数时候都能接受，因为你知道(或希 望)自己的 int 值不会超过限制。但假如不想冒这个险，也可手动启用溢出检查功能。 
提示 Visual Studio 2017 允许设置项目属性来启用或禁用溢出检查。在“解决方案资源 管理器”中选定项目，右击并选择“属性”。在项目属性对话框中单击“生成” 标签。单击右下角的“高级”按钮。在“高级生成设置”对话框中勾选或清除“检 查运算上溢/下溢”选项。 
不管如何编译，在代码中都可用 checked 和 unchecked 关键字选择性打开和关闭程序 一个特定部分的整数溢出检查。这些关键字会覆盖项目的编译器选项。 
编写 checked 语句 
checked 语句是以 checked 关键字开头的代码块。checked 语句中的任何整数运算溢 出都抛出 OverflowException 异常，如下例所示： 
int number = int.MaxValue; 
checked 
{     
	int willThrow = number++;     
	Console.WriteLine("永远都执行不到这里");
}
重要提示 只有直接在checked块中的整数运算才会检查。例如，对于块中的方法调用， 不会检查所调用方法中的整数运算。
还可用 unchecked 关键字创建强制不检查溢出的代码块。unchecked 块中的所有整数 运算都不检查，永远不抛出 OverflowException 异常。例如： 
int number = int.MaxValue; 
unchecked 
{     
	int wontThrow = number++;     
	Console.WriteLine("会执行到这里"); 
} 
编写 checked 表达式 
还可使用 checked 和 unchecked关键字控制单独整数表达式的溢出检查。只需用圆括 号将表达式封闭起来，并在之前附加 checked 或 unchecked关键字。如下例所示：  
int wontThrow = unchecked(int.MaxValue + 1);  // 不抛出异常 
int willThrow = checked(int.MaxValue + 1);  // 抛出异常 
复合操作符(例如+=和-=)和递增(++)/递减(--)操作符都是算术操作符，都可用 checked 和 unchecked关键字控制。记住，x += y;等同于 x = x + y;。
重要提示 不能使用 checked 和 unchecked 关键字控制浮点(非整数)运算。checked 和 unchecked 关键字只适合 int 和 long 等整型运算。浮点运算永远不抛出 OverflowException 异常——即使让浮点数除以 0.0 (2.5.1 节说过，.NET Framework 有专门表示无穷大的机制)。 
练习使用 Visual Studio 2017 执行 checked 算术运算
使用 checked 表达式 
1. 返回 Visual Studio 2017。 
2. 在“调试”菜单中选择“开始调试”。 
 接着试验两个大数相乘。 
3. 在 Left Operand 框中输入 9876543，在 Right Operand 框中也输入 9876543，单击* Multiplication，再单击 Calculate。 
 Result 文本框显示值–1195595903。负数肯定不对。之所以得到错误结果，是因 为在执行乘法运算时，悄悄溢出了 int 类型的 32 位限制。 
4. 返回 Visual Studio 2017 并停止调试。 
5. 在“代码和文本编辑器”窗口显示MainPage.xaml.cs，找到multiplyValues方法：
private void multiplyValues() 
{    
	int lhs = int.Parse(lhsOperand.Text);    
	int rhs = int.Parse(rhsOperand.Text);    
	int outcome = 0; 
 
   outcome = lhs * rhs;    
   expression.Text = $"{lhs} * {rhs}";    
   result.Text = outcome.ToString(); 
} 
    乘法溢出发生在 outcome = lhs * rhs;语句中。 
6. 编辑该语句，对表达式执行 checked 运算： 
outcome = checked(lhs * rhs); 
这样就实现了对乘法运算的检查。溢出将抛出 OverflowException 异常而非假装 返回一个答案。 
7. 选择“调试”菜单中的“开始调试”命令。 
 继续试验两个大数相乘。 
8. 在 Left Operand 框中输入 9876543，在 Right Operand 框中也输入 9876543，单击* Multiplication，再单击 Calculate。 
 Visual Studio 2017 启动调试器，报告乘法运算导致 OverflowException 异常。现 在需捕捉异常来得体地处理错误。 
9. 选择“调试”|“停止调试”。 
10. 在 MainPage.xaml.cs 中找到 calculateClick 方法。 
11. 在现有的 FormatException 处理程序后添加以下加粗的 catch 块。 
private void calculateClick(object sender, RoutedEventArgs e) 
{    
	try    
		{       
			...    
		}    
	catch (FormatException fEx)    
		{       
			result.Text = fEx.Message;    
		}    
	catch (OverflowException oEx)    
		{       
			result.Text = oEx.Message;    
		} 
} 
 这个异常的处理逻辑和 FormatException 相同，但仍有必要对两者进行区分，而 不是写一个常规的 Exception catch 处理程序，因为将来可能决定以不同方式处 理两个异常。 
12. 在“调试”菜单中选择“开始调试”，生成并运行应用程序。 
13. 在 Left Operand 框中输入 9876543，在 Right Operand 框中也输入 9876543，单击* Multiplication，再单击 Calculate。 
 第二个 catch 块成功捕捉 OverflowException 异常，Result 文本框显示消息 “Arithmetic operation resulted in an overflow”(算术运算导致溢出)。 
14. 返回 Visual Studio 并停止调试。
异常处理和 Visual Studio 调试器 
Visual Studio 调试器默认只在发生未处理异常时才中断应用程序。但有时需要调试异 常处理程序本身。这样就需要在异常被应用程序捕捉之前跟踪它们。可以很容易地启用该 功能。选择“调试”|“窗口”| “异常设置”。随后会在“代码和文本编辑器”窗口下方显 示“异常设置”窗格。 
在“异常设置”窗格中展开“Common Language Runtime Exceptions”，向下滚动，找 到并勾选“System.OverflowException”。 
现在若发生 OverflowException 异常，Visual Studio 将启动调试器，可利用“调试” 工具栏上的“逐语句”按钮跳入 catch 处理程序。 
抛 出 异 常 
假定要实现 monthName(月份名称)方法，它接收 int 参数并返回对应月份名称。例如， monthName(1)返回"January"，monthName(2)返回"February"。问题是：如传递的整数实 参小于 1 或大于 12，方法应返回什么？最好的答案是什么都不返回，应抛出异常。.NET Framework 类库包含专为这种情况设计的大量异常类。大多数时候都能从中找到符合要求 的(创建自己的异常类也很容易，但需掌握更多 C#知识)。对于本例，.NET Framework 的 ArgumentOutOfRangeException 类刚好满足要求。用 throw 语句抛出异常，如下例所示：
public static string monthName(int month) 
{     
	switch (month)     
	{         
		case 1 :            
			return "January";         
	 	case 2 :             
	 		return "February";         
	 		...         
	 	case 12 :             
	 		return "December";         
	 		default :             
	 			throw new ArgumentOutOfRangeException("不存在的月份");     
	}
} 
throw 语句抛出含异常细节的一个异常对象。本例用 new 关键字新建并初始化一个 ArgumentOutOfRangeException 对象，构造器用提供的字符串填充对象的 Message 属性。 
以下练习将修改 MathsOperators 项目，如用户未选择和操作符对应的单选钮，单击计 算按钮就会抛出异常。 
注意 该练习有一点儿“造作”，因为好的设计会提供默认操作符。但该程序就是为了 要证明这一点。 
抛出异常 
1. 返回 Visual Studio 2017。 
2. 在“调试”菜单中选择“开始调试”。 
3. 在 Left Operand 框中输入 24，在 Right Operand 框中输入 36，单击 Calculate。 Expression和Result 文本框什么都不显示。不仔细检查，恐怕还不知道尚未选择操作符。因此有必要在 Result 文本框中输出诊断消息，提醒尚未选择操作符。
 
4. 返回 Visual Studio 并停止调试。 
5. 在“代码和文本编辑器”窗口显示 MainPage.xaml.cs 的代码，找到并检查 calculateClick 方法，如下所示： 
 
private int calculateClick(object sender, RoutedEventArgs e) 
{    
	try    
		{       
			if ((bool)addition.IsChecked)       
				{          
					addValues();       
				}       
			else if ((bool)subtraction.IsChecked)       
				{          
					subtractValues();       
				}       
			else if ((bool)multiplication.IsChecked)       
				{          
					multiplyValues();       
				}       
			else if ((bool)division.IsChecked)       
				{          
					divideValues();       
				}      
			else if ((bool)remainder.IsChecked)       
				{          
					remainderValues();       
				}    
			}    
			catch (FormatException fEx)    
				{       
					result.Text = fEx.Message;    
				}    
			catch (OverflowException oEx)    
				{       
					result.Text = oEx.Message;    
				} 
		} 
 addition，subtraction，multiplication，division和 remainder 是窗体上显 示的各个操作符单选钮。每个单选钮都有 IsChecked 属性，指出是否已选定。 IsChecked是可空布尔值。如选定，值为 true；否则为 false。层叠的 if 语句依次检查每个单选钮，判断具体哪个被选中。(单选钮是互 斥的，一次只能选中一个。 )没有任何单选钮被选中，就没有任何 if 语句的条件为 true，不会调用任何计算方法。 为了处理没有选中任何单选钮的情况，可在 if-else结构中添加一个 else 子句， 在发生这种情况时向 result 文本框输出消息。但更好的做法是将检测/通知错误 的代码与捕捉/处理错误的代码分开。 
 6. 在 if-else 结构末尾添加 else 子句来抛出 InvalidOperationException 异常。 如以下加粗的代码所示： 
if ((bool)addition.IsChecked) 
{    
	addValues(); 
} 
... 
else if ((bool)remainder.IsChecked) 
{    
	remainderValues(); 
} 
else 
{    
	throw new InvalidOperationException("No operator selected"); 
} 
7. 在“调试”菜单中选择“开始调试”，生成并运行应用程序。 
8. 在 Left Operand 框中输入 24，在 Right Operand 框中输入 36，不选择要执行什么 计算，单击 Calculate。 
 Visual Studio 检测到 InvalidOperationException 异常并显示异常对话框。应用 程序虽抛出异常，但尚未捕捉。 
9. 选择“调试”|“停止调试”。 
前面写了 throw 语句，证实它能抛出异常，接着写 catch 处理程序捕捉该异常。 

捕捉异常 
1. 在“代码和文本编辑器”窗口显示MainPage.xaml.cs，找到calculateClick方法。 在方法现有两个 catch 处理程序之后，添加以下加粗的 catch 处理程序： 
 
... 
catch (FormatException fEx) 
{    
	result.Text = fEx.Message; 
} 
catch (OverflowException oEx) 
{    
	result.Text = oEx.Message; 
} 
catch (InvalidOperationException ioEx) 
{    
	result.Text = ioEx.Message; 
} 
代码捕捉 InvalidOperationException 异常。没有选择任何操作符并单击 Calculate 将抛出该异常。 
2. 在“调试”菜单中选择“开始调试”，生成并运行应用程序。 
3. 在 Left Operand 框中输入24，在 Right Operand 框中输入36，不选择任何计算，单击 Calculate。Result 文本框显示消息“No operator selected”。 
注意 如应用程序自动切换到 Visual Studio 调试器，可能是因为你允许 Visual Studio 捕 捉所有 CLR 异常。在此情况下，请选择“调试”｜“继续”。完成本练习后，记得禁止 Visual Studio 捕捉 CLR 异常（Common Language Runtime Exceptions）。 
4. 返回 Visual Studio 并停止调试。 
应用程序的健壮性已获得大幅增强，但仍有几个可能发生的异常未被捕捉，它们会造 成应用程序执行失败。例如，试图除以 0会抛出未处理的 DivideByZeroException(虽然浮 点数除以 0 不会抛出异常，但整数除以 0 会抛出异常)。为了解决问题，一个办法是在 calculateClick 方法内添加更多的 catch 处理程序。但更好的方案是在 catch 处理程序 列表的末尾添加常规 catch 处理程序来捕捉 Exception。这样就能捕捉一切未处理的异常。
注意 虽然能捕捉 Exception 来捕捉一切异常，但特定的异常还是需要单独捕捉的。异 常处理越具体，维护代码和发现问题越容易。只有真正罕见的异常才适合用 Exception 捕捉。我们出于练习的目的将“除以 0”（DivideByZeroException） 异常划分到这个类别。但在专业软件中，该异常应专门处理。 

捕捉未处理的异常 
1. 在“代码和文本编辑器”中显示 MainPage.xaml.cs，找到 calculateClick 方法， 在现有的一系列 catch 处理程序的末尾，添加以下常规 catch 处理程序： 
catch (Exception ex) 
{     
	result.Text = ex.Message; 
} 
 该 catch 处理程序捕捉所有未处理的异常，无论异常具体是什么类型。 
2. 在“调试”菜单中选择“开始调试”。 
 现在试验一些已知会造成异常的计算，确定它们都会被捕捉。 
3. 在 Left Operand 框中输入 24，在 Right Operand 框中输入 36，单击 Calculate。 
 确定 Result 文 本 框 仍 显 示 “No operator selected” 。 消 息 由InvalidOperationException 处理程序生成。 
4. 在 Left Operand 框中输入 John，单击+Addition，再单击 Calculate。 
 确定 Result 文本框显示“Input string was not in a correct format”。消息由 FormatException 处理程序生成。 
5. 在 Left Operand 框中输入 24，在 Right Operand 框中输入 0，单击/Division，再单 击 Calculate。 
 确定 Result 文本框显示“Attempted to divide by zero”。它由刚才添加的常规 Exception处理程序生成。 
6. 试验值的其他组合，验证异常情况都得到处理，不会造成应用程序失败。 
7. 结束后返回 Visual Studio 并停止调试
使用 throw 表达式 
throw 表达式语义上和 throw 语句相似。区别在于，凡是能使用表达式的地方都能使 用 throw 表达式。例如，假定要将字符串变量 name 设为用户在窗体上的 nameField 文本 框中输入的内容，但前提是用户真正输入了一个值，否则就抛出一个“未输入值”异常。 可使用以下代码： 
string name; if (nameField.Text != "") 
{     
	name = nameField.Text; 
} 
else 
{     
	throw new Exception("未输入值"); // 这是 throw 语句 
} 
能用，但不优雅。可用 throw 表达式加一个?:操作符简化上述代码。?:操作符相当于 针对一个表达式的 if…else 语句。作为三元条件操作符，它要获取三个操作数： 
条件 ? 第一个表达式 : 第二个表达式 
首先求值“条件”，为 true 就求值“第一个表达式”，为 false 就求值“第二个表达 式”。例如： 
// 用throw 表达式改写 string name = nameField.Text != "" ? nameField.Text : throw new Exception("未输入值"); 
如 nameField 文本框不为空，就将 Text 属性的值存储到 name 变量中。否 则求值 throw 表达式来抛出异常。一行代码就做了前面好多行代码做的事情。 

使用 finally 块 
记住，抛出异常会改变程序执行流程。这意味着不能保证当一个语句结束之后，它后 面的语句肯定运行，因为前一个语句可能抛出异常。之前说过，当 catch 处理程序运行完 毕，会从整个 try/catch 块之后的语句继续，而不是从抛出异常的语句之后继续。 
以下例子。很容易以为 while 循环结束后肯定调用 reader.Dispose。 毕竟，它就在代码中明摆着。 
TextReader reader = ...;
...
string line = reader.ReadLine();
while (line != null) 
{    
	...    
	line = reader.ReadLine(); 
} 
reader.Dispose(); 
不执行某个语句，有时没问题，但许多时候都有大问题。假如语句作用是释放它之前 的语句获取的资源，不执行就会造成资源得不到释放。上例清楚演示了这一点：如打开文 件进行读取，将获取一个资源(文件句柄)，必须调用 reader.Dispose 释放该资源，否则迟 早用光所有文件句柄，造成无法打开更多文件。(如果觉得文件句柄过于普通，那么换成数 据库连接呢？) 
解决方案是写一个 finally 块，放到其中的语句总是运行(无论是否抛出异常)。 finally 块要么紧接在 try 块之后，要么紧接最后一个 catch 块之后。只要程序进入与 finally 块关联的 try 块，finally 块始终都会运行——即使发生异常。如抛出异常，而 且在本地捕捉到该异常，那么首先运行异常处理程序，然后运行 finally 块。如没有在本 地捕捉到异常(也就是说，“运行时”必须在调用栈的上一级搜索匹配的处理程序)，那么首 先运行 finally 块，再搜索异常处理程序。无论如何，finally 块总是运行。 
所以可用以下方案确保 reader.Dispose 总是得到调用： 
 
TextReader reader = ...; 
... try 
{    
	string line = reader.ReadLine();    
	while (line != null)    
		{       
			...       
			line = reader.ReadLine();    
		} 
} 
finally 
{    
	if (reader != null) 
		 {       
		 	reader.Dispose();    
		 } 
} 
即使读取文件时发生异常，finally 块也保证 reader.Dispose 语句得到执行。第 14 章将介绍解决该问题的另一个方案(使用 using 语句)。 

理解C＃对象模型
创建并管理类和对象
定义类来包含一组相关的方法和数据项
使用 public 和 private 关键字控制类成员的可访问性使用new关键字创建对象并调用构造器来初始化它
编写并调用 自己的构造器
使用 static 关键字创建可由类的所有实例共享的方法和数据
理解如何创建匿名类
Windows Runtime 和 Microsoft .NET Framework 包含数量众多的类 。类提供了对应用程序操纵的实体进行建模的便利机制 。实体既可代表具体的东西（如客户）,也可代表抽象的东西（如事务处理）  。任何系统在设计时都要确定哪些实体是重要的 ,分析它们要容纳什么信息和提供哪些功能。类容纳的信息用字段存储，类执行的操作用方法实现 。
理 解 分 类
英语里面的类（class）是分类（classification）的词根 。设计类的过程就是对信息进行分类 ，将相关信息放到有意义的实体中 。所有人都会分类并非只有程序员才会 。例如，所有汽车都有通用的行为 （都能转向 、制动、加速等）和通用的属性（都有方向盘 、发动机等）。人们用 “汽车” 一词泛指具有这些行为和属性的对象 。只要所有人都认同一个词的意思 ，这个系统就能很好地发挥作用 ，可以使用简练的形式表达复杂而精确的意思  。不会分类 ，很难想象人们如何思考与交流 。
既然分类己在我们思考和交流的过程中根深蒂固 ，那么在写程序时 ，也很有必要对问题及其解决方案中固有的概念进行分类 ，然后用编程语言对这些类进行建模 。这正是包括 Microsoft Visual C＃在内的现代面向对象编程语言的宗旨 。
封装的目的
封装是定义类时的重要原则 。其中心思想是：使用类的程序不应关心类内部如何工作。 程序只需创建类的实例并调用类的方法  。只要方法能做到它们宣称能做到的事情 ，程序就不关心它们具体如何实现 。例如在调用 Console.Writeline方法时 ，肯定不会想去了解 Console 类将数据输出到屏幕的复杂细节 。类为了执行其方法 ，可能要维护各种内部状态 信息 ，还要在内部采取各种行动 。在使用类的程序面前 ，这些额外的状态信息和行动是隐藏的 。因此，封装有时称为信息 隐藏，它实际有两个目的 ： 将方法和数据合并到类中，也就是为了支持分类：控制对方法和数据的访问，也就是为了控制类的使用。
定义并使用类
c#用class关键字定义新类。类的数据和方法放在类的主体中（两个大括号之间）一下circle类包含方法（计算圆的面积）和数据（圆的半径）
class Circle
{
	int radius:double Area()
	{
		return Math.PI*radius*rasius;
	}
}
注意Math类包含用于执行数学计算的方法，还用一些字段定义了数学常量。其中Math.PI字段包含值3.14159265358979 ，即圆周率的近似值 。
类主体包含的是一般的方法（如Area）和字段（如radius）记住c#术语将类中的变量称为字段。
Circle类的使用方式和之前用到的其他类型相似。以Circle为类型名称创建变量，再以有效的数据初始化它
Circle c;
c= new Circle()
注意这里使用了new关键字。以前在初始化int或float变量时是直接赋值
int i；
i=42；
但类类型的变量不能像以前那样赋值。一个原因是c#没有提供将字面赋值给类变量的语法，例如不能像下面这样写
Circle c;
c= 42;
等于42的Circle是什么意思?另一个原因涉及“运行时”对类的类型的变量的内存进行分类与管理方式，new关键字将新建类的实例。所谓“类的实例”更通俗的说法就是“对象”。
但是 ，可以直接将类的实例赋给相同类型的另 一个变量 ，例如 ：
Circle c;
c = new Circle( );
Cicle d;
d = c;
但如果这样赋值 ，实际发生的事情或许并不是你想象的那样 。
重要提示类和对象不要混淆 。类是类型的定义 ，对象则是该类型的实例 ，是在程序运行时创建的 。换言之 ，类是建筑蓝图 ，对象是按蓝图建造的房子 。同一个类可以有多个实例 ，正如同一张蓝图可建造多栋房子 。
控制可访问性
令人惊讶的是 ，Circle类目前没有任何实际用处 。默认情况下 ，方法和数据封装到类中，就和外部世界划清了界线 。类的其他方法能看见类的宇段（如radius）和方法（如 Area), 但外界看不见 。换言之，它们是类“私有” 的。虽然能创建 Circle 对象，但访问不了radius 字段，也调用不了A俨ea 方法。正因为如此，该类目前并没有多大用处 。但是 ，可用 pu blic 和 private 关键字修改宇段或方法的定义 ，决定它们是否能从外部访问 。
只能从类内部访问的方法或宇段是私有的 。声明私有方法或字段需要在声明前添加 private 关键字。默认添加的就是该关键字 ，但作为良好编程实践 ，应显式将 宇段和方法声明为 private ，以免困惑。
方法或宇段如果既能从类的内部访问  ，也能从外部访问 ，就说它是公共的 。声明 公共方法或宇段需在声明前添加 pu blic 关键字。
以下是修改过的 Circle类。这次 Area 方法声明为公共方法 ，radius 声明为私有字段 ：
class Circle
{
	private int radius;public double Area()
	{
		return Math.PI*radius*radius;
	}
}
注意 c++程序员注意，public或private关键字后面不要加冒号。每个字段和方法声明都要重复public或private关键字。
虽然radius被声明为私有字段：不能从类的外部访问，但能在类的内部访问。这正是Area方法能访问radius字段的原因。尽管如此，Circle类的作用目前依然有限，因此还无法初始化rasiud字段。解决方案是使用构造器。
提示	方法中声 明的变量不会自 动初始化 ，但类的字段会自 动初始化为 0, false 或 null ，具体视类型而定。不过，好的编程实践是始终显式初始化字段 。 
命名和可访问性
许多企业规定了自己的编码样式，标识符命名是其中一环，目的是加强代码的可维护性。出于对类成员可访问性的考虑，推荐采用以下字段和方法命名规范（c#未强制这些规范）
公共标识符以大写字母开头，例如Area以A而非a开头，因为它是公共的。这是所谓的PascalCase命名法（因为最早在Pascal语言中使用）
非公共公共标识符（包括局部变量）以小写字母开头。例如radius以r开头而非以R开头
因为它是私有的。这是所谓的camelCase命名法
有的企业只将camelCae命名法用于方法，私有字段以下划线开头，例如_radius。
上述规则仅有一个例外：类名以大写字母开头。构造器必须完全和类同名，所以私有构造器也以大写字母开头。
重要提示 不要声明名称仅大小写不同的两个公共成员，否则不区分大小写的其他语言（如Microsoft visual basic）的开发者可能无法在其解决方案中集成该类。
使用构造器
使用new关键字创建对象时“运行时”必须根据类的定义构造对象那，必须从操作系统申请内存区域，在其中填写类定义的字段，然后调用构造器执行任何必要的初始化。
构造器是在创建类的实例时自动进行的方法，它与类同名，能获取参数但不能返回任何值（void都不能加）。每个类至少要有一个构造器，不提供构造器，编译自动生成一个什么都不做的的默认构造器。自己写的默认构造器很容易——添加与类同名的公共方法，不返回任何值就可以了。下面展示了有默认构造器的Circle类，这个自己写的构造器将能radius字段初始化为0：
class Circle
{
	private int radius;
	public Circle() //
	{
		radius = 0;
	}
	public double Area()
	{
		return Math.PI*radius*radius;
	}
}
注意 C＃默认构造器是无参构造器 。不管编译器生成还是自己写，默认构造器都必定无参。非默认构造器（有参构造器 ）可以随便写。
本例的构造器标识为 public 。省略该关键字 ，构造器默认为私有(和其他方法和字段一样）。私有构造器不能在类的外部使用 ，造成无法从 Circle 类的外部创建 Circle 对象。 但并不是说私有构造器完全无用 。
添加公共构造器后 ，Circle类就可以使用了，可开始使用它的 Area方法。注意，用圆点记号法调用 Circle 对象的 Area 方法：
Circle c;
c = new Circle();
double areaOfCircle = c.Area();
重载构造器 
现在可以声明Circle变量，让它指向新建的Circle对象,并调用它的Area方法。但工作还没有结束,还有最后一个问题需要解决,所有Circle对象的面积都是0，因为默认构造器把radius设为0之后,radius的值就没有变过（radius字段是私有的，初始化后不好改变它的值）。为了解决这个问题，必须认识到构造器本质上还是方法。和所有方法一样可以重载。我们知道，Console.Writeline方法有好几个版本，每个版本都获取不同参数。类似地，构造器也可以有多个版本 。下面在 Circle 类中添加一个构造器 ，取半径作为参数。
class Circle
{
	private int radius;
	public Circle()//默认构造器
	{
		radius = 0;
	}
	public Circle(int initialRadius)
	{
		radius = initialRadius;
	}
	public double Area()
	{
		return Math.PI*radius*radius;
	}
}
注意 构造器在类中的顺序无关紧要
然后可在新建 Circle 对象时调用该构造器，如下所示:
Circle c;
c = new Circle(45);
生成应用程序时，编译器根据为 new 操作符指定的参数判断应该使用哪个构造器 。本例传入一个int ，所以编译器生成的代码将调用获取一个int参数的构造器 。 
C＃的一个重要特点是 ，一旦为类写了任何构造器 ，编译器就不再自动生成默认构造器 。 所以 ，一旦写了构造器 ，让它接收一个或多个参数 ，同时还想要默认构造器 ，就必须自己写一个（无参构造器）。 
分部类
类可以包含大量方法 、字段、构造器以及以后会讲到的其他项 。一个功能齐全的类可能 相当大。C＃允许将类的源代码拆分到单独的文件中 。这样，大型类的定义就可用较小的 、 更易管理的部分进行组织 。Visual Studio 2017 为通用 Windows 平台（UWP）应用采用的就是这种代码组织技术 。开发者可编辑的源代码在一个文件中维护 ，窗体布局变化时由Visual Studio  生成的代码在另一个文件中维护 。 
类被拆分到多个文件中之后 ，要在每个文件中使用partial（分部）关键字定义类的不同 部分。例如，假定Circle 类被拆分到两个文件中，分别是circl.cs（ 包含构造器）和 circ2.cs （ 包 含方法和字段），那么 circl .cs 的内容如下： 
partial class Circle
{
	public Circle()
	{
		this.radius = 0;
	}
	public Circle(int intitialRadius)
	{
		this.radius = initialRadius;
	}
}        
circ2.cs的内容如下：
partial class Circle
{
	private int radius;
	public double Area()
	{
		return Math.PI*this.radius*this.radius;
	}
}
编译拆分到多个文件的类时，必须向编译器提供全部文件
以下练习定义一个类来建模平面几何中的点。类包含两个私有字段，用于保存点的横坐标x和纵坐标y。此外，类还包含用于初始化这两个字段的构造器。将用new关键字创建类的实例，并调用构造器初始化它 。
编写构造器并创建对象
1.如Microsoft Visual Studio 2017尚未启动,请启动。
2.打开Clases解决方案,它位于"文档"文件夹下的Microsoft\Press\VCSBS\Chapter7\Classes 子文件夹。
3.在"解决方案资源管理器"中双击Program.cs 文件,在"代码和文本编辑器"窗口中显示它。
4.找到Program类中的Main方法。Main方法调用了dowork方法。对 doMork方法的调用封闭在try块中,try块之后是 catch 处理程序。可利用这个try/catch块在doMork方法中写以前一般出现在Main中的代码,并可放心地知道所有异常都会被捕捉。dowork方法目前还是"光杆司令",只有一条/TO00:注释。
提示 T000:注释常用于标注以后要加工的代码,指出此处应完成什么工作。例如//TOD0:实现domork方法。Visual Studio 能识别这种注释,可利用"任务列表"窗口快速定位,选择"视图"|"任务列表"来打开该窗口.如下图所示,"任务列表"窗口默认在"代码和文本编辑器"窗口下方显示,所有TODO注释都被列出,双击即可在"代码和文本编辑器"中定位。
5. 在"代码和文本编辑器"窗口中打开Pointcs 文件。定义了Point类,用于表示×和y坐标所定义的点。类中目前只有/TO00:注释。返回Program.cs文件,找到Program类中的doMork方法。编辑dowork方法主体,用以下语句替换//TOD0:注释:Point origin= new Point();
7.选择"生成"|"生成解决方案"。程序成功生成,没有报错,因为编译器自动生成了 Point类的默认构造器。但看不到该构造器的C#代码,编译器不可能帮你添加源代码。
8.返回 Point.cs文件中的Point类。用公共构造器（接受两个int 参数×和y,调用Console.MriteLine方法在控制台上输出这些参数的值)替换//TOD0:注释,如以下加粗的代码所示。Point类现在应该像下面这样：
class Point
{
	public Point(int x,int y)
	{
		Console.WriteLine($"x:{x},y:{y}");	
	}
}
9 选择"生成"|"生成解决方案"。
这次编译器报错,如下所示:提供与"Point.Point(int,int)"的必需形参"×"对应的实参doWork对默认构造器调用失败，为现在不再有默认构造器。一旦为Point类写了自己的构造器,编译器就不再自动生成默认构造器。对策是自己写一个。
10.编辑 Point类添加公共默认构造器。调用 Console.MrteLine方法,在控制台上输出字符串"Default constructor called"。现在的Point类像下面这样:
class Point
{
	public Point()
	{
		Console.WriteLine("Defaut constructor called");
	}
	public Point(int x,int y)
	{
		Console.WriteLine($"x:{x},y:{y}");
	}
}
11.选择“生成”|“生成解决方案”。程序成功生成。
12.如下加粗的代码所示，在Program.cs文件中编辑doWork方法主体，声明Point变量bottomRight。使用获取两个参数的构造器初始化该Point。参数值分别使用1366和768，表示分辨率为1366x768（许多平板设备的常用分辨率）的屏幕右下角坐标。现在的doWork方法如下所示
static void doWork()
{
	Point orign = new Point();
	Point bottomRight = new Point(1366 ,768)
}
13.在“调试”菜单中选择“开始执行（不调试）”
应用程序顺利产生并运行，向控制台输出所示信息。
14. 按Enter键终止程序运行并返回Viual Studio
现在要在Point类中添加两个int字段来表示点的x和y坐标，然后修改构造器来初始化这些字段。
15. 在Point.cs文件中编辑Point类，添加两个私有int字段x和y，如下加粗的代码所示。现在的Point类应该像下面这样:
class Point
{
	private int x,y;
	public Point()
	{
		Console.WriteLine(“Default constructor called”);
	}
	public Point(int x,int y)
	{
		Console.WriteLine(&"x:{x},y:{y}");
	}
}
接着编辑第二个Point构造器，将x和y字段初始化成x和y参数的值。但是留意一个陷阱。不小心可能写出如下所示的构造器:
public Point(int x,int y)
{
	x=x;//错误的写法
	y=y;//错误的写法
}
虽然代码能够编译,但这些语句存在严重歧义。编译器如何知道在x =x;这样的语句中,第一个×是字段,第二个x是参数?事实上,编译器根本就不会区分!
如果方法的参数与某个字段同名,在该方法的任何语句中,参数都将覆盖字段。所以上述构造器实际做的事情是将参数赋给它自己,根本不会修改字段。这显然不是我们所希望的。
对策是用 this关键字限定哪些变量是参数,哪些变量是字段。为变量附加 this前缀,意思就是"这个对象(this)的字段"。
16.修改获取两个参数的 Point 构造器,用以下加粗显示的代码替换
Console.WriteLine语句：
public Point(int x,int y)
{
	this.x = x;
	this.y = y;
}
17.编辑 Point 类的默认构造器,将 x和 y字段初始化为-1(同时删除Console.MriteLine 语句)。虽然目前没有参数来"捣乱",但作为好的编程实践,仍应使用 this 明确指出它们是字段引用:
public Point()
{
	this.x=-1;
	this.y=-1;
}
18.选择"生成"|"生成解决方案"。确定代码成功编译,不会显示错误或警告(也可运行它,只是还不能产生任何输出)。
如果方法从属于一个类,而且操纵的是类的某个实例的数据,就称为实例方法。以下练习为Point类添加实例方法DistanceTo,用于计算两点之间的距离。    
编写并调用实例
1. 编辑 Point.cs 文件中的Point类,在构造器之后添加以下公共实例方法
DistanceTo.它接收 Point 参数other并返回一个double:
class Point
{
	...
	public double DistanceTo(Point other)
	{
	}
}
面要添加 DistanceTo 实例方法的主体代码,计算并返回两个 Point 对象之间的距离。两个对象中,第一个 Point是发出调用的对象,第二个 Point是作为参数传递的对象。首先计算x和y坐标差值。
2. 在DistanceTo方法中声明int变量xDff,初始化为this.x和other.x的差值|如加粗代码所示:
public double DistanceTo(Point other)
{
	int xDiff = this.x - other.x;
}
3. 再声明int变量yDiff，初始化为this.y和other.y的差值，如下加粗代码所示：
public double DistanceTo(Point other)
{
	int xDiff = this.x - other.x;
	int yDiff = this.y - other.y;
}
注意 虽然×和y是私有字段,但类的其他实例可以访间它们。"私有"是类级别上的私有,而对象级的私有.同一个类的两个实例能相互访问私有数据,但访问不了其他类的实例中的私有数据。
勾股定理计算两点之间的距离,即 xDi什f 与 yDiff的平方和的平方根。System.Math类提供了Sqrt方法来计算平方根。
4. 声明double变量distance来容纳计算结果。
public double DistanceTo(Point other)
{
	int xDiff = this.x - this.x;
	int yDiff = this.y - other.y;
	double distance = Math.Sqrt((xDiff * xDiff) + (yDiff * yDiff));
}
5.Distance方法末尾添加 return 语句返回 distance值:
public double DistanceTo(Point other)
{
	int xDiff = this.x - other.y;
	int yDiff = this.y - other.y;
	double distance = Math.Sqrt((xDiff *xDiff) + (yDiff * yDiff);
	return distance;
}
下面测试DistanceTo方法
6.返回 Program 类中的 dowork 方法。在声明并初始化 Point 变量 origin和bottomRight的语句后声明 double 变量distance。调origin对象的DistanceTo方法,将bottomRight对象作为参数传递。结果用于初始化distance
变量,现在的doWork方法应该像下面这样:
static void doWork
{
	Point origin = new Point();
	Point bottomRight = new Point(1366,768);
	double distance = origin.DistanceTo(bottomRight);
}
注意 有"智能感知"帮助,输入origin之后的句点会自动列出DistanceTo方法.
7.在 doMork 方法中再添加一个语句,使用Console.MriteLine 方法将 distance变量的值输出到控制台。最终的dowork方法如下所示:
static void doWork()
{
	Point origin = new Point();
	Point bottomRight = new Point(1366,768);
	double diatance =origin.DistanceTo(bottomRight);
	Console.WriteLine($"Distance is：{distance}");
}
8 在"调试"菜单中选择"开始执行(不调试)"。
9 确定控制台窗口显示 1568.45465347265。按 Enter键关闭程序并返回Visual
Studio。
解构对象
构造器(constructor)创建并初始化对象(通常是填充它包含的字段)。解构器(deconstructor)则检查对象并提取它的字段的值。以上个练习的Point类为例,可像下面这样实现解构器来获取x和y字段的值。
clsss Point
{
	private int x, y;
	...
	public void Deconstruct(out int x.out int y)
	{
		x = this.x;
		y = tjis.y;
	}
} 
以下是关于解构器的重要事实。
须命名为 Deconstruct,必须是void方法。必须获取一个或多个参数。这些参数用对象中的字段的值填充。数用 out 修饰符加以标记。意味着如果向其赋值,这些值会传回调用者。方法主体代码向参数赋值。
用解构器的方式和调用返回一个元组的方法一样。只需创建元组并将对象赋给它,例如
Point origin = new Point():
...
(int xVal,int yVal)=origin;
C#在幕后运行解构器,向其传递元组中定义的变量。解构器中的代码则填充这些变量。例如,假定没有修改 Point类的默认构造器,现在xVal和yVal变量都应包含值-1。
记住要使用元组,必须用NuGet 包管理器添加 System.ValueTuple程序包。了解构器,还有其他方式获取对象中的字段的值。用"属性"做同样的事情。  

理解静态方法和数据
个练习使用了Math类的Sqrt方法;类似地,之前在Circle类中用过 Math类的PI字段。有没有觉得调用Sqrt方法(Nath.Sqrt)和使用PI字段(ath.PI)的方式有点儿奇怪?
是直接在类的上面调用方法,也是直接在类的上面使用字段,而不是先创建Math类的对象,再在这个对象的基础上调用方法和使用字段。这好比写Point.DistanceTo 而不是写origin.DistanceTo。到底发生了什么,为什么能这样写?
事实上,并非所有方法都天生从属于类的某个实例。这些称为工具方法或实用方法,通常提供了有用的、和类的实例无关的功能。Sqrt方法就是一个例子。如果把Sqrt设计成Nath类的实例方法,就必须先创建Math对象,然后才能在那个对象上调用Sqrt:
Math m = new Math();
double d = m.Sqrt(42.24);
这太麻烦了。Math对象对平方根计算没有任何帮助。Sqrt需要的所有输入数据都已在参数列表中提供，结果果也通过方法返回值传给调用者。对象在这里是不必要的,强迫 Sqrt成为实例方法不是好主意。
除了Sqrt方法和PI字段,MathMath类还包含其他用于数学计算的工具方法,如sin,cos,tan和log等。
有方法都必须在类的内部声明。但如果把方法或字段声明为 static(静态），就可使用类名调用方法或访问字段。下面展示了Math类的 Sqrt方法具体如何声明: 
class Math
{
	public static double Sqrt(double d)
	{
		...
	}
}
可以像下面这样调用Sqrt方法：
double d = Math.Sqrt（42.24）;
静态方法不依赖类的实例，不能再其中访问类的任何实例字段或实例方法。相反，只能访问标记为static的其他方法和字段。
创建共享字段
静态字段能在类的所有对象之间共享（非静态字段则局部于类的实例）。
在下例中,每 次新建Circle对象,Circle构造器都使Circle类的静态字段NumCircles递增1:
class Circle
{
	private int radius;
	public static int NumCircle = 0;

	public Circle()
	{
		radius = 0;
		NumCircles++;
	}
	public Circle(int initialRadius)
	{
		radius = initialRadius;
		NumCircles++
	}
}
NumCircles字段由所有Circle对象共享，所以每次新建实例，NumCircles++;语句递增的都是相同的数据。从类外访问NumCircles字段，要以Circle作为前缀，而不是以类的实例名称作为前缀。例如：
Console.WriteLin($"Number of Circle objects:{Circle.NumCircles}");
注意 在c#术语中，静态方法也称为常量字段，是一种特殊的静态字段，值永远不变。关键字 const 是"constant"(常量)的简称。const字段虽然也是静态字段，但声明时不用
static关键字。只有数值类型(如int或double)、字符串(string)类型和枚举(enum)类型
的字段才能声明为const 字段。这样设计是有原因的,例如,在真正的Math类中,PI就被声明为const字段:
class Math
{
	...
	public const double PI = 3.14159265358979;
}
理解静态类
c#允许声明静态类。静态类只能包含静态成员(使用该类创建的所有对象都共享这些成员的单一拷贝)。静态类纯粹作为工具方法和字段的容器使用。静态类不能包含任何实例数据或方法。另外,用new操作符创建静态类的对象没有意义,编译器会报错。为了执行初始化,静态类允许包含一个默认构造器,前提是该构造器也被声明为静态。其他任何类型的构造器都是非法的,编译器会报错要定义自己的Math类,其中只包含静态成员,应该像下面这样写:
public static class Math
{
	public static double Sin(double x) {...}
	public static double Cos(double x) {...}
	public static double Sqrt(double x) {...}
	...
}   
注意 真正的Math类不这么写，它有实例方法。
静态using语句
任何时候调用静态方法或者引用静态字段，都必须指定方法或者字段所属的类，比如Math.Sqrt或Console.WriteLine。静态using语句允许将类引入作用域，以便在访问静态成员时省略类名。这类似于普通的using语句将命名空间引入作用域。下例对此进行了演示：
using static Sysem.Math;
using static System.Console;
...
var root = Sqrt(99.9);
WriteLine($"The square root of 99.9 is {root}");
在using语句中使用了static关键字。本例将 System.Math和 System.Console
类的静态方法引入作用域(类名要附加命名空间前缀进行完全限定)。然后就可直接调用Sqrt和MriteLine方法了。编译器自行判断方法属于哪个类。但这样会产生潜在的维护问题。虽然能少写点代码,但别人维护你的代码时就得多花点功夫了,因为哪个方法属于哪个类变得不太明显了。Visual Studio 的"智能感知"功能可提供一定程度的帮助,但开发人员在通读代码时,会不好跟踪造成 bug的原因。静态using语句使用须谨慎。个人倾向于不用,但选择权完全在你!
练习在 Point 类中添加一个私有静态字段。它初始化为9,在两个构造器中都要递增。还要写公共静态方法返回该字段的值(代表已创建的Point对象数量)。
写静态成员并调用静态方法
1.在VisualStudio2017的"代码和文本编辑器"窗口中显示 Point类。
2.在 Point类中添加int类型的私有静态字段 objectCount。声明时初始化为。
class Point
{
	...
	private static int objectCount = 0;
}
注意 prvate和static关键字顺序任意。不过，首选顺序是private static
3.在两个 Point 构造器中添加语句来递增 objectCount字段,如加粗的代码所示:
class Point
{
	private int x,xy;
	private static int objectCount = 0;

	public Point()
	{
		this.x = -1;
		this.y = -1;
		objectCount++;
	}
	public Point(int x, int y)
	{
		this.x = x;
		yhis.y = y;
		objectCount++;
	}
	...
}
每次创建对象都会调用构造器。只要在每个构造器(包括默认构造器)中递增,objectCount就能反映出迄今为止创建的对象总数。这个策略之所以奏效,是因为objectCount是共享的静态字段。如果objectCount是实例字段,则每个对象都有自己的 objectCount字段,会被设为1.
现在的问题是 Point类的用户如何知道创建了多少Point对象? objectCount是私有字段,不能在类外使用。下策是将objectCount变成公共字段。但这会破坏类的封装性,无法保证值是正确的,因为任何人都能改变该字段的值。上策是提供公共静态方法来返回objectCount字段值。这正是下面要做的工作
4.在Point类中添加公共静态方法 ObjectCount,返回int值但不获取任何参数。
在方法主体中返回 objectCount字段值,如以下加粗的代码所示。
class Point
{
	...
	public static int ObjectCount() => objectCount;
}
5.在"代码和文本编辑器"窗口中显示Program类,在doOMork方法中添加语句(如
以下加粗的代码所示)将 Point 类的ObjectCount方法返回值输出到屏幕。
static void doWork()
{
	Point origin = new Point();
	Point bottomRight = new Point(1366.768);
	double diatance = origin.distanceTo(bottomRight);
	Console.WriteLine($"Distance is : {distance}");
	Console.WriteLine($"Number of Point objects:{Point.ObjectCount}");
}
要用类名Point作为前缀来调用0bjectCount方法,而不要使用某个Point变量的名称(如 origin或 bottomRight)作为前缀。由于调用ObjectCount时已创建了两个 Point对象,所以方法应返回值2。
6.在"调试"菜单中选择"开始执行(不调试）"。
确认在控制台窗口中,在显示了距离值之后,显示的Point对象的数量是2。
7.按Enter键结束程序并返回Visual Studio。
7.5.5 匿名类
匿名类是没有名字的类。虽然听起来奇怪,但这种类有时相当好用。以后会讲到需要这种类的场合,尤其是在使用查询表达式的时候。目前只需知道它们有用。创建匿名类法是以new关键字开头,后跟一对{},在大括号中定义想在类中包含的字段和值,如下所示:
mAnonymousObject new { Name="John",Age a 47);
该类包含两个公共字段,名为Name(初始化为字符串"John")和Age(初始化为整数47),编译器根据用于初始化字段的数据类型推断字段类型。定义匿名类时,编译器为该类生成只有它自己知道的名称。这带来了一个有趣的问题:
既然不知道类名,如何创建正确类型的变量,并把类的实例分配给它?在上例中,myAnonymousObject变量的类型是什么?答案是根本不知道类型是什么——这正是匿名类的意义。但使用var关键字将myAnonymousObject声明为隐式类型的变量,问题就解决了,
如下所示:
var myAnonymousObject a new（Name ="John",Age = 54);
以前说过,如果使用 var关键字,对变量进行初始化的表达式是什么类型,编译器就用这个类型创建变量。在本例中,表达式的类型名称就是编译器自己为匿名类生成的名称。
可用熟悉的点记号法访问对象中的字段,如下所示
Console.writeLine($"Name:{(mAnonymousobject.Name]Age:{nyAnorymous0bject.Age)"};
甚至能创建匿名类的其他实例,在其中填充不同的值:
var anotherknonymousbject = new{ Name =" Dlana",Age= 53 };
C#编译器根据字段名称、类型、数量和顺序判断匿名类的两个实例是否具有相同类型。本例的变量myAnonymousObject和anotherAnonymousObject包含相同数量的字段,而且字段不仅名称和类型相同,顺序也相同,所以两个变量被认为是同一匿名类的实例。这意味着可以执行下面这样的赋值操作:
anotherAnonymousObject =myApnonymousObect；
注意 上述赋值语句的结果或许不是你想象的那样。
匿名类有时虽然好用,但内容存在着相当多的限制。例如,匿名类只能包含公共字段,字段必须全部初始化,不可以是静态,而且不能定义任何方法。

理解值和引用
理解值类型和引用类型的区别
使用关键字 ref和out修改方法实参的传递方式
通过装箱将值转换成引用
通过拆箱和转型(强制类型转换)将引用转换回值
复制值类型的变量和类

c#大多数基元类型(包括int,float,double和 char等,但不包括string,原因稍后解释)都是值类型。将变量声明为值类型,编译器会生成代码来分配足以容纳这种值的内存块。例如,声明int类型的变量会导致编译器分配4字节(32位)内存块。向 int变量赋值,将导致值被复制到内存块中。
类类型则以不同方式处理。声明Circle变量时,编译器不生成代码来分配足以容纳一个Circle 的内存块。相反,它唯一做的事情就是分配一小块内存,其中刚好可以容纳一个地址。以后,Circle 实际占用内存块的地址会填充到这里。
该地址称为对内存块的引用。Circle对象实际占用的内存是在使用new关键字创建对象时分配的。类是引用类型的一个例子。引用类型容纳对内存块的引用。为了写高效的C#程序来充分利用Microsoft.NET Framework,有必要理解值类型和引用类型的区别。
注意 c#的string实际是类类型。由于字符串大小不固定,所以更高效的策略是在程序运行时动态分配内存,而不是在编译时静态分配。本章对类这样的引用类型的描述同样适合string类型。事实上,C#的string关键字是System.String类的别名。
声明int变量i,将值42赋给它,再声明int变量copyi,将i赋给copyi,那么copyi将容纳与i相同的值(42)。虽然copyi和i容纳的值大小一样,但事实上已经有两个内存块,其中都包含值42:一个块为i分配,一个为copyi分配。修改i的值不会改变copyi的值。下面用代码进行演示:
int i-42;//声明并初始化i
Int copyi = i;/// copyi 包含i中的数据的拷贝,i和copyd都包含值42
i++; //i递增不响copy:1现在包含43,copyi仍然包含42
c 声明为类类型(比如Circle)的结果完全不同。将c声明为Circle,C就能引用Circle对象:c实际容纳的是内存中的一个Circle对象的地址。将变量refc也声明为Circle,将c赋给refc,refc将容纳和c一样的地址:换言之,现在只存在一个Circle对象,refc和c都引用它。下面用代码进行演示:
Circle c = new Circle(42);
Circle refc= c;
Circle对象中的符号@代表引用,容纳的是内存地址。
引用类型的复制与私有数据要将c引用的Circle对象的内容复制给 refc 引用的Circle对象,而不是复制引用,必须让refc引用Circle类的新实例,再将数据逐字段地从c复制到 refc.一种可能的写法如下:
Circle refc = new Circle();
refc,radius =c.rad1us;//不要这样做
但如果Circle类有任何成员是私有的(例如 radius 字段),就不能复制这个数据。私有字段应作为属性公开,再通过属性读取c的数据并复制给 refc.
另外,类可以提供Clone方法来返回自己的新实例,并填充相同的数据.Clone方法能访问对象的私有数据,并直接将数据复制到同一个类的另一个实例中,例如,Circle类的Clone方法可以这样定义:
class Circle
{
	private int radius; //省略了构造器和其他方法
	...
	public Circle Clone()
	{
		Circle clone = new Circle();
		clone.radius = this.radius;
		return clone;
	}

}
如果所有私有数据都是值类型,这个方式没有任何问题,但是,如果包含任何引用类型的字段(例如,可以扩展Circle类来包含上一章的Point对象,以指定圆心位置),这种引用类型也需要提供Clone方法,否则Circle类的Clone方法只是复制对这些字段的引用.只复制引用称为"浅拷贝",如果提供了Clone方法,能够复制引用的对象,就称为"深拷贝"。
上述代码还带来了一个有趣的问题:私有数据到底"私有"在哪里?前面说过,private关键字创建了不能从类外访问的字段或方法。但是,这并不是说它只能由单个对象访问。创建同一个类的两个对象,它们分别能访问对方的私有数据。这听起来很怪,但事实上Clone 这样的方法正是依赖于这个原理.clone.radius= this.radius;这样的语句之所以能够工作,正是因为可以从Circle类的当前实例中访问clone对象的私有radius字段所以,"私有"实际是指"在类的级别上私有",而非"在对象级别上私有".另外,私有和静态是两码事、字段声明为私有,类的每个实例都有一份自己的数据。声明为静态,每个实例都共享同一份数据。
用值参数和引用参数
1.如Microsoft Visual Studio 2017尚未启动,请启动。
2.打开 Parameters 解决方案,它位于"文档"文件夹的MicrosofPrss\VCSBS\Chapter 8\Parameters子文件。
项目包含三个C#代码文件,分别是Pass.cs,Program.cs和WmppedInt.cs
3.在"代码和文本编辑器"窗口中打开Passcs文件。该文件定义了Pass类。该类目前空白,只有一条//T000:注释。
提示 可以使用"任务列表"窗口定位解决方案中的所有T000注释。
4.在 Pass 类中添加名为Value 的公共静态方法,替换原来的//TO0:注释,如以下加粗的代码所示。该方法接收一个名为param的int 参数(一个值类型),返回类型是void。在Value的主体中,直接将值42赋给 param。
namespace Parameters
{
	class Pass
	{
		public static void Value (int param)
		{
			param = 42;
		}
	}
}
注意 方法定义为静态,目的是简化练习。这样可直接在 Pass类上调用Value方法,而不必先创建新的Pass对象。但是,本练习所阐述的原则同样适合实例方法。
5.在"代码和文本编辑器"窗口中打开Program.cs 文件,找到Program类的doWork方法。
程序开始运行时,dowork方法将由Main方法调用。该方法调用被封闭在一个try块中,try块之后是一个 catch 处理程序。
6	在doMork方法中添加4个语句,分别执行以下任务。
6.1 声明名为1的局部int 变量,初始化为0。
6.2 使用Console.MriteLine,将i的值输出到控制台。
6.3 调用Pass.Value方法,将i作为实参传递。
6.4 再次将i的值输出到控制台。
在调用Pass.Value前后调用Console.MriteLine,可以看出对 Pass.Value 的调用是否改变了i的值。完成后的doork方法应该像下面这样,新增语句加粗显示:
static void doWork()
{
	int i = 0;
	Console.WriteLine(i);
	Pass.Value(i);
	Console.WriteLine(i);
}
7．在"调试"菜单中选择"开始执行(不调试)",生成并运行程序。
8.确定值0在控制台窗口中输出了两次。  Pass.Value内部的赋值操作是用实参的拷贝来进行的,原始实参i完全未受影响。
9.按Enter键关闭应用程序。接着,让我们来看看传递包装在类中的int参数会是什么情况。    
10.在"代码和文本编辑器"窗口中打开WrappedIntcs文件。文件包含wrappedInt类。这是一个空白类,只有一条//TO00:注释。
11.在MrappedInt类中添加int类型的公共实例字段NMumber,如加粗的代码所示：
namespace Parameters
{
	class WrappedInt
	{
		public int Number;
	}
}
12.在"代码和文本编辑器"窗口中打开 Pass.cs 文件。在Pass 类中添加名为Reference的公共静态方法,接收一个名为 param的MrappedInt 参数,返回类型为 void。Reference方法的主体将42赋给param.Number,如下所示:
public static void Reference(WrappedInt param)
{
	param.Number =42;
}
13.在"代码和文本编辑器"窗口中打开 Program.cs 文件。在dowork方法中再添加4条语句来执行以下任务。
13.1 声明wrappedInt类型的局部变量wi,并通过调用默认构造器,把它初
始化为一个新的wrappedInt对象。
13.2 将wi.Number 的值输出到控制台。
13.3 调用 Pass.Reference方法,将wi作为实参来传递。
13.4 再次将wi.Number的值输出到控制台。
和前面一样,通过调用Console.writeLine,可以验证对 Pass.Reference的调用是否更改了wi.Number的值。现在的doMork方法应该像下面这样(新增语句加粗显示):
static void doWork()
{
	// int i= 0;
	//Console.WriteLine(i);
	//Pass.Value(i);
	//Console.WriteLine(i);
	WrappedIt wi = new WrappedInt();
	Console.WriteLine(wi.Number);
	Pass.Reference(wi);
	Console.WriteLine(wi.Number);
}
14.在"调试"菜单中选择"开始执行(不调试)",生成并运行程序。
这一次,控制台窗口显示的两个值对应于调用 Pass.Reference 方法前后的wi.Number值。请验证这两个值是和 42.
15.按Enter键关闭应用程序,返回Visual Studio 2017。
这个练习中,wi.Number被编译器生成的默认构造器初始化为0。wi变量包含对新建的 MrappedInt 对象(其中包含一个 int)的引用。然后,wi 变量作为实参传给Pass.Reference方法。由于MrappedInt是类(一个引用类型),所以w1和 param将引用同一个MrappedInt对象。在 Pass.Reference方法中,通过 param变量对对象的内容进行的任何改动都会在方法结束之后通过wi变量反映出来。

理解 null值和可空类型
变量应尽量在声明时初始化。对于值类型,下述代码可谓司空见惯:
int i = 0;
double d =0.0;
为了初始化引用类型（例如类）的变量，可以创建类的新实例，并新实例的引用赋给引用变量，如下所示：
Circle c = new Circle(42);
目前为止,一切都很完美。但是,如果并不想真的创建新对象又该怎么办呢?例如,或许只想用变量来存储对一个现有对象的引用。在下例中,Circle类型的变量 copy 先被初始化,但稍后又将对另一个Circle对象的引用赋给它。
Circle c = new Circle(42);
Circle coppy = new Circle(99);  //随便用一个值来初始化coppy
...
copy = c;     //copy和c引用同一个对象
将c赋给copy后，copy原来引用的Circle实例会发生什么事情？那个实例已经用半径值42进行了初始化。一旦将c赋给copy,copy就会引用c所引用的实例,copy原来引用的实例就"落单"了,现在不存在对它的任何引用。在这种情况下,"运行时"通过垃回收机制来回收内存。
就目前来说,只需知道垃圾回收是一个可能比较耗时的操作;不要创建从来不用的对象,否则只会浪费时间和资源。很多人会有疑问:反正变量在程序运行到某个地方时都会被赋值为对另一个对象的引用,提前初始化有什么意义?但请记住,不在声明时初始化,这是一个很不好的习惯,可能造成代码出问题。例如,迟早会遇到这样的情况:只有在变量不包含引用时才允许该变量引用一个对象,如下所示：
Circle = new Circle(42);
Circle coppy;
...
if (copy == //只有copy未初始化时才向copy赋值，但这里应该填什么？)
{
	copy = c;  //copy和c引用同一个对象
}
if语句测试copy变量，看它是否已初始化。但这个变量应该和哪个值进行比较能?答案是使用名为null的特殊值。
c#许将null值赋给任意引用变量。值为nul1的变量表明该变量不引用内存中的任何对象。所以上述代码的正确形式是：
Circle c = new Circle(42);
Circle copy = null;
...
if (copy ==null)
{
	copy = c:
	...
}
空条件操作符
可用空条件操作符更简洁地测试空值,使用它需为变量名附加问号(?)前缀,例如,以下代码在Circle对象为空时调用其 Area方法:
Circle c null;
Console.riteLine($"The area of circle c is {c.Area())");
这造成Circle.Area 方法抛出一个NullReferenceException.这很合理,因为无法计算不存在的一个圆的面积。为避免该异常,可先检测Circle对象是否为null,再决定是否调用其 Area方法:
if (c! = null)
{
	Console.WriteLine($"The area of circle c is {c,Area()}");
}
C为空，就不向命令提示符窗口写入任何内容。还可在尝试调用Circle.Area 方法前用空条件操作符判断c是否为空:
Console. writeLine($"The area of circle c is {c7.Area()");
c为空就不调用它的Area方法。在本例中,命令提示符窗口显示以下文本:
The area of circle c is
两种方式均有效,可满足不同情况下的需要。空条件操作符有利于保持代码简洁。以后为嵌套引用类型(可能都为空)处理复杂属性时,该操作符特别好用。
使用可空类型
null值在初始化引用类型时非常有用，但是null本身就是引用，不能把它赋给值类型，在c#中，以下语句是非法的：
int i = null;//合法
为了判断可空变量是否包含null，可采取和引用类型一样的测试办法：
if (i ==null)
...
可将恰当值类型的表达式直接赋给可空变量。以下例子全部合法：
int？ i = null；
int j = 99;
i = 100;   //将值类型的常量给可空变量
i = j;		//将值类型的常量给可空变量
反之则不然,不可将可空变量赋给普通值类型变量,所以基于上面对1和j的定义,以下语句非法:
j = i;;//非法
考虑到变量i可能包含nul1,而j是不能包含null的值类型,所以像这样处理是合理的。这还意味着如果一个方法希望接收的是一个普通值类型参数,就不能将一个可空变量作为实参传给它。例如在上个练习中,Pass.Value方法希望接收普通int参数,所以以下方法调用无法编译:
int? i =99;
Pass.Value(1);//编译错误
注意 不要混淆可空类型和空条件操作符。前者的问号加在类型名称后,后者加在变量名称后。
理解可空类型的属性
可空类型公开了两个属性,用于判断类型是否实际包含非空的值,以及该值是什么。其中,HasValue属性判断可空类型是包含一个值,还是包含nul1.如果包含值,可用Value属性获取该值。如下所示:
int? i = null;
...
if (!i.HasValue)
{
	//i为null,就将99赋给它
	i=99；
}
else
{
	//i不为null，就显示它的值
	Console.WriteLine（i.Value）;
}
NOT操作符（!)是对布尔值进行求反操作。以上代码段测试可空变量i,如果它不包含值(而是为nul1),就把值99赋给它;否则就显示变量的值。在这个例子中,和直接测试 null值相比,即if(1 == null),使用 HasValue属性并没有什么优势。此外,读取Value属性还不如直接读取i的值呢!不过,之所以有这些明显的缺陷,是由于int?属于那种十分简单的可空类型。以后完全可能创建更复杂的值类型,并用它们来声明
可空变量,届时就能体会到HasValue 和Value属性的优势了。可空类型的Value属性是只读的。可用该属性读取变量的值,但不能修改。
注意 要用普通的赋值语句。
使用 ref和 out 参数向传递实参时,对应的参数（形参)通常会用实参的拷贝来初始化——不管参数是值类型(例如int),可空类型(例如int?),还是引用类型(例如MrappedInt)。换言之,随便在方法内部进行什么修改,都不会影响作为参数传递的变量的原始值。例如在以下代码中,向控制台输出的值是42,而不是 43.doIncrement方法递增的只是实参(arg)的拷贝,原始实参不递增。
static void doIncrement(int param)
{
	param++;
}
static void Main()
{
	int arg = 42;
	doIcrement = 42;
	Console.WruteLine(arg);//输42，而不是43
}
通过前一个练习我们知道如果一个方法的参数(形参)是引用类型,那么使用那个参数来进行的任何修改都会改变传入的实参所引用的数据。这里的关键在于,虽然引用的数据发生了改变,但传入的实参没有变——它仍然引用同一个对象。换言之,虽然可以通过参数来修改实参引用的对象,但不可能修改实参本身(例如,无法让它引用不同的对象)。大多数时候,这个保证都非常重要,它有助于减少程序bug。但少数情况下,我们希望方法能实际地修改一个实参。为此,C#语言专门提供了ref和out关键字。

创建 ref 参数
为参数(形参)附加 ref 前缀,C#编译器将生成代码传递对实参的引用,而不是传递实参的拷贝。使用ref 参数,作用于参数的所有操作都会作用于原始实参,因为参数和实参引用同一个对象。作为ref 参数传递的实参也必须附加 ref 前缀。这个语法明确告知开发人员实参可能改变。下面是前一个例子的修改版本,这次使用了ref关键字:
static void doIncrement (ref int param)//使用了ref
{
	param++;
}
static void Main()
{
	int arg = 42;
	doIncrement(ref arg);  //传递实参数也要附加ref
	Console.WriteLine(arg);  //输出43
}
这一次,由于向 doIncrement方法传递的是对原始实参的引用而非拷贝,所以用这个引用进行的任何修改都会反映到原始实参中。因此,向控制台输出的是43."变量使用前必须赋值"规则同样适合方法实参。不能将未初始化的值作为实参传给方法,即便是 ref实参。例如,下例的arg没有初始化,所以代码无法编译。doIncrement方法中的 param+;语句相当于 arg+;,而只有当 arg有一个已定义的值的时候,arg+才是允许的。
static void doIncrement (ref int param)
{
	param++;
}
static void Main()
{
	int arg;
	doIncrement(ref arg);
	Console.WriteLine(arg);
}
创建 out 参数
编译器会在调用方法之前验证其 ref 参数已被赋值。但有时希望由方法本身初始化参数,所以希望向其传递未初始化的实参。这时要用到out关键字。out关键字的语法和 ref关键字相似。可为参数(形参)附加out前缀,使参数成为实参
的别名。和使用 ref一样,向参数应用的任何操作都会应用于实参。为 out 参数传递实参时,实参也必须附加 out关键字作为前缀。关键字out是output(输出)的简称。向方法传递out参数之后,必须在方法内部对其进行赋值,如下例所示：
static void doInitialize(out int param)
{
	param = 42;  //在方法中初始化param
}
下例则无法编译，因为doInitialize没有向param赋值：
static void doInitialize(out int param)
{
	//什么都不做
}
由于out 参数必须在方法中赋值,所以调用方法时不需要对实参进行初始化。例如,以下代码调用 doInitialize来初始化变量 arg,然后在控制台上输出它的值：
static void doInitialize(out int param)
{
	param = 42;
}
static void Main()
{
	int arg;//未初始化
	doInitialize(out arg); //初始化
	Console.WriteLine(arg);  //输出42
}
以下练习将进一步体验ref参数的运用。
用ref参费
1.返回Visual Studio 2017中的Parameters 项目。
2.在"代码和文本编辑器"窗口中打开Pass.cs 文件。
3.编辑Value方法,把它的参数变成一个 ref参数。
现在的Value方法应该像下面这样:
class pass
{
	public static void Value(ref int param)
	{
		param = 42;
	}
	...
}
4. "代码和文本编辑器"窗口中打开Program.cs 文件。
5.撤消对前4个语句的注释。注意,doork 方法第3个语句 Pass.Value(1);显示有错。这是因为Value方法现在要求 ref 参数。编辑该语句,在调用Pass.Value方法时传递 ref 实参。
注意 创建和测试MrappedInt对象的4个语句不要管。
现在doWork方法应该像下面这样：
class program
{
	static void doWork()
	{
		int i = 0;
		Console.WriteLine(i);
		Pass.Value(ref i);
		Console.WriteLine(i);
		...
	}
}
6.在 "调试"菜单中选择"开始执行(不调试)",生成并运行程序。
这一次,在控制台窗口中输出的前两个值将变成0和42,表明 Pass.Value方法调用修改了实参i.
按 Enter键关闭应用程序,返回Visual Studio2017。
注意 ref和out 修饰符除了能应用于值类型的参数,还能应用于引用类型的参数。效果完全一样。形参成为实参的别名。
计算机内存的组织方式
计算机使用内存来容纳要执行的程序以及这些程序使用的数据。为了理解值类型和引用类型的区别，有必要理解数据在内存中如何组织。操作系统和"运行时"通常将用于容纳数据的内存划分为两个独立区域,每个区域以不同方式管理。这两个区域通常称为栈(stack)堆(heap)。栈和堆的设计目标完全不同。调用方法时,它的参数和局部变量所需的内存总是从栈中获取、方法结束后(不管正常返回还是抛出异常),为参数和局部变量分配的内存都自动归还给栈,并可在
另一个方法调用时重新使用。栈上的方法参数和局部变量具有良好定义的生存期。方法开始时进入生存期,结束时结束生存期。
注意 实际上,这个生存期规则适合任何代码块中定义的变量。下例的变量i在while循环主体开始时创建,循环结束时消失
while(..)
{
	int i =...;//这时i在栈上创建
}
//这时i就从栈中消失了
使用new关键字创建对象(类的实例)时,构造对象所需的内存总是从堆中获取。前面讲过,使用引用变量,可从多个地方引用同一个对象。对象最后一个引用消失之后,对象占用的内存就可供重用(虽然不一定立即回收)堆上创建的对象具有较不确定的生存期;使用new关键字将创建对象,但只有在删除了最后一个对象引用之后的某个不确定时刻,它才会真正消失。
注意 所有值类型都在栈上创建,所有引用类型的实例(对象)都在堆上创建(虽然引用本身还是在栈上)。可空类型实际是引用类型,所以在堆上创建。

"栈"和"堆"这两个词来源于"运行时"的内存管理方式。
栈(Stack)内存就像一系列堆得越来越高的箱子。调用方法时,它的每个参数都被放入一个箱子并放到栈顶。每个局部变量也同样分配到一个箱子,并同样放到栈顶。方法结束后,它的所有箱子都从栈中移除。
堆(Heap)内存则像散布在房间里的一大堆箱子,不像栈那样每个箱子都严格堆在另一个箱子上。每个箱子都有一个标签,标记了这个箱子是否正在使用。创建新对象时,"运行时"查找空箱子,把它分配给对象。对对象的引用则存储在栈上
的一个局部变量中。"运行时"跟踪每个箱子的引用数量(记住,两个变量可能引用同一个对象）。一旦最后一个引用消失，运行时就将箱子标记为"未使用"。将来某个时候，会清除箱子里的东西，使之能被重用。
使用栈和堆
思考调用以下方法会发生什么：
void Method(int param)
{
	Circle c;
	c = new Circle(param);
	...
}
假定传给 param的值是42.调用方法时,栈中将分配一小块内存(刚够存储一个int),并用值42初始化。在方法内部,还要从栈中分配出另一小块内存,它刚够存储一个引用(一个内存地址),只是暂不初始化。这是为Circle类型的变量c准备的。接着,要从堆中分配一个足够大的内存区域来容纳一个Circle对象。这正是new关键字所执行的操作:它运行Circle构造器,将该原始堆内存转换成Circle对象。对该Circle 对象的引用将存储到变量c中。
注意以下两点。
虽然对象本身存储在堆中,但对象引用(变量 c)存储在栈中。堆内存是有限的资源。堆内存耗尽,new操作符抛出OutOfMemoryException,对象创建失败。
注意 Circle构造器也可能抛出异常,在这种情况下,分配给Circle对象的内存会被回收,构造器返回null值.
方法结束后,参数和局部变量离开作用域。为c和 param分配的内存被自动回收到栈。"运行时"发现已不存在对Circle对象的引用,所以会在将来某个时候,安排垃圾回收器回收其内存System.0bject类
.NET Framework最重要的引用类型之一是System命名空间中的Object类。要完全理解 System.0bject类的重要性,首先需理解继承。目前请无脑接受以下两点:所有类都是System.0bject 的派生类,而且System.0bject类型的变量能引用任何对象。由于 System.0bject相当重要,所以C#提供了object关键字来作为System.0bject的别名。实际写代码时,既可写object,也可写System.0bject,两者没有区别。
提示 优先使用 object关键字而不是 System.0bject。前者更直接,而且与其他类的别名更一致（例如,string是System.String的别名)。下例的变量c和o 引用同一个 Circle 对象。c 的类型是 Circle,o的类型是
object(System.0bject 的别名),它们从不同角度观察内存中的同一个东西:
Circle c;
c = new Circle(42);
object o;
o= c;

装 箱
object 类型的变量能引用任何引用类型的任何对象。此外,object 类型的变量也能引用值类型的实例。例如,以下两个语句将int 类型(一个值类型)的变量i初始化为42,并将object类型(一个引用类型)的变量o初始化为i:
int i=42;
object o= i;
执行第二个语句所发生的事情需要仔细思考一下。1是值类型,所以它在栈中。如果o直接引用i,那么引用的将是栈。然而,所有引用都必须引用堆上的对象:引用栈上的数据项,会严重损害"运行时"的健壮性,并造成潜在的安全漏洞,所以是不允许的。实际发生的事情是"运行时"在堆中分配一小块内存,然后i的值被复制到这块内存中,最后让o引用该拷贝。这种将数据项从栈自动复制到堆的行为称为装箱。
重要提示 修改变量i的原始值,o所引用的堆上的值不变。类似地,修改堆上的值,变量的原始值也不变。

拆 箱
由于object类型的变量可引用值的已装箱拷贝,所以通过该变量也应该能获取装箱的值。你或许以为使用简单的赋值语句就能访问变量o引用的已装箱int值:
int i = 0;
但这样写会发生编译时错误,稍微想一想就知道上述语法不正确,因为o 可能引用任何东西,而非只能引用一个int。如上述语法合法,那么以下代码会发生什么？
Circle c- new Circle();
Int i=42;
object o;
o=c;//o引用一个圆
i= o;//1应存储什么?
为了访问已装箱的值,必须进行强制类型转换,简称转型。这个操作会先检查是否能将一种类型安全转换成另一种类型,然后才执行转换。为了进行转型,要在 object 变量前添加一对圆括号,并输入类型名称,如下例所：
inti-42;
object o = i; //装箱
i = (int)o; /成功编译
转型的过程需稍微解释一下。编译器发现指定了类型int,所以会在运行时生成代码检查o实际引用什么。它可能引用任何东西。不能因为你在转型时说o引用的是int,它就真的引用一个int。如o真的引用一个已装箱int,转型成功执行,编译器生成的代码会从装箱的int 中提取出值(本例是将装箱的值再存回1）。该过程称为拆箱。
然而,如果o引用的不是已装箱的int,就会出现类型不匹配的情况,造成转型失败。编译器生成的代码将在运行时抛出InvalidCasLException。下面是拆箱失败的例了:
Circle c = new Circle(42);
object o =c; //不装箱,因为c是引用类型的变量,而不是值类型的变量
int i = (int)o; //编译成功,但在运行时抛出异常
以后的练习将使用装箱和拆箱。注意,这两种操作都会产生较大的开销,因为它们涉及不少检查工作,而且需要分配额外的堆内存。装箱有一定用处,但滥用会严重影响性能。
数据的安全转型强制类型转换是"一厢情愿"指定对象引用的数据具有某种类型,而且可用那种类型"安全地"引用对象。这里的关键词是"一厢情愿"。C#编译器生成应用程序时只能选择相信你的判断。但"运行时"对此报怀疑态度,并通过检查加以确认。如内存中的对象的类型与指定类型不匹配,"运行时"将抛出InvalidCastException异常。
编写应用程序时,应考虑捕捉这种异常,并在发生时进行相应的处理。但是,在对象类型不符合预期的情况下捕捉异常并试图恢复应用程序的顺利执行,这是一个相当繁琐的过程。C#语言提供了两个相当有用的操作符,能以更得体的方式执行转型,这就是is操作符和as操作符。

is 操作符
用is操作符验证对象的类型是不是自己希望的,如下所示:
Wrapped wi = new WrappedInt();
...
object o = wi;
if (o is WrappedInt){
	whrappedInt temp ·(whrappedInt)o;//转型是安全的:o确定是一个wrappedInt
	...
}
is操作符取两个操作数:左边是对象引用,右边是类型名称。如左边的对象是(is)右边的类型,则is 表达式的求值结果为 true,反之为 false。换言之,上述代码只有确定转型能成功,才真的将引用变量 o转型为wrappedInt。
as 操作符as操作符充当了和is 操作符类似的角色,只是功能稍微进行了删减。可以像下面这样使用 as 操作符:
WrappedInt wi. = new wrappedInt();
...
objecto = wi;
WhrappedInt temp = o as wrappedInt;
if(temp！= nul1)
{
	...//只有转型成功,这里的代到才会执行
}
和is操作符一样,as操作符取对象和类型作为左右操作数。"运行时"尝试将对象转换成指定类型。若转换成功,就返回转换成功的结果。在本例中,这个结果被赋给wrappedInt类型的变量temp。相反,若转换失败,as表达式的求值结果为null,这个值也会被赋给temp。
复习switch语句
如需检查几个类型的引用,可用一系列if...else语句加is操作符的组合。下例假定已定义Circle,Square和Trlangle类。构造器获取半径或其他几何图形的边长作为参数。
Circle c = new Circle(42); //半径42的圆
Square s=new Square(55); //边长55的正方形
Triangle t = new Triangle(33)3;)/;//边长33的等边三角形
...
object o =s;
...
if(o is Circle myCircle)
{
	...//o是Circle,myCircle中存在一个引用
else if(o is Square mySquare)
{
	...//o是Square,mySquare 中存在一个引用
}
else if(o is Triangle myTriangle)
	...//o是Triangle,myTriangle 中存在一个引用
和任何冗长的系列if.else语句一样,这样写既麻烦,又不好阅读。幸好可用switch语句简化。
switch (o)
{
	case Circle myCircle:
		...//0是Circle,myircle 中存在一个引用
		break;
	case Square my5quare:
	...//0是Square,mySquare中存在一个引用
	break;
	case Triangle myTriangle:
	...//0是Triangle,myTriangle 中存在一个引用
	break;
	default:
		throw new ArgumentException("变量不是可识别的几何图形");
		break;
}
注意两个例子中创建的变量(myCircle,mySquare 和myTriangle)的作用域都限于对应的if 块或 case 块。
注意,switch 语句中的case选择符还支持when表达式,进一步限制选择该case的前提条件。例如,以下 switch 语句对几何图形的大小进行了限制。
switch(0)
{
	case Circle myCircle when my Circle.Radius >10:
		...
		break;

	case Square mySquare when mySquare.SideLength == 100:
		...
		break;
}
指针和不安全的代码
本补充内容仅供参考,针对的是已热悉C或C→+的开发者.编程新手可跳过。
如果熟悉C或C+这样的开发语言,那么前面有关对象引用的讨论听起来应该是比较耳熟的,虽然C和C++都没有提供显式的引用美型,但两种语言都通过一个特殊的构造提供了类似的功能,这个构造就是指针.
指针是特殊变量,其中容纳着内存(堆或栈)中的一个数据项的地址(或者说对这个数据的引用).要用特殊语法将变量声明为指针。例如,以下语句将变量 pi 声明为能指向一个整数的指针:
int *pi;
虽然变量pi声明为指针,但除非对它进行了初始化,否则不会指向任何地方.例如,
可以使用以下语句让pi指向整数变量i,取址操作符&返回变量的地址:
int *tp1;
int i = 99;
...
p1 =&i;
可通过指针变量pi来访问和修改变量i中容纳的值:
*pi - 100;
上述代码将变量i的值更新为100,因为pi指向变量i的内存位置。
学习c和C++语言时,指针语法是一个重要主题,操作符*至少有两个含义(另一个含义是乘法操作符),而且很多人都不清楚什么时候应该使用&,什么时候应该使用*.指针的另一个问题是很容易指向无效的位置,或者根本就忘记了让它指向一个位置,然后企图引用指向的数据。结果要么是垃圾数据,要么是程序出错,因为操作系统检测到程序企图访问内存中的一个非法地址,在当前许多操作系统中,还存在大量因为指针管理不当而引起的安全缺陷;有的环境(Microsoft Windows 不包括在内)不会强制检查一个指针是否指向从属于另一个进程的内存,这可能造成机密数据失窃。
C#通过添加引用变量来一劳永逸地解决了这些问题.如果愿意,可以在C#中继续使用指针,但必须将代码标记为unsafe(不安全)unsafe关健字可标记代码块或整个方法,如下所示
public static void Main(string [] args）
{
	int x= 99,y = 100;
	unsafe
	{
		swap (&x,&y);
	}
	Console.WriteLine($"x is now {x},y is now {y}");
}
public static unsafe void swap(int *a,int *b)
{
	int temp;
	temp = *a;
	*a = *b;
	*b = temp;
}
编译包含 unsafe代码的程序时,必须在生成项目时指定"允许不安全代码"选项,做在解决方案资源管理器中右击项目名称,选择"属性",在属性窗口中单击"生成"标签,选择"允许不安全代码",选择"文件" "全部保存"。
unsafe代码还关系到内存的管理方式;unsafe代码中创建的对象被称为"非托管"对象.虽然不常见,但偶尔也需要以这种方式访问内存,尤其是在执行一些低级Windows操作时。

使用枚举和结构创建值类型
声明枚举类型
创建并使用枚举类型
声明结构类型
创建并使用结构类型
解释结构和类在行为上的差异

c#支持两种值类型:枚举和结构。
假定要在程序中表示一年四季。可用整数0,1,2和3分别表示Spring(春)、Summer(夏)、Fall(秋)和Winter(冬)。虽然可行,但不直观。如代码中已使用了整数值0,那么经常搞不清楚一个特定的0是否代表Spring。另外,这也不是一种十分可靠的方案。例如,假定声明了名为season的int变量,那么除了O,1,2和3,其他任何合法的整数值都可以赋给
它。C#提供了更好的方案。可以使用 enum关键字创建枚举类型,限制其值只能是一组符号名称。

声明枚举
定义枚举要先写一个enum 关键字,后跟一对{},然后在{}内添加一组符号,这些符号标识了该枚举类型可以拥有的合法的值。下例展示了如何声明 Season枚举,其字面值限定于Spring,Summer,Fall和Winter这4个符号名称:
enum Season {Spring,Summer,Fall,Winter}
使用枚举
声明好枚举后,可像使用其他任何类型那样使用。假定枚举名称是Season,那么可以创建 Season类型的变量、字段和方法参数,如下例所示：
enum Season {Spring,Summer,Fall,Winter}
class Example
{
	public void Method(Season parameter) //方法参数
	{
		Season localVariable;//局部变量
		...
	}
	private Season currentSeason;	//字段
}
举类型的变量只有在赋值之后才能使用。只能将枚举类型定义好的值赋给该类型的变量。例如:
Season colorful = Season.Fall;
Console.hriteLine(colorful);//输出"Fall"
注意 和所有值类型一样,可用修饰符?创建可空枚举变量,这样一来,除了能把枚举类型定义的值赋给这个变量,还可以把null值赋给它,例如:
Season? colorful = null;
注意必须写 Season.Fall,不能单独写一个Fal1。每个枚举定义的字面值名称都只有该枚举类型的作用域。这是一个很有必要的设计,它使不同枚举类型可包含同名字面值。
还要注意,使用Console.MriteLine显示枚举变量时,编译器会自动生成代码,输出和变量值匹配的字符串。如有必要,可调用所有枚举都有的 ToString 方法,显式将枚举
变量转换成代表其当前值的字符串。例如:
string name = colorful.ToString();
Console.writeLine(name);//也输出"Fall"
适合整数变量的许多标准操作符也适合枚举变量。唯一例外的是按位(bitwise)和移位(shift)操作符。例如,可以使用操作符=比较同类型的两个枚举变量,甚至可以对枚举变量执行算术运算(虽然结果不一定有意义)。
选择枚举字面值
枚举内部的每个元素都关联(对应)一个整数值。默认第一个元素对应整数0,以后每个元素对应的整数都递增1.可将枚举变量转型为基础类型,然后获取其基础整数值。将数据从一种类型转换为另一种类型,只要转换结果是有效的、有意
义的,转型就会成功。例如,下例在控制台上输出值2,而不是单词Fal1(Spring对应O,
Summer对应1,Fall对应2,Winter对应3):
enum Season(Sprlng, Sumer, Fall, winter}
...
Season colorful Season.Fall;
Console.WriteLine((int)colorful); //输出2
如果愿意,可将特定整数常量（例如 1)和枚举类型的字面值(例如 Spring)手动关联起来,如下例所示:
enum Season { Spring = 1, Summer,Fall, Minter }
重要提示 用于初始化枚举字面值的整数值必须是编译时能确定的常量值(例如1)。不为枚举的字面值显式指定常量整数值,编译器自动为它指定比前一个枚举字面值大1的值(第一个字面值除外,编译器为它指定默认值0)。所以在上例中,Spring,Summer,Fall和 winter的基础值将变成1,2,3和4。
多个枚举字面值可具有相同的基础值。例如英国的秋天是Autumn 而不是Fall。为了适应两个国家的语言文化,可声明以下枚举类型:
enum Season { Spring, Sumer,Fall, Autum = Fall,Mnter }

选择枚举的基础类型
声明枚举时,枚举字面值默认是int 类型。但是,也可让枚举类型基于不同的基础整型。例如,为了声明 Season的基础类型是short 而不是int,可以像下面这样写：
enum Season:short{Spring, Sumrer,Fall,Mnter }这样做的主要目的是节省内存。int占用内存比short大；如果不需要int那么大的取值范围,就可考虑使用较小的整型。
枚举可基于8种整型的任何一种:byte,sbyte,short,ushort,int,uint,long或者 ulong。枚举的所有字面值都不能超出所选基础类型的范围。例如,假定枚举基于 byte数据类型,那么最多只能容纳256个字面值(从0开始)。
知道如何创建枚举类型之后,下一步就是使用。以下练习在控制台应用程序中声明并使用枚举来表示一年中的月份。
创建并使用枚举
1.如Microsoft Visual Studio 2017尚未启动,请启动。
2. 打开StructsAndEnums解决方案,它位于"文档"文件夹下的\Microsoft
Press\VCSBS\Chapter 9\StructsAndEnums 子文件夹。
3.在"代码和文本编辑器"窗口中打开 Month.cs 源代码文件。
文件包含一个名为StructsAndEnums的空命名空间和//TO00:注释。
4.删除//TOD0:注释,在 StructsAndEnums 命名空间中添加名为Month 的枚举（如粗的代码所示),用于对一年中的各个月份进行建模。Month的12个枚举字面值从January(一月)到 December(十二月)。
namespace StructsAndEnums
{
	enum Month
	{
		January,February,Narch,Apr1l,
		May,June,July,August, 
		September,October,November,December
	}
}
5.在"代码和文本编辑器"窗口中打开 Program.cs 源代码文件。Main方法调用dowork方法并捕捉可能发生的异常。
6. 在 doWork 方法中添加语句来声明 Nonth 类型的变量 first,初始化为Month.January。再添加语句将first变量的值输出到控制台。
现在的 dowork方法应该像下面这样:
static void doWork
{
	Month.first =  Month.January;
	Console.WriteLine(first);
}
注意 输入Month后再输入一个句点,"智能感知"自动列出Nonth枚举中的所有值。
7.在"调试"菜单中选择"开始执行(不调试)"。
Visual Studio 2017开始生成并运行应用程序。确定在控制台中输出了单词 "January"。
8.按Enter键关闭程序,返回Visual Studio 2017。
9.再在dowork方法中添加两个语句,使first变量递增1,在控制台中输出新值。 如加粗的代码所示:
static vold dobork()
{
	Month first = Month.January;
	Console.writeline(first); 
	first++;
	Console.writeLine(first);
}
10.在"调试"菜单中,选择"开始执行(不调试)"。
Visual Studio 2017开始生成并运行应用程序。确定控制台输出单词"January"和"February"。
注意,对枚举变量执行数学运算(如递增),会改变这个变量的内部整数值。输出该变量时,会输出对应的枚举值。
11.按 Enter键关闭程序,返回Visual Studio2017。
12.修改doWork方法的第一个语句,将first变量初始化为Month.December。如以
下加粗的代码所示:
static vold doWork()
{
	Month first = Month.December;
	Console.WriteLine(first);
	first++;
	Console.WriteLine(first);
}
13.在"调试"菜单中选择"开始执行(不调试)"。
虽然可以对枚举值执行数学运算,但如果运算结果溢出枚举定义的取值范围,"运行时"只能将变量的值解释成对应的整数值。
14.按Enter键关闭程序,返回Visual Studio 2017。
使 用 结 构
类定义的是引用类型,总是在堆上创建。有时类只包含极少数据,因为管理堆而产生的开销不合算。这时更好的做法是将类型定义成结构。结构是值类型,在栈上存储,能有效减少内存管理的开销(当然前提是该结构足够小)。
结构可包含自己的字段、方法和构造器(但不能主动声明默认构造器)。
用结构类型
在 C#语言中,基元数值类型
int,long和float分别是System.Int32,System.Int64和System.Single这三个结构的别名.这些结构有自己的字段和方法,可直接为这些类型的变量和字面值调用方法。例如,所有这些结构都提供了ToString方法,能将数值转换成对应的字符串形式.以下语句在 C#中都是合法的:
int1 55;
Console.MriteLine(i.ToString())；
Console.MriteLine(55.ToString());
float f= 98.765F;
Console.writeLine(f.TosString());
Console.writeLine(98.765F.ToString()); Console.MriteLine((590,600).ToString());//(500,690)是常量元组
像这样使用ToString 方法很罕见,因为Console.MriteLine方法会在需要的时候自动调用它.更常见的是使用这些结构提供的静态方法,,例如曾用静态方法int.Parse 将字符串转换成对应的整数值．在这种情况下,实际是调用了 Int32 结构的Parse方法:
string s="42";
int i = int.Parse(s);//完全等同于Int32.Parse
这些结构还包含一些有用的静态字段。例如,Int32.MaxValue对应的是一个int能容
纳的最大值,Int32.Minvalue则是int能容纳的最小值。
下面总结了C#基元类型及其在Microsoft.NETFramework中对应的类型.注意,string
和 object类型是类(引用类型)而不是结构。
关键字 				等价的类型 				类还是结构
bool 				System.Boolean 				结构
byte 				System.Byte 				结构
decimal 			System.Decimal 				组a
double 				System.Double 				结构
float 				System.Single 				结构
int 				System.Int32 				结构
long 				System.Int64 				结构
object 				System.Object 				类
sbyte 				System.SByte  				结构
short 				System.Int16 				结构
string 				System.String 				类
uint 				System.UInt32 				结构
ulong 				System.UInt64 				结构
ushort 				System.UInt16				结构
声明结构
声明结构要以struct关键字开头,后跟类型名称,最后是大括号中的结构主体。语法
上和声明类一样。例如,下面是一个名为Time的结构,其中包含三个公共int 字段,分别是 hours,minutes和 seconds:
struct Time
{
	public int hours,minutes,seconds;
}
和类一样,大多数时候都不要在结构中声明公共字段,因为无法控制它的值。例如,
任何人都能将minutes(分)或 seconds(秒)设为大于60的值。更好的做法是使用私有字段,
并为结构添加构造器和方法来初始化和处理这些字段。如下例所示:
struct Time
{
	private int hours,minutes,seconds;
	...
	public Time(int hh,int mm,int ss)
	{
		this.hours = hh % 24;
		this.minutes = mm % 60;
		this。seconds = ss % 60;
	}
	public int Hours()
	{
		return this.hours;
	}
}
注意 许多常用操作符都不能自动应用于自定义结构类型,例如,m=和l=操作符就不能自动应用于你定义的结构变量。但可使用所有结构都公开的 Equals()方法来比较,还可为自己的结构类型显式声明并实现操作符。
复制值类型的变量将获得值的两个拷贝。相反,复制引用类型的变量,将获得对同一个对象的两个引用。总之,对于简单的、比较小的数据值,如复制值的效率等同于或基本等同于复制地址的效率,就使用结构。但是,较复杂的数据就要考虑使用类。这样就可选择只复制数据的地址,从而提高代码的执行效率。
提示 如果一个概念的重点在干值而非功能,就用结构来实现。
理解结构和类的区别
结构和类在语法上极其相似,但两者也存在一些重要区别,具体如下。不能为结构声明默认构造器（无参构造器)。在下面的例子中,如果将Time换成一个类,就能编译成功。但由于Time是结构,所以无法编译:
struct Time
{
	public Time() {...} //编译时错误
}
所以不能为结构声明自己的默认构造器,是因为编译器始终都会自动生成一个。而在类中,只有在没有自己写构造器的时候,编译器才会自动生成一个默认的。编译器为结构生成的默认构造器总是将字段置为0,false或null,这和类一样。所以,要保证由默认构造器创建的结构值具有符合逻辑的行为,而且这些默认值是有意义的。
如果不想使用这些默认值,还可提供一个非默认的构造器,用它将字段初始化成不同的值。然而,自己写的构造器必须显式初始化所有字段,否则会发生编译错误。例如,假定 Time是类,那么下例能通过编译,而且seconds会被悄悄地初始
化为0。但由于Time是结构,所以无法编译:
truct Time
{
	private int hours,minutes,seconds;
	...
	public Tme(int h,int mm)
	{
		this.hours hh; 
		this.minutes = mm;
	}//编译时错误:seconds未初始化
}
类的实例字段可在声明时初始化,但结构不允许。例如,假定 Time 是类,下面的例子是可以编译的。但由于Time是结构,所以会造成编译时错误(结构中不能有实例字段初始值设定项)：
struct Time
{
	private int hours = 0; //编译时错误
	private int minutes;
	private int seconds;
	...
}
下表总结了结构和类的主要区别。

声明结构变量
定义好结构类型之后,可像使用其他任何类型那样使用它们。例如,如定义了名为Time的结构,就可创建Time类型的变量、字段和参数。如下例所示;
struct Time
{
	private int hours,minutes,seconds;
	...
}
class Example
{
	private void currentTime;
	public void Method(Time parameter)
	{
		Tiem localVariable;
	}
}
注意 和枚举一样,可用?修饰符创建结构变量的可空版本.然后可把null值赋给变量。
Time? currentTIme = null;
理解结构的初始化
前面讨论了如何使用构造器来初始化结构中的字段。调用构造器,前面描述的规则将保证结构中的所有字段都得到初始化:
Time now=new Time();
创建并使用结构类型
1.在 StructsAndEnums 项目中,在"代码和文本编辑器"窗口中打开 Date.cs 文件。
2.删除TODO注释,在StructsAndEnums 命名空间添加 Date结构。
结构包含三个私有字段:一个是 year,类型为int;一个是month,类型为Month;另一个是 day,类型为int。下面是Date结构:
struct Date
{
	private int year;
	private Month month;
	private int day;
}
现在考虑一下编译器为Date结构生成的默认构造器。该构造器将 year初始化为0,将month初始化为0(January的值),将 day初始化为0。year为0无效(没有为的年份),day为0也无效(每个月都从1号开始)。为了解决这个问题,一个
办法是实现Date结构,对 year和 day值进行转换,当 year字段在容纳值Y的时候,该值代表Y＋1900年(也可选择其他世纪);当 day字段容纳值D的时候,该值代表D＋1日。这样一来,默认构造器就会设置3个字段来代表1900年1月
1日。
如果能用自己的默认构造器覆盖自动生成的就好了,因为这样可直接将 year 和day 字段初始化成有效值。但由于结构不允许,所以只能在结构中实现逻辑,将编译器生成的默认值转换成有意义的值。
虽然不能重写默认构造器,但好的实践是定义非默认构造器,允许用户将结构中的字段显式初始化成有意义的、非默认的值。
3.在Date结构中添加一个公共构造器。该构造器应获取3个参数:一个是名为ccyy的int参数,代表年;一个是名为mm的Month参数,代表月:一个是名为dd的int参数,代表日。用这3个参数初始化相应的字段。值为Y的 year字段代表Y＋
1900年,所以需要将 year字段初始化成值ccyy-1900;值为D的day字段代表D＋1日,所以需要将 day 字段初始化成值dd-1.现在的 Date结构应该像 下面这样(构造器加粗显示）：
struct Date
{
	private int year;
	private Month month;
	private int day;

	public Date(int ccyy, Month mm, int dd)
	{
		this.year = ccyy =1900;
		this.month = mm;
		this .day = dd -1;
	}
}
4.在构造器之后,为 Date结构添加名为ToString的公共方法。该方法无参,返回日期的字符串形式。记住,year字段的值代表 year＋1900年,day 字段的值则代表day＋1日。
注意 ToString方法和前面所见过的其他方法有所区别。每种类型(包括自定义结构和类)都自动拥有一个ToString方法——不管是否需要,它的默认行为是将变量中的数据转换成字符串形式,这种默认行为有些时候合适,但也有一些时候意义不大,例如,为Date结构生成的ToString方法的默认行为是生成字符串"StructsAndEnums.Date"。
ToString方法应该像下面这样:
struct Date
{
	...
	public override string Tostring()
	{
	string data= $"{this.month}{this.day ＋1}{this.year＋1900}";
	return data;
	}
}
方法计算month字段、表达式 this.day＋1和表达式this.year ＋1900的值,用这些值的文本形式来生成一个格式化好的字符串并返回。
5.在"代码和文本编辑器"窗口中打开Program.cs 源代码文件。
6.将doWork方法现有的4个语句变成注释(选定后按CtrL+E,C或者从"编辑"|"高级"菜单中选择）。
7.在doWork方法中添加代码来声明局部变量 defaultDate,把它初始化为使用默认Date 构造器来构造的 Date 值。在 dowork 中添加另一个语句,调用Console.MriteLine将 defaultDate输出到控制台。
注意 Console.MriteLine方法自动调用实参的 ToString 方法,将实参格式化为字符串。
现在的dowork方法应该像下面这样:
static vold doWork()
{
	...
	Date defaultDate = new Date();
	Console.WriteLine(defaultDate);
}
注意 健入new Date后,"智能感知"自动检测到Date类型有两个构造器。
8. 在"调试"菜单中选择"开始执行(不调试)",开始生成并运行程序。确定控制台上输出的日期是January 1 1900。
9. 按 Enter键返回Visual Studio 2017。
10.在""代码和文本编辑器"窗口中,返回刚才的doWork方法,再在其中添加两个语句。第一个语句声明局部变量 weddingAnniversary(结婚纪念日),把它初始化成July42015。第二个语句将weddingAnniversary的值输出到控制台。
现在的 dowork方法应该像下面这样:
static void doiork()
{
	...
	Date weddingAmniversary = new Date(2015,onth.July,4);
	Console.writeline(weddinghrnniversary);
}
11.在"调试"菜单中选择"开始执行(不调试)",开始生成并运行程序。确定控制台上最后输出的是July 4 2015。
12.按 Enter键关闭程序并返回VisualStudio 2017.

复制结构变量
可将结构变量初始化或赋值为另一个结构变量,前提是赋值操作符=右侧的结构变量已
完全初始化(换言之,所有字段都用有效数据填充,而不是包含未定义的值)。例如,下例能成功编译,因为 now已完全初始化。
Date now = new Date(2012,Nonth.March,19);
Date copy = now;
下例则无法通过编译,因为 now没有被初始化:
Date now;
Date copy = now;//编译时错误: now未赋值
复制结构变量时,=操作符左侧的结构变量的每个字段都直接从右侧结构变量的对应字段复制。这是一个简单的复制过程,它对整个结构的内容进行复制,而且绝不会抛出异常。而如果Time是类,两个变量(now和copy)将引用堆上的同一个对象。
注意 C++程序员注意,这种复制行为是不可自定义的(人无法干预)。
比较结构和类的行为
1.在StructsAndEnums 项目中,在"代码和文本编辑器"窗口中显示 Date.cs 文件。
2.在Date结构中添加以下加粗的方法。该方法使结构中的日期增加1个月。如果在增加1个月之后,month字段的值超过了December(12月),代码将month重置为January(1月),并将 year字段的值递增1。
struct Date
{
	...
	public void Advanceonth()
	{
		this.month++;
		if (this.month == Month.December + 1)
		{
			this.month = Month.January;
			this.year++;
		}
	}
}
3.在"代码和文本编辑器"窗口中显示 Programcs 文件。
4.在dowork方法中,将前两个创建和显示 defaultDate变量的语句变成注释。
5. 将以下加粗的代码添加到doWork方法末尾。这些代码创建 weddingAnniversary变量的拷贝,命名为weddingAnniversaryCopy,并打印新变量的值。
static vold doWork()
{
	...
	Date weddingAnniversaryCopy = weddingAnniversary;
	Console.WriteLine($"Value of copy is(weddinghanniversaryCopy)");
}
6.将以下加粗的语句添加到 doWork 方法末尾,调用 weddingAnniversary 变量的AdvanceMonth方法,再显示 weddingAnniversary和 weddingAnniversaryCopy变量的值:
static vold doWork()
{
	...
	weddingAnniversary. Advanceonth();
	Console.writeLine($"new Value of wedtigimniversary is (weddingimiversary)"");
	Console.writeLine($"value of copy is still (weddingarniversarycopy)");
}
7.在"调试"菜单中选择"开始执行(不调试)"来生成并运行应用程序。验证控制台窗口显示以下消息:
July 4 2015
Value of copy is uly 4 2015
New value of weddingAnniversary is August 4 2015
Value of copy is still July 4 2015
第一条消息显示weddingAnniversary变量初始值(July 4 2015)。第二条消息显示 weddingAnniversaryCopy变量值。可以看到,它包含和 weddingAnniversary变量一样的日期(July 4 2015)。第三条消息显示将weddingAnniversary变量的月份增加1月,变成 August 4 2015之后的值。最后一条消息显示weddingAnniversaryCopy变量值,它没有变,仍然是July 4 2015。
如果Date是类,创建的拷贝引用的还是原始的实例。更改原始实例中的月份,拷贝引用的日期也会变。下面对此进行验证。
8.按 Enter键返回Visual Studio 2017
9.在"代码和文本编辑器"窗口中显示Datecs 文件。
10.将Date结构更改为类,如下例中加粗的部分所示:
class Date
{
	...
}
11.在"调试"菜单中单击"开始执行(不调试)"来生成并运行应用程序。验证控制台
窗口显示以下消息:
July 4 2015
Value of copy is July 4 2015
New value of weddingAnniversary is August 4 2015
Value of copy is still Agust 4 2015
前三条消息没变,第4条消息证实weddingAnniversaryCopy变量的值变成August
4 2015。
12.按 Enter键返回Visual Studio 2017。
Windows Runtime 的结构和兼容性问题
所有C#应用程序都由NET Framework 的"公共语言运行时"(Common LanguageRuntime,CLR)执行.CLR以虚拟机的形式为应用程序代码提供了安全执行环境,(有Java经验的人对这个概念再熟悉不过了.)编译C#应用程序时,编译器将 C#代码转换成一组伪机器码形式的指令,称为"公共中间语言"（Common Intermediate Language,CIL).这些指令存储在程序集中。运行C#程序时,CLR将CIL指令转换成真正的机器指令,以便处理器理解并执行、整个环境称为托管执行环境,像这样的C#代码称为托管代码,也可用.NET Framework支持的其他语言(如Visual Basic和 F#）写托管代码。Windows7和更早的Windows允许写非托管应用程序,也称为原生代码,这些代码依赖于能直接和 Windows操作系统打交道的Win32 API(运行托管应用程序时,CLR实际会将许多.NETFrmework画数转换成Wim32 API调用,只是该过程完全透明)。非托管代码可用C++等语言写,.NET Framework允许通过一些互操作性技术在托管应用程序中集成非托管代码,反之亦然。这些技术的详情超出了本书范围——只需知道上手不易。Windows后续版本采用了另一种策略,称为Windows Runtime(简称WinRT).WinRT
在Win32API(和其他选择的原生WindowsAPI)顶部建立了新的一层,为从服务器到手机的不同硬件提供了一致的功能。生成通用Windows 平台(UWP)应用时,使用的是由WinRT而非 Win32公开的API.类似地,Windows10上的CLR也使用 WinRT;使用C#和其他语言写的托管代码依然由CLR执行,但CLR会在运行时将代码转换成WinRTAPI调用而不是Win32API调用,CLR和WinRT负责安全地管理和运行代码。WinRT的一个主要目的是简化语言之间的互操作性,能在应用程序中更方便地集成用不同语言开发的组件,但方便是有代价的、取决于各种语言支持的功能集,必须做出一些妥协,尤其是,因为历史的原因,C十虽然支持结构,但不支持其中的成员函数.(C#将成员画数称为实例方法。)所以,要将C#的结构打包到库中并交给C++(或其他任何非托管语言)程序员使用,该结构就不能包含任何实例方法、结构中的静态方法也有类似的限制,要包含实例或静态方法,必须将结构转换成类、此外,结构不能包含私有字段,而且所有公共字段都必须是C#基元类型、合格的值类型或字符串。WinRT还对要在原生应用程序使用的C#类和结构提出了其他限制。

使 用 数 组
明数组变量
用一组数据项填充数组
访问数组中的数据项
遍历数组中的数据项

学习了如何创建和使用不同类型的变量。但这些变量有一个共同的地方:容纳的都是与单个元素(例如一个int、一个float、一个Circle、一个Date)有关的信息。怎么处理元素的集合呢?一个方案是为集合中的每个元素都创建一个变量,但这又会带来进一步的问题:具体需要多少个变量?如何命名?如果需要对集合中的每个元素都执行相同的操作(例如递增整数集合中的每个变量),那么如何避免写大量重复性的代码?另外,这个方案假定事先知道需要多少个元素,但这种情况普遍吗?例如,假定程序需要从数据库读取并处理记录,那么数据库有多少条记录?这个数量会时常变化吗?
数组可妥善解决这些问题。

声明和创建数组
数组是无序的元素序列。数组中的所有元素都具有相同类型(这一点和结构或类中的字段不同,它们可以是不同类型)。数组中的元素存储在一个连续性的内存块中,并通过索引来访问(这一点也和结构或类中的字段不同,它们通过名称来访问)。
声明数组变量
声明数组变量要先写它的元素类型名称,后跟一对方括号([]),最后写变量名。方括号标志该变量是数组。例如,以下语句声明 pins数组,其中包含int变量:int[]pins;//pins是Personal Identification NMmbers(个人识别号)的简称
注意 Microsoft Visual Basic程序员注意,数组声明要使用方括号而不是圆括号.C和C++程序员注意,数组大小不是声明的一部分。Java程序员注意,方括号在变量名之前。
数组元素并非只能是基元数据类型。还可以是结构、枚举或类。例如,以下代码创建由Date结构构成的数组：
Date[] dates;
提示 最好为数组变量取复数名称,例如 places(其中每个元素都是一个 Place)、people(每个元素都是一个 Person)或者times(每个元素都是一个Time).
创建数组实例
无论元素是什么类型,数组始终都是引用类型。这意味着数组变量引用堆上的内存块, 数组元素就存在这个内存块中,就跟类变量引用堆上的对象一样。即使数组元素是int这样的值类型:也是在堆上分配内存。这是值类型不在栈上分配内存的特例。
以前说过,声明类变量不会马上为对象分配内存,用new关键字创建实例才会。数组 也是如此:声明数组变量时不需要指定大小,也不会分配内存(只是在栈上分配一小块用于 存储引用的内存)。创建数组实例时才分配内存,数组大小也在这时指定。为了创建数组实例,要先写new关键字,后跟元素的类型名称,然后在一对方括号中指定要创建的数组的大小。创建数组实例时,会使用默认值(6,null或者false,分别取
决于是数值类型,是引用类型,还是 bool类型)对其元素进行初始化。例如,针对早先声明的 pins 数组变量,以下语句创建并初始化由4个整数构成的新数组:
pins= new int[4];
由于数组实例的内存动态分配,所以数组实例的大小不一定是常量;而是可以在运行
时计算,如下例所示:
int size = int.Parse(Cconsole.ReadLine());
int[]pins= new int[size];
甚至可以创建大小为O的数组。虽然听起来有点儿奇怪,但有时数组大小需动态决定,而且可能为0,所以该设计是有意义的。大小为的数组不是null(空)数组,而是包含0个元素的数组。

填充和使用数组
创建数组实例时,所有元素都被初始化为默认值(具体取决于元素类型）。例如,所有数值初始化为0,对象初始化为 null,DateTime 值初始化为日期时间值"01/01/00010 00:00:00",而字符串初始化为null。可以修改这个行为,将数组元素初始化为指定的值。为此,需要在大括号中提供一个以逗号分隔的值列表。例如,以下语句将 pins 初始化为包
含4个int 值的数组,这些值分别是9,3,7和2。
int[] pins = new int[4](9,3,7,2)；
大括号中的值不一定是常量,它们可以是在运行时计算的值。下例用4个随机数填充
pins 数组:
Random r a new Random();
int[]pins = new int[4]{	r.Next()%10,r.Next()%10,r.Next()%10,r.Next()%10};
注意 System.Random 类是伪随机数生成器.它的 Next 方法默认返回0~Int32.MaxValue之间的一个非负随机整数。Next方法有多个重载版本,可用其他版本来指定新范围。Random类的默认构造器用一个依赖于时间的值来作为随机
数生成器的种子值,这样就极大降低了一个随机数序列重复出现的概率。构造器的一个重载版本允许自己指定种子值,从而生成可重复的随机数序列供测试。
大括号中的值的数量必须和要创建的数组实例的大小完全匹配：
int[]pins = newint[3](9,3,7,2); ）;//编译时错误
int[]pins = new int[4]{9,3,7); //编译时错误
int[]pins = new int[4](9,3,7,2 ); // //正确
初始化数组变量时可以省略new表达式和数组大小。编译器根据初始值的数量来计算大小,并生成代码来创建数组。例如：
int[]pins-(9,3,7,2)；
创建由结构或对象构成的数组时,可调用构造器来初始化数组中的每个元素,例如:
Time[]schedule ={new Time(12,38), new THme(5,30));

创建隐式类型的数组
声明数组时,元素类型必须与准备存储的元素类型匹配。例如,将 pins 声明为int类型的数组(就像前面的例子那样),就不能把double,struct,string或其他非int类型的值保存到其中。如果在声明数组时指定了初始值列表,可让C#编译器自己推断数组元素的类型,如下所示:
var names - nes[]("Joh","Diana",")ames","Francesca");
在这个例子中,C#编译器推断 names 是string类型的数组变量。注意语法有两个特别之处。首先,类型后的方括号没了,本例中的names 变量被直接声明为var,而不是var[]。其次,必须在初始值列表之前添加 new[]。
使用这个语法,必须保证所有初始值都有相同类型。下例将导致编译器报错:"找不到隐式类型数组的最佳类型。"
var bad= new[]{"Johmn","Ddana",99,109};
但有时编译器会把元素转换为不同的类型——前提是结果有意义。下例的numbers会 被推断成double数组,因为常量3.5和99.999都是double值,而C#编译器能将整数值 1和2转换成double：
var numbers - new[](1,2,3.5,99.9};
一般最好避免混合使用多种类型,不要单纯寄希望于编译器帮自己转换。
以下代码创建由匿名对象构成的数
组,其中每个对象都包含两个字段,分别指定了我的家庭成员的姓名和年龄：
var name a new[]{ new{Name "John",Age = 53 },
		   new{Name ="Diana",Age = 53 }，
		   new{Name ="James",Age = 26 } ，
		   new({Name."Francesca",Age a 23}};
对于每个数组元素,匿名类型中的字段名称都必须一致。
访问单独的数组元素
必须通过索引来访问单独的数组元素。数组索引基于零,第一个元素的索引是0而不 是1.索引1访问的是第二个元素。例如,以下代码将pins 数组的索引为2的元素(第三个元素)的内容读入一个int变量：
int myPin; 
myPin a= pins[2];
类似地,可通过索引向元素赋值来更改数组内容；
myPin = 1645; 
pins[2]=myPin;
所有数组元素访问都要进行边界（上下限)检查。使用小于0或大于等于数组长度的整 数索引,编译器会抛出IndexOutOfRangeException异常,如下例所示:
try
{
	int[] pins = {9,3,7,2)；
	Cnsole.WiteLine(pins[4]);/错误,第4个也是最后一个元素的索引是3
}
catch(IndexOutOfRangeException ex)
{
	...
}
遍历数组
所有数组都是Microsoft.NETFramework的System.Array类的实例,该类定义了许多有用的属性和方法。例如,可查询Length属性来了解数组中包含多少个元素,并借助for语句来遍历所有元素。下例将pins数组的各个元素的值输出到控制台
int[]pins={9,3,7,2};
for(int index = 8;index < pins.Length;index++）
{
	int pin = pins[index];
	Console.writetLine(pin);
}
注意 Length是属性而非方法,所以调用它不用圆括号。
新手程序员经常忘记数组从元素0开始,而且最后一个元素的索引是 Length-1。C#提供了foreach语句来遍历数组的所有元素,使用该语句就可以不必关心这些问题。例如,上述for语句可以用 foreach语句修改为下面这个样子：
int[]pins {9,3,7,2）;
foreach(int pin in pins)
{
	Cnsole.writeline(pin);
}
forach 语句声明了一个循环变量(本例是int pin)来自动获取数组中每个元素的值。该变量的类型必须与数组元素类型匹配。foreach语句是遍历数组的首选方式,它更明确地表达了代码的目的,而且避免了使用for循环的麻烦。但少数情况下for语句更佳,如下所示。foreach语句总是遍历整个数组。如果只想遍历数组的一部分(例如前半部分),或者希望中途跳过特定元素
(例如隔两个跳一个),那么使用for语句将更容易。foreach语句总是从索引遍历到索引Length-1。要反向或者以其他顺序遍历,更简单的做法是使用for语句。如循环主体需要知道元素的索引,而非只是元素的值,就必须使用 for语句。
修改数组元素必须使用 for语句。这是因为foreach语句的循环变量是数组每个元素的只读拷贝。
提示 用 foreach语句遍历长度为零的数组是安全的。可以将循环变量声明为var,让C#编译器根据数组元素的类型来推断变量的类型。如果事先不知道数组元素的类型,例如在数组中包含匿名对象时,这个功能就尤其有用。下例演示了如何遍历早先描述的家庭成员数组：
var names new[] {	new{Name = "John",Age = 53},
				{	new{Name = "Diana", Age = 53},
				{	new{Name = "James",Age = 26},
				{	new{Name = "Francesca",Age = 23} };
foreach(var familyember in names)
{
	Console.writeLine($"Name:(familyember.Nlame},Age:(famdlyrember.Age)");
}
数组作为方法参数和返回值传递
方法可获取数组类型的参数,也可把它们作为返回值传递。将数组声明为方法参数的 语法和数组的声明语法差不多。例如,以下代码定义ProcessData方法来获取一个整数数 组。方法主体遍历数组来处理每个元素。
public vold ProcessData(int[] data）
{
	foreach(int i in data)
	{
		...
	}
}
记住数组是引用类型,在方法(比如 ProcessData)内部修改作为参数传递的数组,所有数组引用都会"看到"修改,其中包括原始实参。方法要返回一个数组,返回类型必须是数组类型。方法内部要创建并填充数组。下例提示用户输入数组大小,再输入每个元素的数据。最后,方法返回创建好的数组。
public int[]ReaData()
{
	Console.MriteLine("How many elements?");
	string reply =Console.ReadLine()；
	int numElements = int.Parse(reply);

	int[] data= new int[numElements];
	for(int i =8;i<numElements;1++)
	{
		Console.iritelLine($"Enter data for element {i)");
		reply =Console.ReadLine()；
		int elementData = int.Parse(reply);
		data[1]= elementData;
	}
	return data;
}
可像下面这样调用 ReadData:
int[]data a ReadData();
Main 方法的数组参数，你可能早已注意到应用程序的Main方法获取一个字符串数组作为参数:
static void Main(string[]args)
{
	...
}
Main方法是程序运行时的入口方法。从命令行启动程序时,可以指定附加的命令行参数。Microsoft Windows操作系统将这些参数传给CLR,后者将它们作为实参传给Main方法。这个机制允许在程序开始运行时直接提供信息,而不必交互式地提示输入信息,编写能通过自动脚本运行的实用程序时,这个机制相当有用,下例来自一个用于文件处理的MyFileUtl实用程序,它允许在命今行输入一组文件名,然后调用ProcesSFile方法(这里没有显示)处理每个文件:
static void Main(string[] args)
{
	foreach(string fllename in args)
	{
		ProcessFile(fllename);
	}
}
可在命令行上像下面这样运行MyFileUtil程序:
MyFileUtil C:\Temp\TestData.datC:\Users\John\Documents\WyDoc.txt
每个命令参数都以空格分隔,由MyFileUil程序负责验证实参的有效性。

复制数组
数组是引用类型(记住数组是 System.Array类的实例)。数组变量包含对数组实例的引用。这意味着在复制了数组变量之后,将获得对同一个数组实例的两个引用。例如:
int[] pins ={9,3,7,2）;
int[]alias=pins;//allas和pins现在引用同一个数组实例
在这个例子中,修改pins[1]的值,读取alias[1]时也会看到改动。要完全复制数组实例,获得堆上实际数据的拷贝,必须做两件事情。首先,必须创建类型和大小与原始数组一样的新数组实例,然后将数据元素从原始数组逐个复制到新数组,如下例所示
int[]pins{9,3,7,2）;
int[] copy = new int[pins.Length];
for(int i =0;i<copy.Length;i++)
{
	copy[1]= pins[1];
}
注意,上例使用原始数组的Length属性指定新数组大小。
复制数组是常见操作,所以 System.Array类提供了一些方法来复制数组,避免每次 都要写上面那样的代码。例如,CopyTo方法将一个数组的内容复制到另一个数组,并从指定的起始索引处开始复制。下例从索引开始将pins 数组的所有元素复制到copy数组。
int[]pins=(9,3,7,2）; 
int[]copy= new int[pins.Length];
pins.CopyTo(copy,0);
复制值的另一个办法是使用System.Array的静态方法 Copy。和 CopyTo一样,目标数组必须在调用Copy 前初始化：
int[]pins{9,3,7,2）;
int[] copy = new int[pins.Length];
Array.copy(pins,copy,copy.Length);
注意 Array.Copy 方法的长度参数必须是一个有效的值．提供负值会抛出 ArgumentOutOfRangeException 异常．提供比元素数量大的值,会抛出 ArgumentException异常。
可使用System.Array的实例方法Clone,它的特点是一次调用就能创建数组并完成复制
int[]pins={9,3,7,2}；
int[] copy =(int[])pins.Clone();
注意 Array类的Clone方法返回 object 而不是Array,
所以必须在使用时强制转换成恰当类型的数组.另外,Clone、CopyTo和Copy
这三个方法创建的都是数组的浅拷贝，.简单地说,如果被复制的数组包舍引用,这些方法只复制引用,不复制被引用的对象．复制后,两个数组都引用同一组对象,要创建数组的深拷则(即复制被引用的
对象),必须在for循环中写恰当的代码来做这件事情。

使用多维数组
目前为止的数组都是一维数组,相当于简单的值列表。还可以创建多维数组。例如, 二维数组是包含两个整数索引的数组。以下代码创建包含24个整数的二维数组items.可 将二维数组想象成表格,第一维是表行,第二维是表列。
int[,] items = nes int[4,6];
访问二维数组元素需提供两个索引值来指定目标元素的"单元格"(行列交汇处)。以 下代码展示了items 数组的用法：
items[2,3] = 99; //将单元格(2,3)的元素设为99
item[2,4] = item [2,3];//将单元格(2,3)的元素复制到单元格(2,4)
tems[2,4]++ //递增单元格(2,4)的整数值
数组维数没有限制。以下代码创建并使用名为cube 的三维数组。访问三维数组的元素必须指定3个索引。
int[,]cube = new int[5,5,5];
cube[1,2,1] = 101;
cube[1,2,1]= cube[1,2,1]*3;
超过三维的数组时要小心,数组可能耗用大量内存。上例的cube 数组包含 125个元素(5*5*5)。而对于每一维大小都是5的四维数组,则总共包含625个元素。使用多维数组时,一般都要准备好捕捉并处理OutOfemoryException异常。
创建交错数组
在c#中,普通多维数组有时也称为矩形数组。例如,下面这个表格式二维数组每一行都包含40个元素,共计160个元素。
int[,] items = newint[4,40];
多维数组可能消耗大量内存。如应用程序只用到每一列的部分数据,为未使用的元素分配内存就是巨大的浪费。这时可考虑使用交错数组(或称为不规则数组),
其每一列的长度都可以不同,如下所示:
int[][]items= new int[4][];
int[]columForRow0 = new int[3];
int[] columnForRow1 = new int[10];
int[] columForRow2 = new int[40];
int[] colummForRowo3= new int[25];
items[0]= columnforRow0;
items[1] = columnForRow1;
items[2] = columnForRoM2;
items[3] = columForRoud3;
本例第一列3个元素,第二列10个元素,第三列40个元素,最后一列25个元素。交错数组其实就是由数组构成的数组。items数组不是二维数组,而是一维数组,但那一维中的元素本身就是数组。此外,items数组的总大小是78个元素而不是160个;不用的元素不分配空间。
注意交错数组的语法。以下代码将items指定为由int数组构成的数组。
int[][] items;
以下语句初始化items来容纳4个元素,每个元素都是长度不定的数组。
items = new int[4][];
从columnForRowe 到columnForRow3的数组都是一维int数组,它们初始化来容纳每一列所需的数据量。最后,每个这样的数组都被赋给 items 数组中的对应元素,例如:
items[0]= colummForRow0;
记住，数组是引用类型的对象,所以上述语句只是为items数组的第一个元素添加对columnForRowe的引用,不会实际复制任何数据。为了填充该列的数据,要么将值赋给columnForRowe中的元素,要么通过items数组来引用。以下语句是等价的:
columForRowe[1]= 99;
items[0][1]=99;
同样的概念还可扩展为创建"数组的数组的数组"(而不是矩形三维数组),以此类推。
注意 如果以前写过Java程序,这个概念应该不会陌生,Java没有多维数组的概念,需要像刚才描述的那样写"数组的数组"。
以下练习利用数组在扑克牌游戏中发牌,应用程序显示窗体来模拟向4个玩家发一副 扑克牌(52张牌,没有大小王)。你将完成为每一手发牌的代码。用数组实现扑克牌游戏
1.如Microsoft Visual Studio2017尚未启动,请启动。
2. 打开Cards解决方案,它位于"文档"文件夹下的Microsoft Press\VCSBS\Chapter10\Cards 子文件夹。
3.在"调试"菜单中选择"开始调试"来生成并运行应用程序。随后会显示标题为CardGame的窗体,窗体包含4个文本框(标签分别是North,South,East 和West)。单击底部的省略号打开命令栏,应出现 Deal(发牌)按钮。
注意 这是在通用Windows平台(UWP)应用中定位命令按钮的首选方式。从现在起,本书展示的所有UWP应用都遵循该样式。
4.单击Deal按钮。
什么都不会发生。尚未实现发牌代码,这是本练习要做的事情。
5.返回VisualStudio 2017,在"调试"菜单中选择"停止调试。
6.在"代码和文本编辑器"窗口中显示Value.cs 文件。其中包含一个名为Value的枚举,它代表一张牌所有可能的点数,升序:
enum Value (TMo, Three,Four, Five,Six, Seven, Eight, Nine,Ten,Jack,Queen, King,Ace）
7.在"代码和文本编辑器"窗口中显示 Suitcs 文件。
该文件包含一个名为Suit 的枚举,代表一副牌中的所有花色:
enum Suit{Clubs, Diamonds, Hearts,Spades }
8.在"代码和文本编辑器"窗口中显示 PlayingCard.cs 文件。
该文件包含PlayingCard类,用于对一张牌进行建模。
class PlayingCard
{
	prlvate readonly Sutt sutt;//花色
	private readonly Value value;//点数

	public PlayingCard(Sut s,Value v)
	{
		this.suit = S;
		this.value = v;
	}
	public override string ToString()
	{
		string result - $"{this.value} of {this.suit};
		return result
	}
	public Sudt Cardsuit()
	{
		return this.suit;
	}
	public Value Cardvalue()
	{
		return this.value;
	}
}
该类包含两个只读字段(value 和 suit),代表牌的点数和花色。构造器初始化两个字段。类包含一对方法CardValue和CardSuit,分别返回牌的点数和花色。另外,类这重写(override)了ToString方法,返回一张牌的字符串表示。
注意 如数据在初始化之后不再改变,就适合用只读字段来建模。向只读字段赋值需在声明时初始化它或者用构造器进行初始化,但之后就不能变了。
9.在"代码和文本编辑器"窗口中显示Packcs 文件。
该文件包含 Pack类,它对一副牌(或者称为一个牌墩)进行建模。Pack类顶部是两个公共常量int字段NumSuits和CardsPerSuit,分别指定一副牌有几种花色,以及每种花色多少张牌。私有cardPack变量是由PlayingCard对象构成的二维数组。(第一维指定花色,第二维指定点数。)randomCardSelector 变量是基于Random类生成的随机数。将利用 randomCardSelector洗牌。
class Pack
{
	public const int NumSuts=4;
	public const int CardsPersuit 13;
	private Playingard[,] cardPack;
	private Random randomCardSelector n new Random();
	...
}
10.找到 Pack类的默认构造器。目前该构造器空白,只有一条//T000:注释。删除注释,添加以下加粗的代码来实例化cardPack数组,使其每一维都有正确的长度。
public Pack()
{
	this. cardPack = new PlayingCard[Numsuits,CardsPeSut];
}
11.将以下加粗代码添加到 Pack构造器,用一整副排好序的牌填充cardPack数组。
public Pack()
{
	this. cardPack = new PlayingCard[NumSuts,CardsPerSut];
	for(Sudt suit a Sut.Clubs;suitca Suit.Spades;suit++)
	{
		for(Value value = Value.TMo; value <= Value.Ace; valuet++)
		{
			this. cardPack[(int)sult,(int)value]· nesw Playingard(sudt,value);
		}
	}
}
外层for循环遍历Suit 枚举的值列表,内层for循环遍历每种花色中的每个点数。内层循环每一次迭代,都创建特定花色和点数的一个新的PlayingCard对象(也就是一张牌),并把它添加到cardPack数组的恰当位置。
注意 数组索引只能使用整数值.suit和value变量是枚举变量,但枚举基于整型,所以可安全转型为int。
12.在 Pack类中找到 DealCardFromPack方法。该方法从一副牌中随机挑选一张牌,从牌墩中移除这张牌以防它被再次选中,最后作为方法返回值返回。方法第一个任务是随机选择花色。删除注释和抛出 NotmplementedException异
常的语句,替换成以下加粗的语句。
 public Playingard DealCardFromPack
 {
 	Suit suit =(Sult)randonCardSelector.Next(Mumsudts);
 }
该语句使用randomCardSelector随机数生成器的Next方法返回和一种花色对应的随机数。Next方法的参数指定随机数上限(不含该上限);生成的值在0到这个值减1之间。注意返回一个int,必须先转型再赋给Suit类型的变量。
总是存在所选花色没有更多牌的可能。所以需要处理这个情况,并在必要时选择另一种花色。
13.在随机选择花色的代码后面添加以下加粗的while循环。该循环调用IsSuitEmpty方法检查牌墩中是否还有指定花色的牌(马上就要实现该方法的逻辑)。如果没有,就随机选择另一种花色(可能选中同样的花色),并再次检查。循环将重复该过程,直至发现至少还有一张牌的花色。
 public PlayingCard DealCardFromPack()
 {
 	Suit suit (Sut)randomnCardSelector.Next(AumSults);
 	while(this.IsSutEmpty(suit)
 	{
 		suit =(Sut)randonCardselector.Mext(MumSuits);
 	}
 }
 14.目前已随机选择了一种至少还有一张牌的花色。下个任务是在这种花色中随机挑选一张牌。可用随机数生成器选择一个点数,但和前面一样,不保证选出的牌还没有发出。但可以采用和前面一样的模式:调用ISCardAlreadyDealt方法判断牌是否发出(马上就要实现该方法的逻辑)。如果是,就随机选择另一张牌,并重新尝试。该过程一直重复,直至发现一张牌为止。在 DealCardFromPack 方法现有的语句后面添加以下加粗的语句。
public PlayingCard DealCardFromPack()
{
	...
	Value value=（Value)randomCardSelector.NMext(CardsPerSuit);
	while(this.IsCardAlreadyoealt(suit, value))
	{
		value =(Value)randomCardSelector.Next(CardsPerSuit);
	}
}
15.现已选好了一张随机的、以前没有发过的牌。在DealCardFromPack 方法末尾添加以下加粗的代码来返回这张牌,将 cardPack数组中对应的元素设为null;
public PlayingCard DealCardFromPack()
{
	...
	playingCard card= this.cardPack[(int)suit,(int)value];
	this.cardPack[(int)suit,(int)value]= null;
	return card;
}
16.找到IsSuitEmpty方法。该方法获取一个 Suit参数,返回一个bool值指出是否还有该花色的牌留在牌墩里。删除注释和抛出 NotImplementedException 异常的语句,添加以下加粗的代码:
private bool IssuitEmpty(Suit suit)
{
	bool result a true;
	for (Value value = Value. Tho;value(= Value.Ace;value+t)
	{
		if(!IsCardAlreadypealt(sut,value)
		{
			result = false;
			break;
		}
	}
	return result;
}
上述代码遍历所有可能的牌点,使用ISCardAlrcadyDcalt方法(将于下一步完成)判断cardPack数组中是否有一张指定花色和点数的牌。如果有,就将result变量设为false,并用break语句终止循环。相反,如果一直到循环结束都没有找到符合要求的牌,result变量将保持初始值true。方法最后返回result变量值。
17.找到ISCardAlreadyDealt方法。该方法判断指定花色和点数的牌是否发出并从牌墩中删除。以后会看到,DealFromPack方法发一张牌时,会将其从cardPack数组中删除,并将对应元素设为null。将注释和抛出NotImplementedException异常的代码替换以下加粗的代码:
private bool IsCardAlreadypealt(Sut suit,value value)
=>(ths.cardPack[(int)suit,(int)value]=null);
如果 cardPack数组中指定 suit和 value 的元素为null,方法就返回 true,否则返回false。
18.下一步是将所选的牌添加到一手牌(一个hand)中。在"代码和文本编辑器"窗口中显示Hand.cs 文件。该文件包含Hand类,用于实现"一手牌"的概念(也就是发给一个玩家的全部牌)。
文件包含名为HandSize的public constint字段,设置成一手牌有多少张牌(13)。还包含由PlayingCard 对象构成的数组,数组用 HandS1ze 常量初始化。利用playingCardCount字段,代码可在填充一手牌期间跟踪牌的数量。
class Hand
{
	public const int HandS1ze= 13;
	private PlayingCard[] cards= new PlayingCard[HandSize];
	private int playingCardCount =0;
}
ToString方法生成手上所有牌的字符串表示。它用foreach循环遍历cards数组,为它发现的每个PlayingCard对象调用ToString方法。出于格式化的目的,这些字符串用一个换行符连接。（用Environment.NewLine常量指定换行符。）
public override string ToString()
{
	string result= "";
	foreach（Playingcard card in thts.cards)
	{
		result += $"(card.ToString()}Emvironmment.NewLine}";
	}
	return result;
}
19.找到 Hand类的 AddCardToHand 方法。该方法将作为参数指定的牌添加到一手牌中。在方法中添加以下加粗的语句:
public void AddCardToHand(PlayingCard cardDealt)
{
	if(this.playingCardCount >m HandSize)
	{
		throw nesw ArgumentException("Too many cards");
	}
	this. cards[this.playingardCount]= cardDealt;
	this.playingCardCount++;
}
上述代码首先验证这一手牌还没有满。满了就抛出 ArgumentException异常(这个情况应该永远都不会发生,但保险一点总没错)。否则,就将牌(一个PlayingCard对象)添加到cards数组中由playingCardCount变量指定的索引位置。然后,这个变量递增1.
20.在解决方案资源管理器中展开 MainPage.xaml节点,再在"代码和文本编辑器"窗口中打打开 MainPage.xaml.cs 文件。这些是Card Game 窗口的代码。找到dealClick 方法。单击Deal(发牌)按钮将调用该方法。方法目前包含空的try块和一个异常处理程序(发生异常时显示一条消息)。
21.删除注释并在try块中添加以下加粗的语句：
private void dealClick(object sender,RoutedeventArgs e)
{
	try
	{
		pack = new Pack();
	}
	catch(Exception ex)
	{
		...
	}
}
该语句创建一副新牌。前面说过,Pack类包含容纳了牌墩的二维数组,构造器用每张牌的细节来填充数组。现在需要从这个牌墩创建4手牌。
22.在 try块中添加以下加粗的语句:
try
{
	pack= new Pack();
	for(int handNum = 6; handNum<NumHands; handNLum+t)
	{
		hands[handum] = new Hand();
	}
}
catch(Exception ex)
{
	...
}
for循环从一副牌中创建 4手牌,把它们存储到名为hands 的数组中。每一手牌最开始都是空的,需要将牌发给每一手。
23.为for循环添加以下加粗的代码:
try
{
	...
	for(int handNum =6;handNum< Numands; handNum++)
	{
		hands[handNAum]- new Hand();
		for(int nunCards = 6;numCards< Hand.HandSize;numCards+)
		{
			playingCard cardDealt pack.DealCardFromPack();
			hands[handNm].AddCardToHand(cardDealt);
		}
	}
}
catch(Exception ex)
{
	...
}
内层 for循环使用 DealCardFromPack 方法从牌墩里随机获取一张牌,而AddCardToHand方法将这张牌添加到一手牌中。
24.在外层for循环后面添加以下加粗的代码:
try
{
	...
	for(int handNum = 8; handNum< NumHands;handNum++)
	{
		...
	}
	north.Text= hands[0].ToString();
	south.Text = hands[1].ToString();
	east.Text = hands[2].ToString();
	west.Text = hands[3].TosString();
}
catch(Exception ex)
{
	...
}
所有牌都发好后,上述代码在窗体上的文本框中显示每一手牌。文本框的名称是north,south,east和 west。代码用每个hand的ToString方法格式化输出。任何位置发生异常,catch处理程序都会显示消息框并在其中显示错误消息。
25.在"调试"菜单中选择"开始执行(不调试)"。CardGame 窗口出现后展开命令栏并单击 Deal。牌墩中的牌应随机发给每一手,每手牌都应在窗体上显示
26.再次单击Deal按钮会重新发牌,每一手牌都会变化。
27.返回Visual Studio并停止调试。

访问包含值类型的数组
数组是按索引排序的简单数据集合。知道索引就能轻松获取一个数据项。但要基于其他特性来查找数据,一般就要实现相应的辅助方法,执行搜索并返回目标项的索引。
例如,以下代码创建由Person对象构成的数组family。Person是类。
class Person
{
	public string Name;
	publlc int Age;

	public Person(string name,int age)
	{
		this.Name name;
		this.Age age;
	}
}
...
person[] famdly a new[]
{
	new Person("John",53),
	new Person("DLana",,53),
	new Person("James",26),
	new Person("Francesca",23)
};
现在想查找家里年龄最小的人,所以写了以下方法
Person findYoungest()
{
	int youngest = 0;
	for(int i= 1;1< family.Length;i++)
	{
		if (family[i].Age< family[youngest].Age)
		{
			youngest = i;
		}
	}
	retum family[youngest];
}
然后调用方法并显示结果:
var mostYouthful=findYoungest();
Console.writeLine($"Name:{mostYouthful.Name},Age:{mostYouthful.Age)");
结果符合预期:
Name:Francesca,Age:23
然后你想更新一下年龄最小的家庭成员的年龄（Francesca 刚过生日,现在24岁了),所
以写了以下语句:
mostYouthful.Age++;
最后,为确认一切都正确改变,用以下语句遍历family数组并显示其内容:
foreach(Person familyember in family)
{
	Console.writeLine($"Mame:(fandlyember.Name),Age:(famtlyember.Age});
}
结果不错,Francesca的年龄正确修改了:
Name:John,Age:53
Name:Dlana, Age:53
Name:lames,Age: 26
Name:Francesca,Age:24
这时你突然想到Person类实际不应设计成类,而应设计成结构,所以修改了一下:
struct Person
{
	Public string Mame;
	public int Age;

	Public Person(string name,int age)
	{
		this.Name = name;
		this.Age = age;
	}
}
代码能编译和运行,但你注意到Francesca的年龄不再更新了。foreach循环的输出如下所示:
Name:John, Age:53
Name:DLana,Age:53 
Name:James,Age:26
Name:Francesca,Age: 23
问题在于将引用类型转变成了值类型。family数组中的数据从一组对堆上对象的引用
变成了栈上的数据拷贝。之前,findYoungest方法返回的是对一个 Person对象的引用, 所以 Age 字段的递增操作能通过该引用更新堆上的原始对象。而现在family数组包含的 是值类型,findYoungest方法返回的是数组中的一个项的拷贝而不是引用。此时递增 Age 字段更新的是一个Person拷贝,而不是更新 family数组中的原始数据项。
为了解决该问题,可修改findYoungest方法用 ref 关键字显式返回对值类型的引用而 不是拷贝,如下所示:
ref Person findYoungest()
{
	int youngest =0;
	for(Int1= 1;i< family.Length;1)
	{
		if（famdly[1].Age< famtily[youngest].Age)
		{
			youngest = i;
		}
	}
	return ref famtly[youngest];
}
注意,大多数代码未改动。返回类型变成 ref Person(一个Person 引用),return 语
句也相应修改成返回对 family 数组中年龄最小项的引用。
调用方法时,有两个地方也必须对应地修改:
ref var mostYouthful = ref findYoungest();
这些修改指出mostYouthful是对 family 数组中的一个数据项的引用。如下所示,还 是和以前一样访问该项的字段,但C#编译器现在知道应通过变量提领(解引用,用引, dereference)数据。结果,递增语句止确史新数组中的原始数据而非拷贝：
mostYouthful.Age++;
再打印数组内容,Francsca的年龄就能如实变化了:
foreach（Person famdlyember in famdly)
{
	Console.MriteLine($"Name:(familyember.Name),Age:(famdlyember.Age)");
}
将显示以下结果:
Name:John,Age:53
Name:Diana,Age:53
Name:James,Age:24
Name:Francesca,Age:24
从方法返回引用数据,这很强大但使用需谨慎。只有方法结束后仍然存在的数据（比如数组元素),才能返回对它的引用。例如,对于方法在栈上创建的局部变量,便不能返回
对它的引用:
//不要尝试,编译不了
ref int danglingReference()
{
	int i;
	...//用1进行计算
	returm ref i;
}
这其实是旧C程序的一个常见问题,称为"虚悬引用""。幸好 C#编译器从源头杜绝了此类问题。

理解参数数组
写方法使用 params 关键字来接受任意数量的实参
写方法使用 params关键字和object类型接受任意类型和数量的实参
比较获取参数数组的方法和荻取可选参数的方法
如方法需要获取数量可变、类型也可能不同的实参,就可考虑使用参数数组。熟悉面向对象概念的人或许不喜欢这种方式。毕竟,面向对象解决这个问题的方案是定义方法的重载版本。但重载不是万金油,尤其是实参数量真的变化很大,而且每次调用时实参类型也可能不同的时候。
回顾重载
重载是指在同一作用域中声明两个或更多同名方法,适合对不同类型的实参执行相同的操作。VisualC经典的重载例子是Console.WriteLine。该方法被重载了好多次,确保可向它传递任何基元类型的参数。以下代码展示了WriteLine方法在Console类中的定义:
class Console
{
	public static vold WriteLine(Int32 value)
	public static vold Writeline(Double value)
	public static vold WriteLine(Decimal value)
	public static vold WriteLine(Boolean value)
	public static void WriteLine(String value)
	...
}
注意MritelinMriteLine方法的参数类型实际是在System命名空间中定义的结构类型,而非C#别名．例如,荻取int的重载版本实际获取Int32作为参数重载很有用,但没有照顾到所有情况。尤其是,如果发生变化的不是参数类型,而是
参数的数量,重载就有点儿"力不从心"了。例如,假定要向控制台写入许多值,那么该怎么办?是不是必须提供Console.MriteLine的更多版本,让每个版本都获取不同数量的参数?那就太麻烦了!幸好,有一种技术允许只写一个方法就能接受数量可变的参数。这种技术就是参数数组(用 params关键字声明的参数)。为了理解参数数组如何解决这个问题,首先需要理解普通数组的用途和缺点。
使用数组参数
假定要写方法判断作为实参传递的一组值中的最小值。一个办法是使用数组。例如, 为查找几个int 值中最小的,可写静态方法Min,向其传递一个int数组,如下所示:
class Util
{
	publicstatic int Min(int[]paramList)
	{
		//验证调用者至少提供了一个参数。
		//否则抛出ArgumentException异常,
		//因为不可能在空列表中查找最小值
		if（paramList =s null ll paramList.Length ==0)
		{
			thow new ArgumentException("Ut1l.Nin:not enough arguments");
		}
		//将参数列表第一项设为当前最小值
		int currentNin = paramiist[0];

		//遍历参数列表,检查是否有一个值比currentMin小
		foreach(int i in paramList)
		{
			//找到比currentin小的就把它把设为currentMin的值
			if(1<currentMin）
			{
				currentin=1;
			}
		}
		//循环结束后 currentNn 必然容纳参数列表中的最小值。所以直接返回它
		return currentMin;
	}

}
注意 ArgumentException特别设计成在提供的实参不满足方法要求时抛出用Min方法判断两个int 变量(first和 second)的最小值可以这样写:
int[] array= new int[2];
array[6]= frst; array[1]· second;
int mn = Uti.Min(array);
用Min方法判断三个int变量(first,second和 third)的最小值可以这样写。
int[] array a new int[3];
array[0]a first;
array[1]= second;
array(2]= third;
int min = Ui1.Min(array);
可以看出,这个方案避免了对大量重载的需求,但也为此付出了代价:必须写额外留代码来填充传入的数组。当然,也可以像下面这样使用匿名数组:
int min = U11.Min(new int[](first,second,third);
但本质没变,仍需创建和填充数组,而且这个语法还有点儿不容易理解。解决方案是向Min方法传递用 params关键字声明的参数数组,让编译器自动生成这样的代码。
声明参数数组
参数数组允许将数量可变的实参传给方法。为了定义参数数组,要用params关键字修饰数组参数。例如下面这个修改过的Min方法。这次它的数组参数被声明成参数数组:
class Util
{
	public static int Min(params int[] paramList)
	{
		//这里的代和以前完全一样
	}
}
params关键字对Min方法的影响是:调用该方法时,可传递任意数量的整数实参,而不必担心创建数组的问题。例如,要判断两个整数值哪个最小,可以像下面这样写:
int min = Uti.Min(first,second);
编译器自动将上述调用转换成如下所示的代码:
int[] array· new int[2];
array[0] = first;
array[1]= second;
int min = Ut1l.Min(array);
下代码判断三个整数哪个最小,它同样被编译器转换成使用了数组的等价代码:
两个Min调用(一个传递了两个实参,另一个传递了三个)都被解析成使用了params关键字的同一个Min方法。事实上,可在调用Mn方法时传递任意数量的int实参。编译器每次都会统计int 实参数量,并创建这个大小的int 数组,在数组中填充实参,最后调用方法,将单独一个数组参数传给它。
注意 C和C++程序员可将 params理解成头文件stdarg.h定义的 varargs宏的"类型安全"等价物。Java也有工作方式与C# params 关键字相似的 varargs机制。
参数数组需注意以下几点。
只能为一维数组使用params关键字,不能用于多维数组,以下代码不能编译：
//编译时错误
public static int Min(params int[,] table)
...
不能只依赖 params关键字来重载方法。params关键字不是方法签名的一部分,如下例所示：
//编译时错误:重复的声明
public static int Min(int[] paramList
...
public static int Min(params int[] paramtist)
...
不允许为参数数组指定 ref或out 修饰符,如下例所示:
//编译时错误
public static int Min(out params int[] paramList)
...
public static int Nin(ref params int[] paramlList)
...
params 数组必须是方法最后一个参数。意味着每个方法只能有一个参数数组。如
下例所示:
//编译时错误
public static int Min(params int[] paramList,int i)
...
非 params方法总是优先于 params 方法。也就是说,如果愿意,仍然可以创建方 法的重载版本以便在常规情况下使用
public static int Nin(int leftuandSide,int rightandSide)
...
public static int Min(params int[] paramist)
...
调用Min 时传递两个int实参,就用Min的第一个版本。传递其他任意数量的int 实 参(包括无任何实参的情况),就用第二个版本。为方法声明无参数数组的版本或许能优化
性能,避免编译器创建和填充太多数组。
使用 params object[]
类型的参数数组很有用,它允许在方法调用中传递任意数量的int 参数。但如果参数数量不固定,类型也不固定,又该怎么办?C#也为此提供了对策。该技术基于这样一 个事实:object 是所有类的根,编译器通过装箱将值类型(那些不是类的东西)转换成对象。可让方法接收object类型的一个参数数组,从而接收任意数量的objec实参;换言之,实参不仅数量随意,类型也可随意,如下例所示:
class Black
{
	public static void Hole(params object [] paramList)
	...
}
我将该方法命名为Black.Hole(黑洞),意思是任何实参都不能从中逃脱。
不向它传递任何实参,编译器将传递长度为O的 object数组:
Black.Hole();//转换成Black,Hole(new object[0]);
传递 nul1作为实参。数组是引用类型,所以允许使用null来初始化数组:
Black.Hole(null);
传递一个实际的数组。也就是说,可以手动创建本应由编译器创建的数组:
object[] array =new object[2];
array[?]"forty two";
array[1]-42;
Black.Hole(array);
传递不同类型的实参,这些实参自动包装到 object数组中:
Black.Hole("forty two",42);//转换成lack.Hole(new object[]("forty two",42));
Console.WritelLine方法
Console类包含 MriteLine方法的大量重载版本,下面是其中一个;
public static void writeLine(string format,params object[] arg); 
虽然字符串插值使该WriteLine重载版本显得有些多余,但它在以前的C#语言中还是很吃香的。它获取包含占位符的一个格式宇符串实参,每个占位符都在运行时替换成任意类型的变量.下面是调用该方法的一个例子(fname 和 lname 是字符串,mi是char,age是int):
Console.MriteLine("Forename:(e},Middle Initial:{1},Last name:{2},Age:(3}",fname,mi,Iname,age);
编译器将此调用解析成以下形式:
Console.MriteLine("Forename:(0}, Middle Initial:(1},Last name:(2},Age:(3}",new object[4](fname,mi,Iname,age]);

使用参数数组
以下练习将实现并测试名为Sum的静态方法。方法作用是计算数量可变的int 实参之和,结果作为int返回。为此,Sum要获取一个 params int[]参数。要实现对参数数组的两项检查来确保 Sum方法的健壮性,然后用各种实参测试Sum方法。
获取参数数组的方法
1.如Microsoft Visual Studio 2017尚未启动,请启动。
2. 打开 ParamsAray 解决方案,它位于"文档"文件夹下的 Microsof Press\VCSBS\Chapter I1\ParamArrays子文件夹。
Progam.cs 包含Program类,采用前几章用过的doork方法框架。Sum方法将作为另一个名为Util("utility"的简称)类的静态方法实现。该类稍后添加。
3.在解决方案资源管理器中右击ParamsAray项目,选择"添加""类"。
4.在"添加新项-ParamsArray"对话框中间窗格单击"类"模板,在"名称"框中输入Util.es,单击"添加"。随后会创建UiLcs 文件并添加到项目。其中包含 ParamsArray命名空间中的空白类Util。
5.在Util类中添加名为 Sum的公共静态方法。Sum方法返回一个int,接受一个由int 值构成的参数数组。Sum方法应该像下面这样:
public static int Sum(params int[] paramtist)
{
}
实现Sum方法的第一步是检查 paramList 参数。除了包含有效整数集合,它还可能是 null或长度为e的数组。这两种情况都难以求和,所以最好的方案是抛出ArgumentException异常(你可能会说,在长度为9的数组中,整数之和不应该是0吗?本例将这种情况视为异常）。
6.在Sum方法中添加以下加粗语句,paramList为null就抛出ArgumentException。现在的Sum方法应该像下面这样:
public static int Sum(params int[] paramList)
{
	if(paramtist =s null)
	{
		throw new Argumentexception("Util.Su:null paraeter list");
	}
}
7.在Sum方法中添加另一个语句,在数组长度为9时抛出 ArgumentException。如以下加粗的语句所示：
public staticint Sum(params int[] parasList)
{
	if(paramList == null)
	{
		throw new ArgumentException("Uti1. Sum:null parameter list");
	}
	if(paramList.Length ==0)
	{
		throw new ArgumentException("Uti1.Sum:epty parameter ist");
	}
如数组通过了这两项测试,下一步就是将数组的所有元素加到一起。可用foreach语句求所有元素之和。需要一个局部变量来容纳求和结果。
8.在上一步的代码后声明int 变量 sumTotal,初始化为0。
public static int Sum(params int[] paramList)
{
	...
	if(paramList. Length ==0)
	{
		throw new ArgumentException("Util. Sum:empty parameter list");
	}

	int sumTotal 6;
}
9.为 Sum方法添加 foreach 语句来遍历 paramList数组。循环主体应将数组中的每个元素的值都累加到sumTotal上。在方法末尾,用 return 语句返回 sumTotal的值,如以下加粗的代码所示。
public static int Sum(params int[] paramList)
{
	...
	int sumTotal= 6;
	foreach(int i in paramList)
	{
		sumTotal+= 1;
	}
	return sumTotal;
}
10.选择"生成"|"生成解决方案"命令。确定代码没有错误。
测试 Util.Sum方法
1.在"代码和文本编辑器"窗口中打开 Program.s源代码文件
2. 在"代码和文本编辑器"窗口中,删除 doMork方法的//T000:注释,添加以下语句:
Console.writelLine(Util.Sum(mull);
3.选择"调试"│"开始执行(不调试)"命令。
程序将生成并运行并在控制台上输出以下消息:Exception: Uil.Sum: null parameter list 这证明方法中的第一个检查是有效的。
4.按 Enter 键结束程序,返回VisualStudio 2017
5. 在"代码和文本编辑器"窗口中修改dowork 中的Console.MriteLine 调用:
Console.writeLine(Util.Sum();
这次调用方法没有传递任何实参。编译器将空白参数列表解释成空白数组。
6，选择"调试"|"开始执行(不调试)"命令。
程序将生成并运行,并在控制台上输出以下消息:
Exception: Util. Sum:epty parameter 1st 这证明方法中的第二个检查也是有效的。
7.按 Enter 键结束程序,返回Visual Studio 2017。
8.像下面这样修改 dowork 中的Console.MriteLine的调用:
Cconsole.wrtelLine(Util.Sum(18,9,8,7,6,5,4,3,2,1);
9.选择"调试"│"开始执行(不调试）"命令。
程序生成并运行,在控制台上输出55.
10.按 Enter 键关闭应用程序并返回Visual Studio 2017

比较参数数组和可选参数
获取参数数组的方法和获取可选参数的方法存在一定程度的重叠,但两者有着根本性的区别。获取可选参数的方法仍然有固定参数列表,不能传递一组任意的实参。编译器会生成代码,在方法运行前,为任何遗漏的实参在栈上插入默认值。方法不关心哪些实参是由调用者提供的,哪些是由编译器生成的默认值。
使用参数数组的方法相当于有一个完全任意的参数列表,没有任何参数有默认 此外,方法可准确判断调用者提供了多少个实参。通常,如果方法要获取任意数量的参数(包括0个),就使用参数数组。只有在不方便强迫调用者为每个参数都提供实参时才使用可选参数。最后还要注意,如方法获取参数数组,同时提供了重载版本来获取可选参数,那么在调用时传递的实参和两个方法签名都匹配的时候,具体调用哪个版本并非总是让人一目了然。
比较参数数组和可选参数
1.返回Visual Studio 2017中的ParamsArray解决方案,在"代码和文本编辑器"窗口中显示Util.cs 文件。
2. 将以下加粗的Console.wMriteLine语句添加到Util类的Sum方法的开头:
public static int Sum(params int[] paramList）
{
	Console.writeLine("Usingparameter ist");//使用参数数组
	...
}
3.在Uti1类中添加Sum方法的另一个实现。这个版本获取4个可选的int实参,默认值都是o.方法主体输出消息:"Using optional parameters",然后计算并返回4个参数之和。完成后的方法如下所示:
class Util
{
	...
	public static int Sum( int param=6,int parama2=0,
							int param3 -6,int param4=0)
	{
		Console.MriteLine("Using optional parameters");
		int sumTotal = param ＋ paran2+param3 ＋param4;
		return sumTotal;
	}
}
4.在"代码和文本编辑器"窗口中显示Program.cs 文件。
5.在dowork方法中注释掉现有代码,添加以下语句:
	Console.MwriteLine(Uti1.Sum(2,4,6,8);
它调用 Sum方法,传递4个int参数。该调用匹配Sum方法的两个重载版本。
6.在"调试"菜单中单击"开始执行(不调试)"来生成并运行应用程序。
应用程序运行时,会显示以下消息:
Using optional paraneters
20
在本例中,编译器生成的代码会调用获取4个可选参数的版本。这个版本和方法调用最匹配。
7.按Enter 键返回Visual Studio。
8.在doMork方法中修改调用Sum方法的语句,删除最后一个实参(8),如下所示:
Console.MriteLine(Utl.Sum(2,4,6));
9.在"调试"菜单中单击"开始执行(不调试)"来生成并运行应用程序。
应用程序运行时,会显示以下消息:
Using optional parameters
12
编译器生成的代码仍然调用获取4个可选参数的版本,即使这个版本的签名和实际的方法调用并不完全匹配。要在获取可选参数和获取参数列表的两个版本之间 选择,C#编译器优先选择获取可选参数的版本。
10.按 Enter 键返回Visual Studio。
11.在dowork方法中,再次修改调用 Sum方法的语句:
Console.writeLine(Ut1l.Sum(2,4,6,8,18);
12.在"调试"菜单中单击"开始执行(不调试)"生成并运行应用程序。
应用程序运行时,会显示以下消息:
Using paraneter list
30
这次因为实参数量超过了获取可选参数的那个版本指定的数量,所以编译器生成 的代码会调用获取参数数组的版本。
13.按 Enter键返回Visual Studio

使用继承
创建派生类来继承基类的功能
使用 new,virtual和override关键字控制方法的隐藏和重写使用使用protected关键字限制继承层次结构中的可访问性将扩展方法作为继承的替代机制使用继承是面向对象编程的关键概念。如果不同的类有通用的功能,而且这些类相互之间 的关系很清晰,那么利用继承能避免大量重复性工作。这些类或许是同一种类型的不同的类,每个都有与众不同的功能。例如,工厂的主管和工人都是"员工"。如果写程序来模拟这家工厂,如何定义主管和工人的共性和个性呢?例如,他们都有员工识别号,但主管 担负的职责和工人不同,并执行不同的任务。这正是继承可以大显身手的时候。
什么是继承
随便问几个人他们如何理解"继承",往往会得到不同且相互冲突的答案。这部分是由于"继承"一词本身就存在歧义。如果某人在遗嘱中将什么东西留给你,就说你继承了他的财产。类似地,我们说人部分基因遗传自母亲,部分遗传自父亲。但这两种"继承" 都和程序设计中的继承没有多大关系。
程序设计中的继承问题就是分类问题——继承反映类和类的关系。例如,我们学过生  物,知道马和鲸都属于哺乳动物。这两种动物具有哺乳动物的共性(都能呼吸空气,都能哺 乳,都是温血的…·).但两者还有自己的个性(马有蹄子,鲸有鳍状肢和尾片)。那么,如何在程序中对马和鲸进行建模?一个办法是创建两个不同的类,一个叫 Horse(马),另一个叫whale(鲸)。每个类都可以实现那种哺乳动物特有的行为,例如为Horse 实现Trot(跑),为whale类实现Swim(游)。那么,如何处理马和鲸通用的行为呢?例如,  Breathe(呼吸)和 SuckleYoung(哺乳)是哺乳动物的共性。当然能在刚才两个类中添加具有上述名称的重复方法,但这无疑会使维护成为噩梦,尤其是考虑到以后可能还要建模其他 类型的哺乳动物,例如 Human(人)和 Aardvark(土豚)等。
在C#中,可通过类的继承来解决这些问题。马、鲸、人和土豚都属于 Mammal(哺乳动 物)类型,所以可创建名为Mammal的类,它对所有哺乳动物的共性建模。然后,声明Horse,le,Human和Aardvark等类都从Mammal类继承。继承的类自动包含Mammal类的所有功能(Breathe、SuckleYoung等),但还可为每种具体的哺乳动物添加它独有的功能。
例如,可为Horse类声明Trot方法,为whale类声明Swim方法。如需修改一个通用方法(例如 Breathe)的工作方式,那么只需要在一个位置修改,也就是在Mammal中。

使 用 继 承
用以下语法声明一个类从另一个类继承
class DerivedClass:BaseClass
{
	...
}
DerivedClass(派生类)将从BaseClass(基类)继承,基类中的方法会成为派生类的一部分。在C#中,一个类最多只允许从一个其他的类派生;不允许从两个或者更多的类派生。但除非将 DerivedClass 声明为sealed,否则可以
使用相同的语法,从 DerivedClas 派生出更深一级的派生类。
class DerivedSubClass:DerivedClass
{
	...
}
前面描述的哺乳动物的例子中,可以像下面这样声明 Mammal 类。Breathe 和SuckleYoung是所有哺乳动物都有的功能。
class Mammal
{
	public void Breathe() //呼吸
	{
		...
	}
	public void SuckleYoung()
	{
		...
	}
}
然后可以定义每一种不同的哺乳动物,并根据需要添加额外的方法。例如:
class Horse:Mamal//定义Horse继承自Mammal
{
	...
	public void Trot()//跑
	{
			...
	}

}
class whale:Nammal//定义whale继承自内Mammal
{
	...
	public void SMdm() //游
	{
		...
	}
}
注意 C++程序员注意,不需要、也不能显式指定继承是公共、私有还是受保护,C#的继承总是隐式公共。Java程序员注意,这里使用的是冒号,而且没有使用 extends关键字。
程序中创建 Horse 对象后,可像下面这样调用Trot,Breathe和 SuckleYoung方法
Horse myorse = new Horse();
myorse. Trot();
myHorse.Breathe();
myHorse. SuckleYoung();
可用类似方式创建 whale对象,但这一次能调用的是Swim,Breathe和 SuckleYoung方法。Trot是Horse类定义的,不适用于whale。
重要提示 继承只适用于类,不适用于结构,不能定义由结构组成的继承链,也,从类或其他结构派生出一个结构。所有结构都派生自名为 System.ValueType 的抽象类。但这只是.NET Framework为"基于栈的值类型"定义通用
行为而采取的一个实现细节。不能在自己的程序中直接使用ValueType类。

复习System.Object类
Systeem.Object类是所有类的根。所有类都隐式派生自System.0bject类。所以,C#编译器会悄悄地将Nammal类重写为以下代码(自己这样写也行):
class Mamal:System.Cbject
{
	...
}
System.Object类的所有方法都沿继承链向下传递给从Mammal派生的类(如 Horse和whale)。换言之,你定义的所有类都会自动继承System.0bject类的所有功能,其中包括
ToString方法,它将 object转换成 string 以便显示。
调用基类构造器
除了继承得到的方法,派生类还自动包含来自基类的所有字段。创建对象时,这些字段通常需要初始化。通常用构造器执行这种初始化。记住,所有类都至少有一个构造器（如果你一个都没提供,编译器自动生成一个默认构造器）。
作为好的编程实践,派生类的构造器在执行初始化时,最好调用一下它的基类构造器。
为派生类定义构造器时,可用 base关键字调用基类构造器。下面是一个例子
class Nammal//Mammal是基类
{
	public Mammal(string name) //基类构造器
	{
		...
	}
	...
}
class Horse:Mammal //Horse是派生类
{
	public Horse(string name)
		: base(name) //调用Nammal(name)
	{
		...
	}
}
不在派生类构造器中显式调用基类构造器,编译器会自动插入对基类默认构造器的调用,然后才会执行派生类构造器的代码。例如,以下代码：
class Horse :Nammal
{
	public Horse(strling name)
	{
		...
	}
}
会被编译器改写为以下形式:
class Horse:Mammal
{
	public Horse(string name)
		: base()
	{
		...
	}
	...
}
如Mammal有公共默认构造器,上述代码能成功编译。但并非所有类都有公共默认构造器（记住,只有在没有写任何非默认构造器的前提下,编译器才会自动生成一个默认构造器):在这种情况下,忘记调用正确的基类构造器会造成编译时错误。
类的赋值
解释了如何声明类(class)类型的变量,以及如何使用 new 关键字创建对象。
还解释了C#的类型检查规则如何防止将一种类型的值赋给不同类型的变量。例如,根据以下 Mammal,Horse和 whale类定义,之后的代码是非法的:
class Mamal
{
	...
}
class Horse:Mammal
{
	...
}
class Whale:Mammal
{
	...
}

...
Horse myHorse = new Horse(….); 
whale myhale = myHorse; //错误-不同类型
但是完全可以将一种类型的对象赋给继承层次结构中较高位置的一个类的变量,以下语句合法:
Horse myHorse = new Horse(.); 
Yawmal myrtamal =nyH+orse; //合法。因ammal是Horse的基类
其实是很合乎逻辑的。所有 Horse(马)都是 Nammal(哺乳动物),所以可以安全地将Horse对象赋给Mammal类型的变量。继承层次结构意味着可以将一个Horse视为特殊类型的Mammal(Nammal定义了所有哺乳动物的共性),但又多了一些额外的东西,具体由添加到Horse类中的方法和字段来决定。但要注意,这样做有一个重大的限制:如果用Mammal变量引用一个Horse或whale对象,就只能访问Mammal类定义的方法和字段。Horse或whale类定义的任何额外方法和字段都不能通过 Mammal类来访问:
Horsemyorse a new Horse(…..);
Mamal myammal a myHorse
my"ammal.Breathe( //这个调用合法。,Breathe是地amal类的一部分
myamal.Trot(); //这个调用非法。Trot不是Nmal类的一部分
注意 这就解释了为什么一切都能赋给 object变量。记住,object是Systs的别名,所有类都直接或间接从 System.0bject继承.
反之则不然,不能直接将 Mammal对象赋给 Horse变量:
Namal myrammal = new myrammal(.);
Horse myorse - mNamal;//错误
这个限制表面上很奇怪,但记住虽然所有Horse都是Mammal,但并非所有Mammal对象都是Horse——例如,有的Mammal可能是whale.所以,不能直接将Nammal对象赋给Horse变量,除非先进行检查,确认该Mammal确实是Horse。这个检查是使用as或is操作符,或者通过强制类型转换来进行的。下例使用as操作符检查myNammal是否引用一个Horse,如果是,对myHorseAgain赋值后,myHorseAgain将引用那个Horse对象;如果myMammal引用的是其他类型的Mammal,as 操作符就会返回 null。
Horse myHorse - new Horse(...);
Namal my的amal morse; //myammal 引用一个Horse
..·
myHorAgain = mammal as Horse;//通过-myamal确实是一个Horse
Whale mywhale = new whale();
myamal = mywhale;
...
myorseAgain = myramal as Horse; //返回null-myrammal不是Horse 而是whale
声明新方法
编程最困难的地方之一是为标识符想一个独特的、有意义的名称。为继承层次结构中的类定义方法时,选择的方法名迟早会与层次结构中较高的一个类中的名称重复。如果基类和派生类声明了两个具有相同签名的方法,编译时会显示一个警告。
注意 方法签名由方法名、参数数量和参数类型共同决定,方法的返回类型不计入签名,两个同名方法如果获取相同的参数列表,就说它们有相同的签名,即使它们的返回类型不同.
派生类中的方法会屏蔽（或隐藏)基类具有相同签名的方法。例如,编译以下代码时,编译器将显示警告消息,指出 Horse.Talk方法隐藏了继承的Mammal.Talk方法:
class Nammal
{
	...
	public vold Talk() |//假定所有响乳动物都能talk
	{
		...
	}
}
class Horse:Mammal
{
	...
	public void Talk() //马的talk方式有别于其他哺乳动物!
	{
		...
	}
}
虽然代码能编译并运行,但应该严肃对待该警告。如果另一个类从Horse派生,并调用Talk方法,它希望调用的可能是Mammal类实现的Talk,但该方法被Horse中的Talk隐藏了,所以实际调用的是Horse.Talk。大多数时候,像这样的巧合会成为混乱之源。应重命名方法以免冲突。但如果确实希望两个方法具有相同签名,从而隐藏 Mammal.Talk方法,可明确使用 new关键字消除警告:
class Namma
{
	...
	public vod Talk()
	{
		...
	}
}
class Horse:Nammal
{
	...
	new public void Talk()
	{
		...
	}
}
像这样使用 new 关键字,隐藏仍会发生。它唯一的作用就是关闭警报。事实上,new关键字的意思是说:"我知道自己在干什么,不要再烦我了!"

声明虚方法
有时想隐藏方法在基类中的实现。以System.0bject 的ToString方法为例。方法的目的是将对象转换成字符串形式。由于很有用,所以设计者把它作为System.Object的成员,自动提供给所有类。但System.0bject实现的ToString怎么知道如何将派生类的实例换成字符串呢?派生类可能包含任意数量的字段,这些字段包含的值应该是字符串的一部分。答案是System.0bject中实现的ToString确实过于简单。它唯一能做的就是将对象转换成其类型名称字符串,例如"Mammal"或"Horse"。这种转换显然没什么用处。那么,为什么要提供一个没用的方法呢?为了理解这个问题,我们需要多加思考。
显然,ToString是一个很好的概念,所有类都应当提供一个方法将对象转换成字符串,以便显示或调试。只是实现时需要注意。事实上,根本就不应该调用由System.Object定义的ToString方法,它只是一个"占位符"。正确做法是应在自己定义的每个类中都提供自己的ToString方法,重写System.Object中的默认实现。System.0bject提供的版本只是为了预防万一,因为可能有某个类没有实现自己的ToString方法。这样一来,就可放心大胆地在所有对象上调用ToString,,它肯定会返回一个有内容的字符串。故意设计成要被重写的方法称为虚(vitual)方法。"重写方法""和"隐藏方法"的区别现在应该很明显了。重写是提供同一个方法的不同实现,这些方法有关系,因为都旨在完成相同的任务,只是不同的类用不同的方式,。但隐藏是指方法被替换成另一个方法,方法通常没关系,而且可能执行完全不同的任务。对方法进行重写是有用的编程概念;而如果方法被隐藏,则意味着可能发生了一处编程错误(除非你加上new强调自己没错)。虚方法用virtual关键字标记。例如,以下是System.0bject的ToString方法定义:
namespace Systen
{
	class bject
	{
		public virtual string Tostring()
		{
			...
		}
		...
	}
	...
}
注意 Java开发人员注意,C#方法默认非虚。
声明重写方法
派生类用override关键字重写基类的虚方法,从而提供该方法的另一个实现,如下例所示:
class Horse:Mammal
{
	...
	public override string ToString()
	{
		...
	}
}
在派生类中,方法的新实现可用base关键字调用方法的基类版本,如下所示:
public overridestring ToString()
{
	string temp = base.ToString();
	...
}
使用virtual和 override关键字声明多态性的方法时(参见稍后的补充内容"虚方法和多态性"),必须遵守以下重要规则。
虚方法不能私有。这种方法目的就是通过继承向其他类公开。类似地,重写方法不能私有,因为类不能改变它继承的方法的保护级别。但重写方法可用protected关键字实现所谓的"受保护"私密性。
虚方法和重写方法的签名必须完全一致。必须具有相同的名称和参数类型/数量除签名一致,两个方法还必须返回相同的类型。
只能重写虚方法。对基类的非虚方法进行重写会发生编译时错误。该设计很合理,应由基类设计者决定方法是否能被重写如派生类不用 override 关键字声明方法,就不是重写基类方法,而是隐藏方法。
也就是说,成为和基类方法完全无关的另一个方法,该方法只是恰巧与基类方法同名。如前所述,这会造成编译时显示警告称该方法会隐藏继承的同名方法。可用new关键字消除警告。
重写方法隐式成为虚方法,可在派生类中被重写。但不允许用 virtual关键字将重写方法显式声明为虚方法。

虚方法和多态性
虚方法允许调用同一方法的不同版本,具体取决于运行时动态确定的对象类型。下例是之前描述的Mammal(哺乳动物)层次结构的一个变体：
class Mammal
{
	...
	public virtual string GetTypeName()
	{
		return"This is a mammal";//这是骑乳动物
	}
}
class Horse :Mammal
{
	...
	public override string GetTypeName()
	{
		return "This is a horse";//这是马
	}
}
class hale:Mammal
{
	...
	public override string GetTypeName()
	{
		return "This is a whale";//这是鲸
	}
}
class Aardvark:Mammal
{
	...
}
两个地方需要注意:第一,Horse和 whale类的GetTypeName方法使用了override
关健字;第二,Aardvark类没有GetTypeName方法。
现在研究以下代码块:
Mammal myNammal;
Horse myHorse= new Horse(..);
whale mywhale - new whale(...);
Aardvark myAardvark = new Aardvark(..)
myMammal= myHorse;
Console. MriteLine(myNammal1.GetTypeName())
myNammal= myhale;
Console.MriteLine(myMammal.GetTypeName())
myMammal myAardvark;
Console.MriteLine(myNammal.GetTypeName());
三个不同的 Console.MriteLine 语句分别输出什么?从表面看,它们都会打印"This is a mammal",因为每个语句都在myammal变量上调用GetTypeName方法,而myammal是一个Mammal.但在第一种情况下,myNammal实际是对一个 Horse 的引用(之所以允许将一个Horse赋给Mammal变量,是因为Horse类派生自Mammal类——所有Horse都是Mammal).由于GetTypeName被定义成虚方法,所以"运行时"判断应调用Horse.GetTypeName方法,因此语句实际打印"This is a horse".同样的逻辑也适用于第二个 Console.MriteLine 语句,它打印消息"This is a whale".第三个语句在Aardvark对象上调用Console.r生teLine.但由于Aardvark类没有GetTypeName方法,
所以会调用 Mammal类的默认方法,打印字符串"This is a mammal"。
写法一样的语句,却能依据上下文调用不同的方法,这称为"多态性"（Polymorphism)。该词源自希腊文.polys指 many,much,而morphe指 form,shape.所以字面意思就是"多种形态"或者"多型"(many fom)。

理解受保护的访问
publiic和 private关键字代表两种极端的可访问性:类的公共(public)字段和方法可由每个人访问,而类的私有(private)字段和方法只能由类自身访问。
如果只是孤立地考察一个类,这两种极端的访问完全够用了。但有经验的面向对象程序员会告诉你,孤立的类解决不了复杂问题!继承是将不同类联系到一起的重要方式,在派生类及其基类之间,明显存在一种特殊而紧密的关系。经常都要允许基类的派生类访问基类的部分成员,同时阻止不属于该继承层次结构的类访问。这时就可使用protected《受保护)关键字标记成员。其工作方式如下所示:
●如果类 A派生自类B,就能访问B的受保护成员。也就是说,在派生类A中,B的受保护成员实际是公共的。
●如果类A不从类 B派生,就不能访问B的受保护成员。也就是说,在A中,B的受保护成员实际是私有的
C#允许程序员自由地将方法和字段声明为受保护。但大多数面向对象编程指南都建议尽量使用私有字段,只在绝对必要时才放宽限制。公共字段破坏了封装性,因为类的所有用户都能直接地、不受限制地访问字段。受保护字段虽然维持了封装性(类的用户无法访问受保护字段),但由于受保护字段在派生类中实际就是公共字段,所以这个封装性仍然可能被派生类破坏。
注意 不仅派生类能访问受保护的基类成员,派生类的派生类也能,受保护的基类成员在继承层次结构的任何派生类中都能访问。
一下练习定义了一个简单的类层次结构来建模不同类型的交通工具（(vehicle)。要定义名为Vehicle的基类和名为Adrplane(飞机)和Car(汽车)的派生类。要在Vehicle类中定义两个通用方法:StartEngine(发动)和 StopEngine(熄火)。要在两个派生类中添加它们特有的方法。最后要为Vehicle类添加虚方法Drive(驾驶),并在两个派生类中重写该方法的默认实现。
创建类层次结构
1.如Microsoft Visual Studio2017尚未启动,请启动
2.打开 Vehicles 解决方案,它位于"文档"文件夹下的Microsoft PressVCSBS\apter 12\Vehicles 子文件夹。
Vehicles 项目包含Program.cs 文件,它定义了Program类,其中含有以前练习中出现过的Main和dokork 方法。
3.在解决方案资源管理器中右击Vehicles 项目,选择"添加"I"类"来打开"添加新项-Vehicles"对话相
4.在"添加新项-Vehicles"对话框中,验证中间窗格选定了"类"模板。在"名称"文本框中输入Vehicle.cs,单击"添加"。
随后会创建Vehiclecs,并把它添加到项目。"代码和文本编辑器"窗口会显示边个文件的内容。文件中包含空白的Vehicle类定义。
为Vehicle类添加StartEngine和 StopEngine方法,如以下加粗的代码所示:
class Vehicle
{
	public void StartEngine(string noiseToNakekwhenstarting)
	{
		Console.MriteLine($"Starting engine:{noiseToakewhenStarting}");
	}
	 public void StopEngine(string noiseToNakewhenstopping)
	 {
	 	Console.MriteLine($"Stopping engine:(noiseTotakehenstopping)");
	 }
}
Vehicle 的所有派生类都会继承这两个方法。noiseTOMakekhenStarting(发动时的噪音)和 noiseToakekwhenStopping(熄火时的噪音)参数的值对于每种类型的交通工具来说都不同,这有助于以后区分发动和媳火的是哪种交通工具。
6.在"项目"菜单中选择"添加类"命令。
7.在"名称"文本框中输入Airplane.cs,单击"添加"。
随后会在项目中添加一个新文件,其中包含名为Airplane的空白类。该文件的内容会在"代码和文本编辑器"窗口中出现。
8.在"代码和文本编辑器"窗口中修改 Adrplane类的定义,指定它从 Vehicle类派生,如加粗部分所示:
class Airplane:Vehicle
{
}
9.在 Airplane类中添加 TakeOff（(起飞)和Land(着陆)方法,如加粗的代码所示:
class Airplane:Vehicle
{
	public void TakeOff()
	{
		Console.whriteLine("Takding off");
	}
public vwoid Land()
{
Console.sriteline("Landing");
}
10.在"项目"菜单中选择"添加类"命令。
再次出现"添加新项-Vchiclcs"对话框
11.在"名称"框中输入 Car,cs,单击"添加"。
会在项目中添加一个新文件,其中包含名为Car的空白类。该文件的内容会
在"代码和文本编辑器"窗口中出现。
12.在"代码和文本编辑器"窗口中修改Car类的定义,指定它从Vehicle类派生,
如加粗部分所示
class Car:Vehicle
{
}
13.为Car类添加 Accelerate(加速）和Brake(刹车)方法,如加粗的代码所示:
class Car:Vehicle
{
	public void Accelerate()
	{
		Console.writeLine("Accelerating");
	}
	public void Brake()
	{
		Console.Mriteline("Braking");
	}
}
14.在"代码和文本编辑器"窗口中显示Vehicle.cs 文件的内容。
15.为 Vehicle类添加名为 Drive 的虚方法(所有交通工具都可以"驾驶"),如以下
加粗的代码所示:
class Vehicle
{
...
public virtual void Drive()
{
	Console.writeLine("Default implementation of the Drive method");
}
}
16.在"代码和文本编辑器"窗口中显示 Program.cs文件。
17.在dowork方法中删除//TOD0:注释,创建 Airplane类的实例,模拟一次飞行为
测试该方法,如下所:
static vold dolbork()
{
Console.MriteLine("Journey by adrplane:");
Airplane myPlane a new Adrplane();
myPlane.StartEngine("Contact");
myPlane.TakeOff();
myPlane.Drive();
myPlane.Land();
myPlane.StopEngine("whirr");
}
18.在doMork方法刚才输入的代码之后,添加以下加粗的语句来创建Car类的实例并
测试其方法。
static void dowork()
{
	...
	Console.MriteLine();
	Console.writeLine("Journey by car:")
	 CarmyCar = new Car();
	myCar.StartEngine("Brm brm");
	myCar.Accelerate();
	myCar.Drive();
	myCar.Brake();
	myCar.StopEngine("Phut phut");
}
19.在"调试"菜单中选择"开始执行(不调试)"命令验证程序通过输出消息来模拟驾驶飞机和汽车的不同阶段,注意,两种交通方式（驾驶飞机和汽车)都会调用 Drive 这个虚方法的默认实现,因为两个类目前都没有重写这个方法。
20.按 Enter键关闭应用程序,返回Visual Studio 2017
21.在"代码和文本编辑器"窗口中显示Airplane类。在Airplane类中重写Driv方法,如下所示
class Adrplane:Vehicle
{
	...
	public override void Drive()
	{
		console.writeLine("Flying");
	}

}	
注意 输入override后,"智能感知"自动显示可用的虚方法。从列表中选择 Drive方法,Visual Studio 会自动插入方法主体,并自动插入语句来调用base.Drive方法,如果发生这种情况,请删除自动添加的语句,本练习不需要.
22.在"代码和文本编辑器"中显示Car类。在Car类中重写Drive方法,如下所示
class Car:Vehdcle
{
	...
	public override void Drive()
	{
	Console.swriteLine("?oring");
	}
}
23.在"调试"菜单中选择 "开始执行(不调试)"命令。
注意,在控制台窗口中,在应用程序调用Drive方法时,Aiplane对象现在显消息Flying,而Car对象显示消息Motoring.
24.按 Enter键关闭应用程序,返回Visual Studio 2017。
25.在"代码和文本编辑器"中显示 Program.cs 文件。
26.将以下加粗的语句添加到 doMork方法末尾:
statatic void doNork()
{
...
Console.Writeline("\nTasting polymorphism");//测试多态性
Vehicle v = myCar;
v= myPlane;
V.Drive():
}
上述代码测试虚方法Drive的多态性。代码让一个Vehicle变量引用一个Car对象(这是安全的,因为所有Car都是Vvehicle),然后使用Vehicle变量调用Drive方法。最后两个语句让Vehicle变量引用一个Airplane对象,同样调用Drive。
27.在"调试"菜单中选择"开始执行(不调试)"命令。
如下图所示,在控制台窗口中,前面显示的消息和以前一样,关键是最后几行字:
Testing polymorphism
Notoring
Flying
Drive是虚方法,所以"运行时"(而不是编译器)会动态判断应该调用哪个版本的Drive,这由变量引用的真实对象类型决定。第一种情况,Vehicle变量引用一个Car,所以调用Car.Drive方法。第二种情况,Vehicle 变量引用一个 Airplane,所以调用Airplane.Drive方法。
28.按 Enter键关闭应用程序,返回Visual Studio 2017。

创建扩展方法
继承很强大,允许从一个类派生出另一个类来扩展类的功能。但有时为了添加新的行为,继承不一定是最佳方案,尤其是需要快速扩展类型,又不想影响现有代码的时候。
例如,假定要为int 类型添加新功能,比如一个名为 Negate 的方法,它返回当前整相反数。我知道可以使用一元求反操作符(-)来做这件事情,但请先不要管它。为此, 一个办法是定义新类型 NegInt32,让它从 System.Int32派生(int是 System.Int32的别名),在派生类中添加 Negate方法:
class Negint32:System.Int32 //别这样写!
{
	public int Negate()
	{
		...
	}
}
NegInt32理论上应继承 System.Int32类型的所有功能,并添加自己的 Negate方法。
但有两个原因造成这样行不通:
新方法只适合 NegInt32类型,要把它用于现有的int 变量,就必须将每个int变量的定义修改成NegInt32类型。System.Int32是结构而不是类,结构不能继承。这时就该扩展方法出场了。扩展方法允许添加静态方法来扩展现有的类型(无论类还是结构)。引用被扩展类型的数据,即可调用扩展方法。
扩展方法在一个静态类中定义,被扩展类型必须是方法的第一个参数,而且必须附加this 关键字。下例展示了如何为int类型实现 Negate扩展方法
static class Ut1l
{
	public static int Negate(this int i)
	{
		retun-1;
	}
}
语法看起来有点奇怪,但请记住:正是由于为Negate方法的参数附加了this关键字作为前缀,才表明这是一个扩展方法;另外,this修饰int,表明扩展的是int类型。使用扩展方法只需让Ut1l类进入作用域（如有必要,添加using语句指定Util类所在的命名空间。也可用 using static语句直接指定Util类,参见7.5.4节),然后就可以简单地使用点记号法来引用方法,如下所示:
int x · 591;
Console.writeLine($"x.MNegate{x.MNegate())");
注意,调用Negate方法时根本不需要引用Uil类。C#编译器自动检测当前在作用域中的所有静态类,找出为给定类型定义的所有扩展方法。当然也可以调用Uti1.Negate方法,将int值作为参数传递,这和以前用的普通语法相同。但这样便丧失了将方法定义成扩展方法的意义:
int x 591;
Console.MwriteLine($"x.Negate {Uil.Negate(x)}");
以下练习将为int类型添加扩展方法,允许将int 变量包含的值从十进制(base10）转换成其他进制.

创建扩展方法
1.在Visual Studio2017中打开 ExtensionMethod解决方案,它位于"文档"文件夹下的Microsoft Press\VCSBSIChapter 12、ExtensionMethod子文件夹。
2.在"代码和文本编辑器"中打开Utilcs 文件。
文件包含静态类 Ut1,该类位于 Extensions命名空间,目前空白,只有一条TO00:注释。记住,只能在静态类中定义扩展方法。
3.删除注释并在 Util类中声明公共静态方法ConvertToBase。方法获取两个参数:
一个是int参数1,附加 this关键字作为前缀,表明该方法是int类型的扩展方法。第二个参数是普通的int参数,名为 baseToConvertTo.方法的作用是将i中的值转换成由baseToConvertTo指定的进制。方法应返回一个int,其中包含
转换好的值。
ConvertToBase方法现在应该像下面这样
static class Util
{
	public static int ComvertToBase(this int i,int baseToConvertTo)
	{
	}
}
4.在ConvertToBase方法中添加if语句检查 baseToConvertTo参数的值是否在2～16之间。超出该范围,本练习的算法就不能可靠工作了。如 baseToConvertTo的值超出范围,就抛出 ArgumentException异常并传递恰当的消息。
ConvertToBase 方法现在应该像下面这样:
publlc static int CconvertToease(this int i,int baseToCovertTo)
{
	if(baseTocovertTo < 2 || baseTocovertTo >19)
throw new ArgumentException("Value cannot be converted to base"
baseToConvertTo. ToString());
}
5.在ConvertToBase方法中,在抛出 ArgumentException 的语句后添加以下加粗的语句。这些代码实现了一个已知的算法将数字从十进制转换成不同的进制。
public static int ConvertToBase(this int i,int baseToComvertTo)
{
	...
	int result=6; 
	int iterations 6; 
	do
}
	int nextDigit a iX baseToCovertfo;	
	i/= baseToConvert;
	result += nextDigit *(int)ath.Pow(18,iterations); 
	iterations++;
}
	while(1 l=); 
	returm result;
}
6.在"代码和文本编辑器"中显示Programcs文件。
7.在文件顶部的usingSystem;语句后面添加以下语句:
using Extenslons;
该语句使包含 Util类的命名空间进入作用域。不添加该语句,Program.cs 文件中就"看不见"扩展方法ConvertToBase,
8.在 Program类的doMork方法中添加以下加粗的语句来替换//T000:注释:
static void doiork()
{
	int X = 591;
	for(int 1= 2;i<s 18; i++)
	{
		Console.writeLine($"(x)in base (1}》is (x.ConvertToBase(1))"");
	}

}
上述代码创建int变量x并设为值591(可指定想测试的任意整数值)。然后,代码用for循环打印值591的2～16进制表示。注意,在Console.MriteLine语句中,一旦键入×之后的句点(.),"智能感知"会自动列出扩展方法ConvertToBase。
9.在"调试"菜单中选择"开始执行(不调试)"命令。验证程序会显示591在不同进制中的表示
10.按Enter键关闭程序并返回Visual Studio 2017。

创建接口和定义抽象类
定义接口来规定方法的签名和返回类型
在结构或类中实现接口
通过接口引用类
在抽象类中捕捉通用的实现细节
使用sealed关键字声明一个类不能派生出新类
从类继承是很强大的机制,但继承真正强大之处是能从接口继承。接口不含任何代码或数据;它只是规定从接口继承的类必须提供哪些方法和属性。使用接口,方法的名称/签名可完全独立于方法的具体实现。
抽象类在许多方面都和接口相似,只是允许包含代码和数据。但可将抽象类的某些方法指定为虚方法,要求从抽象类继承的类必须以自己的方式实现这些方法。抽象类经常与接口配合使用,它们联合起来提供了一项关键性的技术,允许构建可扩展的编程框架。
理解接口
假定要定义一个新类来存储对象集合（有点儿像数组)。但和使用数组不同,要提供名为 RetrieveInOrder的方法,允许应用程序根据集合中的对象类型来顺序获取对象。(普通数组只允许遍历其内容,默认按索引获取数组元素。)例如,假定集合容纳了字母/数字对象(比如字符串）,集合应根据计算机的排序规则对对象进行排序。如容纳的是数值对象(比如整数),集合应根据数字顺序对对象进行排序。
定义集合类时不想限制它能容纳的对象类型(对象甚至可以是类或结构类型),所以定义时并不知道如何对对象进行排序。现在的问题是,如何提供一个方法,对定义集合类时不知道类型的对象进行排序?从表面看,这个问题类似于第12章描述的ToString问题,可通过声明一个能由派生类重写的虚方法来解决。但目前的情况并非如此。在集合类和它容纳的对象之间,通常不存在任何形式的继承关系,所以虚方法不好用。仔细思考一下,便知道现在的问题是:集合中对象的排序方式应取决于对象本身的类型,而不是取决于集合。所以,合理方案是规定集合中所有对象都必须提供一个可由集合的RetrieveInOrder方法调用的方法(例如下面的 CompareTo方法),以实现对象的相互比较,:
int Comparefo(bject obj)
{
	//如果this 实例等于cbj,就返回0
	/如果this 实例小于obj.就返回<0
	//如果this 实例大于obj,就返回>0	
}
可为允许出现在集合中的对象定义接口,并在接口中包含 CompareTo 方法。这样接口就相当于一份协议(contract)。实现了接口(签订了协议)的类必然包含接口规定的全部方法。该机制保证能为集合中的所有对象调用CompareTo方法,并对其进行排序。使用接口,可以真正地将"what"（有什么)和"how"(怎么做)区分开。接口指定"有什么",也就是方法的名称、返回类型和参数。至于具体"怎么做",或者说方法具体如何实现,则不是接口所关心的。接口描述了类提供的功能,但不描述功能如何实现。

定义接口
定义接口和定义类相似,只是使用interface 而不是class关键字。在接口中按照与类和结构一样的方式声明方法,只是不允许指定任何访问修饰符(public,private 和protected都不行)。另外,接口中的方法是没有实现的,它们只是声明。实现接口的所有类型都必须提供自己的实现。所以,方法主体被替换成一个分号。下面是一个例子:
interface IComparable
{
	int Ccomparefo(object obj);
}
提示 Microsoft.NET Framework文档建议接口名称以大写字母I开头。这个约定是匈 牙利记号法在C#中的最后一处残余。顺便说一句,System命名空间已经像上述代码描述的那样定义了IComparable接口。
接口不含任何数据;不可以向接口添加字段(私有的也不行)。

实现接口
为了实现接口,需要声明类或结构从接口继承,并实现接口指定的全部方法。虽然语法一样,而且如同本章稍后会讲到的那样,语义有继承的大量印记,但这并不是真正的"继承"。注意,虽然不能从结构派生,但结构是可以实现接口的(从接口"继承")。
假如,假定要定义Nammal(哺乳动物)层次结构,但要求所有陆上哺乳动物都提供名为NmberOfLegs(腿数)的方法,返回一个int值来指出该哺乳动物有几条腿。（海洋哺乳动物不实现该接口。)为此,可定义一个ILandBound(land bound是指陆上)接口来包含该方法:
interface ILandBound
{
	int NumberOfLegs();
}
然后,可以在 Horse(马)类中实现该接口,具体就是从接口继承,并为接口定义的所有方法提供实现(本例只有一个NumberOfLegs方法):
class Horse :ILandBound
{
	...
	public int NumberLegs()
	{
		return 4;//马有4条腿
	}

}
实现接口时必须保证每个方法都完全匹配对应的接口方法,具体遵循以下几个规则。方法名和返回类型完全匹配。所有参数（包括 ref和 out关键字修饰符)都完全匹配。用于实现接口的所有方法都必须具有public可访问性。但如果使用显式接口实现（即实现时附加接口名前缀,稍后会解释),则不应该为方法添加访问修饰符。接口的定义和实现存在任何差异,类都无法编译。
提示 Microsoft VisualStudio IDE能帮你实现接口方法."实现接口"向导为接口定)的每个方法生成存根,用适当的代码填充存根就可以了。稍后在练习中解释。一个类可在从一个类继承的同时实现接口。注意,C#不像Java那样用特定关键字区分基类和接口。相反,C#按位置区分。首先写基类名,再写逗号,最后写接口名。例如,下例定义 Horse从Mammal继承,同时实现ILandBound接口:
interface ILandBound
{
	...
}
class Nammal
{
	...
}
class Horse:Mammal,ILandBound
{
	...
}
注意 一个接口(InterfaceA)可从另一个接口(InterfaceB)继承。技术上说这应该叫接口扩展而不是继承.在本例中,实现 InterfaceA的类或结构必须实现两个接口所规定的方法。
通过接口引用类和基类变量能引用派生类对象一样,接口变量也能引用实现了该接口的类的对象。例如,ILandBound变量能引用 Horse对象,如下所示：
Horse myHorse = new Horse(……); 
ILandBound orse a myrorse;//合法
能这样写是因为所有马都是陆上哺乳动物。反之则不然,不能直接将 ILandBound 对象赋给 Horse变量,除非先进行强制类型转换,验证它确实引用一个Horse对象,而不是其他恰好实现了ILandBound接口的类。
通过接口来引用对象是一项相当有用的技术。因为能由此定义方法来获取不同类型的实参——只要类型实现了指定的接口。例如,以下 FindLandSpeed方法可获取任何实现了
ILandBound接口的实参：
int FindLandSpeed(ILandBound landBoundNamal)
{
	...
}
用is操作符验证对象是不是实现了指定接口的一个类的实例。刚开始用该操作符它判断对象是否具有指定类型。除了适用于类和结构,它还适用于接口。例如,以下代码验证myHorse变量是否实现了ILandBound接口,是就把它赋给一个
ILandBound 变量。
if(myorse is ILandBound)
{
	ILandBound iLandBoundAnimal =myorstHorse;
}
注意,通过接口引用对象时,只能调用通过该接口可见的方法。

使用多个接口
一个类最多只能有一个基类,但可以实现数量不限的接口。类必须实现这些接口规定 的所有方法。结构或类要实现的多个接口必须以逗号分隔。如果还要从一个基类继承,接口必须排列在基类之后。例如,假定在IGrazable(草食)接口中包含了ChewGrass(咀嚼草)方法,规定所有草食类动物都要实现自己的ChewGrass方法,那么可以像下面这样定义Horse类,它表明Mammal是基类,而ILandBound和IGrazable是Horse要实现的两个接口。
class Horse:Mamal,ILandBound,IGrazable
{
	...
}
显式实现接口
前面例子是隐式实现接口。注意 ILandBound 接口和Horse类的代码(如下所示),虽然 Horse类实现了ILandBound接口,但在Horse类的NumberOfLegs方法的实现中,没有任何地方说它是ILandBound接口的一部分。
interface ILandBound
{
	int NmberOfLegs();
}
class Horse:ILandBound
{
	...
	public int NmberOflegs()
	{
		returm 4;//马有4条腿
	}

}
这在简单情况下不成问题,但如果Horse类实现了多个接口呢?没有什么能防止多个接口指定同名方法(虽然这些方法可能有不同语义)。例如,假定要实现马车运输系统。一次长途旅行可能被分成好几段,或者称为几"站"(legs)"。要跟踪每匹马拉马车跑了几"站",可以像下面这样定义接口:
interface IJourney
{
	int NumberOfLegs();//跑的站点(leg)数
}
现在,如果在Horse类中实现该接口,就会发生一个有趣的问题:
class Horse:ILandBound,IJourne
{
	...
	public int NmberOfLegs()
	{
		return 4;
	}
}
代码合法,但到底是马有4条腿,还是它拉了4站呢?在C#看来,两者都是成立的!默认情况下,C#不区分方法实现的哪个接口,所以实际是用一个方法实现了两个接口。为了解决该问题,并区分哪个方法实现的是哪个接口,应该显式实现接口。为此,要在实现时指明方法从属于哪个接口,如下所示:
class Horse:ILandBound, IJourney
{
	...
	int ILandBound.NumberOfLegs()
	{
		retum 4;//马有4条腿
	}
	int Dourney.NumberOflegs()
	{
		returm 3;//拉了3站
	}
}
现在可以清楚地定义马有4条腿,马拉了3站路。除了为方法名附加接口名前缀,上述语法还有一个容易被忽视的变化:方法去掉了public标记。如方法是显式接口实现的一部分,就不能为方法指定访问修饰符。这造成另一个有趣的问题。在代码中创建一个Horse变量,两个NumberOfLegs方法都不能通过该变量来调用,因为它们都不可见。两个方法对于Horse类来说是私有的。该设计是合理的。如方法能通过 Horse类访问,那么以下代码会调用哪一个——ILandBound 接口的?还是IJourney接口的?
Horse horse a new Horse();
...
int legs= horse.NmberOfLegs();//该语句无法编译
那么,怎么访问这些方法呢?答案是通过恰当的接口来引用 Horse对象,如下所示
Horse horse = new Horse();
...
IJourney journeyHorse= horse;
Int legsInJourney a joumeyorse.NumberOfLegs(); 
ILandBound landBoundHorse = horse;
int legsontorse = landBoundPorse.NMmberOfLegs();
建议尽量显式实现接口。
接口的限制，牢记接口永远不包含任何实现。这意味着以下几点限制。
不能在接口中定义任何字段,包括静态字段。字段本质上是类或结构的实现细节。
不能在接口中定义任何构造器。构造器也是类或结构的实现细节。
不能在接口中定义任何析构器。析构器包含用于析构(销毁)对象实例的语句,
不能为任何方法指定访问修饰符。接口所有方法都隐式为公共方法。
不能在接口中嵌套任何类型(例如枚举、结构、类或其他接口)。
虽然一个接口能从另一个接口继承,但不允许从结构或类继承。结构和类含有实现;如允许接口从它们继承,就会继承实现,

定义和使用接口
以下联系将定义和实现两个接口,它们是一个简单的绘图软件包的一部分。接口名为IDraw和IColor,要定义实现这两个接口的类。每个类都定义了能在窗体的一个画布上描绘的形状。(画布是允许在屏幕上画线、文本和形状的一种控件。)
IDraw接口定义了以下两个方法SetLocation 允许指定形状在画布上的XY坐标。Draw 在SetLocation方法指定的位置实际描绘形状。
IColor接口定义了以下方法SetColor允许指定形状的颜色。形状在画布上描绘时,会以这种颜色呈现定义IDraw和IColor接口
1.如 Microsoft Visual Studio2017尚未启动,请启动
2. 打开 Drawing解决方案,它位于"文档"文件夹下的MicrosofPressVCSBS\Chapter 13\Drawing子文件夹。
 Drawing项目是图形应用程序,包含名为DrawingPad的窗体。窗体中包含画布控件 drawingCanvas。将用这个窗体和画布测试代码。
3. 在解决方案资源管理器中选择Drawing项目.从"项目"菜单中选择"添加新项"。随后会出现"添加新项-Drawing"对话框。
4. 在"添加新项-Drawing"对话框左侧窗格中单击VisualC4,再单击"代码"。在中间窗格单击"接口"模板。在"名称"文本框中输入IDraw.cs,单击"添加"。ViualStudio会创建IDraw.cs文件并把它添加到项目。"代码和文本编辑器"会
打开IDraw.cs 文件,它现在的代码如下:
using System;
using SystemCollections.Generi
using System.Linq;
using System.Text;
using System.Threading.Tasks;
namespace  Drawding
{
	interface IDraw
	{
	}
}
5.在IDraw.cs 文件顶部的列表中添加以下 using指令:
using windos.U.Xaml.Controls;
接口中要引用Canvas(画布)类。对于通用Windows 平台(UWP)应用,该类在windowS.UI.Xaml.Controls命名空间
6.将以下加粗的方法声明添加到IDraw 接口:
interface IDraM
{
	vold SetLocation(int xCoord,int yCoord);
	void Dra/(Canvas canvas);
}
7.再次选择"项目"|"添加新项"。
8.在"添加新项-Drawing"对话框中间窗格单击"接口"模板。在"名称"框中输入IColor.es,单击"添加"。
Visual Studio 创建IColor.cs 文件并把它添加到项目。"代码和文本编辑器"会打开IColor.cs 文件。 
9.在IColor.cs 文件顶部的列表中添加以下using指令:
using kdindos.UI;
接口中要引用Color类,对于UWP应用,该类在Mindows.UI命名空间。
10.将以下加粗的方法声明添加到IColor接口:
interface IColor
{
	void Setcolor(color color);
}
现在定义好 IDraw 和 IColor 接口。下一步是创建一些类来实现它们。以下练习将创建形状类Square(正方形)和Circle(（圆)来实现两个接口。
创建 Square和Circle类来实现接口
1.选择"项目"|"添加类"
2. 在"添加新项-Drawing"对话框中,验证中间窗格已选定了"类"模板。在"名称"文本框中输入 Square.cs,单击"添加"。
Visual Studio 会创建 Square cs 文件并在"代码和文本编辑器"中显示。
3.在 Square.cs文件顶部的列表中添加以下 using指令:
using Mndows.UI; 
using wdindows.Ur.Xaml.eda;
using Mindows.UI.Xaml.Shapes;
using wMndows.UI.Xam.Controls;
4.修改 Square类定义,使它实现IDraw和IColor接口,如以下加粗部分所示:
class Square :DraM,IColor
{
}
5.将以下加粗的私有变量添加到Square类。
class Square:IDraw,Iolor
{
	privateint sideLength;
	private int locX = 8,locY = ; 
	private Rectangle rect= null;
}
这些变量容纳Square对象在画布上的位置和大小。UWP应用的Rectangle类在
Windows.UI.Xaml.Shapes命名空间。将用该类画正方形(square)。
6.在Suqre类中添加以下加粗构造器来初始化sideLength字段,指定正方形边长。
class Square:IDraw,IColor
{
	...
	public Square(int sideLength)
	{
		this.sideLength = sideLength;
	}
}
7.在Square类定义中,鼠标移动到IDraw接口上方。点击灯泡按钮,在上下文菜单
中点击"显式实现接口"。
随后,Visual Studio 为 IDraw 接口中的方法生成默认实现。当然,愿意的话也可
以在 Square类中手动添加方法。下面是Visual Studio 生成的代码:
void IDraw. SetLocation(int xCoord, int yCoord)
{
	throw new NotImplementedException();
}
void IDraw.Dram(Canvas canvas)
{
	throw new NotImplementedException();
}
每个方法默认都是抛出NotImplementedException异常。要用自己的代码替换。
8.在IDraw.SetLocation方法中,将现有代码替换成以下加粗的语句。它们将参数
值存储到 Squre对象的locX 和locY字段。
void IDraw.SetLocation(int xCoord, int yCoord)
{
	this.locX=xCoord; 
	this.locY yCoord;
}
9.将IDraw.Draw方法中的代码替换成以下加粗的语句:
void IDraw.Drau(Canvas canvas)
{
	if(this.rect l- null)
	{
		canvas.hildren.Remove(this.rect);
	}
	else
	{
		this.rect = new Rectangle();
	}
	this.rect.Height = this.sideLength;//高
 	this.rect.didth = this.sideLength;//宽
 	Canvas.SetTop(this.rect,this.locY);
 	Canvas.SetTop(this.rect,this.locX);
 	Canvas.SetTop(this.rect);
}
该方法在画布上画一个 Rectangle 形状来描绘出 Square对象。(高宽一样的矩形就是正方形。)如果以前画了一个 Rectangle(也许位置和颜色不同),就把它从画布上删除。Rectangle的高度和宽度都设置成sideLength字段的值。Rectangle在画布上的位置使用Canvas类的静态方法SetTop 和SetLeft来设置。最后,将设置好的Rectangle添加到画布上(这时才真正显示出来)
10.在Square类中显式实现IColor接口的SetColor方法,如下所示:
void IColor. Setcolor(Color color)
{
	if(this.rect l= null)
	{
		SolidcolorBrush brush = new SolidColorBrush(color);
		this.rect.Fill= brush;
	}
}
方法先验证 Square 对象是否已显示。(如果还没有画好,rect字段将为null。)如果是,就将 rect对象的F1ll属性设为指定颜色,这是用一个 SolidColorBrush对象来做到的。
11.选择"项目"|"添加类"。在"添加新项-Drawing"对话框中,在"名称"文本框中输入 CIrele.es,单击"添加"。随后,Visual Studio 会创建Circle.cs 文件并在"代码和文本编辑器"中显示。
12.在Circle.cs 文件顶部添加以下 using指令:
using Mindows.UI;
using Mindows.UI.Xaml.Media;
using Mdindows.U.Xaml.Shapes;
using windows,U.Xaml.Controls;
13.修改Circle类定义来实现IDraw和IColor接口,如以下加粗部分所示:
class Circle:IDraM,IColor
{
}
14.将以下加粗的私有变量添加到Circle类中。这些变量容纳 Circle对象在画布上
的位置和大小。Ellipse类提供了画圆的功能
class Circle:IDraM, IColor
{
	private intdiameter;
	private int locX=6,locY = 0; 
	private E1ipse circle = null;
}
15.将以下加粗的构造器添加到Circle类中,它初始化diameter(直径)字段。
class Circle:IDraw,IColor
{
	...
	public Circle(int diameter)
	{
		this.dameter= diameter;
	}
}
16.将IDraw接口规定的以下 SetLocation方法添加到Circle类。
void IDra.SetLocation(int xCoord,int yoord)
{
	this.locx = xCoord; 
	this.locY = yCoord;
}
注意 方法和 Square类中的一样,明显重复了.以后会解释如何重构.
17.将以下Dra w 方法添加到 Circle类。
vold IDraw. Dram(Camvas carvas)
{
	if(this.circle I= nul1)
	{
		canvas.Children.Remove(this.circle);
	}
	else
	{
	this.circle ■ new E1lipse();
	this.circle.Height = this.diameter; 
	this.circle.Mdth = this.diameter;
	Canvas.SetTop(this.circle,this.locY);
 	Canvas.SetLeft(this.circle, this.locX);
	canvas.Children.Add(this.circle);
	}
	该方法也是IDraw接口的一部分。与 Square类中的 Draw 方法相似,通过在画布上画一个 Ellipse形状来画圆(宽高一样的椭圆就是圆)。和 SetLOcation方法一样,以后会重构代码来减少重复。
18.将 SetColor方法添加到Circle类中。该方法是IColor接口的一部分。方法实现和 Square类中的实现相似。
void IColor. Setcolor(Color color)
{
	if(circle l nul1)
	{
		SolidColortrush brush = new Solidcolortrush(color);
		this.circle.Fill brush;
	}
}
现在已经完成了Square和Circle类,接着用窗体进行测试测试Squre和 Circle类
1.在设计视图中显示 DrawingPad.xaml文件,
2.单击窗体中间的阴影区域。阴影区域是Canvas 对象。单击会造成该对象获得焦点。
3.在属性窗口中单击"事件处理程序"按钮(闪电图标)。
4.在事件列表中找到Tapped事件并双击它旁边的文本框。
Visual Studio会为 DrawingPad类创建 drawingCanvas_Tapped方法,并在"代码和文本编辑器"中显示。该方法就是事件处理程序,用户在画布上用手指点击或者单击鼠标左键就会运行它。
5.在DrawingPad.xaml.cs 文件顶部的列表中添加以下 using指令:
using Mindoas.UI;
Windows.UI 命名空间包含Colors类的定义。设置形状的颜色要用到它。
6.将以下加粗的代码添加到 drawingCanvas_Tapped方法:
private void drawdngCanvas Tapped(object sender,TapedRoutedEventArgs e)
{
	Point mouseLocation- e.GetPosition(ths.dradingCanvas);
	Square mSquare = new Square(108);

	if(mySquare is IDraw)
	{
		IDraw draMSquare = myySquar;
		drawSquare.SetLocation((int)mouseLocation.X,(int)mouseLocation.Y);
		draSquare.Dra(dradingCanvas);
	}
}
TappedRoutedEventArgs参数向方法提供了关于鼠标位置的有用信息。具体地说,GetPosition方法会返回一个Point结构,其中包含鼠标的X和Y坐标。刚才添加的代码创建了一个新的Square对象。然后,代码验证该对象实现了IDraw接口。
(这是好的编程实践,通过接口引用尚未实现该接口的对象会在运行时出错。)然后通过该接口创建一个Square对象引用。记住,显式实现接口时,只有通过接口引用才能使用接口定义的方法。(SetLocation和Draw方法是Square类私有的,只能通过IDraw接口使用。然后,代码将Square的位置设为用户当前手指或鼠标的位置。注意,Point结构中的X和Y坐标实际是double值,所以要把它们转型为int。最后,调用Draw方法显示 Square对象。
7.在drawingCanvas_Tapped方法末尾添加以下加粗的代码:
private void dradngamvas_Tapped(object sender,TapedRoutedEventArgs e)
{
	...
	if(（mysquare is IColor)
	{
		IColor colorSquare =mySquare;
		colorSquare.Setcolor(colors.BlueViolet);
	}
}
上述代码验证 Square 类实现了IColon 接口;如果是,就通过该接口创建一个Square 对象引用,并调用SetColor 方法将 Square 对象的颜色设为 Colors.BlueViolet。
重要提示 必须先调用Draw再调用SetColor.这是由于SetColor方法只有在Square 对象渲染好之后才会设置其颜色。在Draw之前调用SetColor,颜色不会设 置,Square对象也不会出现。
8.返回DrawingPad.xaml文件的设计视图,单击窗体中间的Canvas对象(也就是阴影区域)。
9. 在事件列表中双击 RightTapped事件旁边的文本框。 在画布上用手指长按或者单击鼠标右键,就会发生该事件。
10.将加粗的代码添加到 drawingCanvas_RightTapped方法。代码逻辑与处理手指点击或鼠标左键单击事件的逻辑相似,只是用HotPink颜色显示一个Circle 对象。
private void drawdingCanvas _RLightTapped(object sender,HoldingfoutedEventArgs e）
{
	Point mouseLocation =e.GetPosition(this.dradngCamvas);
	Circle myircle - new Circle(109);
	if(mycircle is IDra)
	{
		IDram draCircle=myCircle;
		draCircle. setLocation((int)mouseLocation.X,(int )mouseLocation.Y
		drauCircle.Dra'(draudngCanvas);
	}
	if（(myCircle is IColor)
	{
		IColor colorcircle = myCircle;
		colorCircle.Setcolor(Colors.HotPink);
	}
11.在"调试"菜单中选择"开始调试"来生成并运行应用程序。
12.出现Drawing Pad窗口后,用手指点击或者用鼠标左键单击画布的任何地方。显示一个紫罗兰色正方形
13.长按或右击画布的任何地方,会显示一个粉色圆。可随意点击或长按,或者按鼠标左右键,每次都会在相应位置画正方形或圆。
14.返回Visual Studio并停止调试。
抽象类
前面讨论的ILandBound(陆上)和IGrazable(草食)接口可由许多不同的类来实现,具体取决于想在自己的C#应用程序中建模多少类型的哺乳动物。在这种情形下,经常都可以让派生类的一部分共享通用的实现。例如,以下两个类明显有重复:
//Horse和Sheep 都是草食动物
class Horse:Mammal,ILandBound,IGrazable 
{
	...
	void IGrazable.ChewGrass()
	{
		Console.iriteLine("Chewing grass");
		//用于描述明嚼草的过程的代码
	}
}
class Sheep:Namal,ILandBound,IGrazable 
{
	...
	void IGrazable.ChewGrass()
	{
		Console.MriteLIne("Chewing grass");
		//和马咀嚼草一样的代码
	}

}
重复的代码是警告信号,表明应重构以免重复并减少维护开销。一个办法是将通用的实现放到专门为此目的而创建的新类中,换言之,要在类层次结构中插入一个新类。例如
class Grazingtamal:Mammal,IGrazable //Grazingammal是指草食性乳动物
{
	...
	void IGrazable.ChewGrass()
	{
		//用于表示咀嚼草的通用代码
		Console.writeLine("Chewing grass");
	}
}
class Horse:Grazing*ammal,ILandBound
{
	...
}
class Sheep:Grazingammal,ILandBound
{
	...
}
该看起来不错,但仍有一件事情不太对:可实际地创建GrazingMammal类(以及Nammal)的实例。这不合逻辑。GrazingMammal(草食性哺乳动物)类存在的目的是提供通用的默认实现,唯一作用就是让一个具体的草食性哺乳动物(例如马、羊)类从它继承。Grazingamal类是通用功能的抽象,而不是单独存在的实体。为明确声明不允许创建某个类的实例,必须将那个类显式声明为抽象类,这是用 abstract关键字实现的。如下所示:
astract class Grazinglamal:Mamal,IGrazable
{
	...
}
试图实例化一个GrazingNammal对象,代码将无法编译。示例如下:
Grazinghammal myGrazingammal - new Grazinghammal(.);//非法

抽象方法
象类可包含抽象方法。抽象方法原则上与虚方法相似,只是不含方法主体。派生类必须重写(override)这种方法。抽象方法不可以私有。下例将 Grazinghammal类中的 DigestGrass(消化草)方法定义成抽象方法:草食动物可以
使用相同的代码来表示咀嚼草的过程,但它们必须提供自己的DigestGrass 方法的实现(虽然咀嚼草的过程相同,但消化草的方式不同)。如一个方法在抽象类中提供默认实现没有意义,但又需要派生类提供该方法的实现,就适合定义成抽象方法。
abstract class Grazingtamal:Mammal, IGrazable
{
	public abstract void DigestGrass();
	...
}
密 封 类
继承不一定总是容易,它要求深谋远虑。如决定创建接口或抽象类,就表明故意要写一些便于未来继承的东西。但麻烦在于,未来的事情很难预料。需掌握一定的技巧,付出一定的努力,并对试图解决的问题有深刻的认识,才能打造出一个灵活和易于使用的接口、抽象类和类层次结构。换言之,除非在刚开始设计一个类的时候就有意把它打造成基类,否则它以后很难作为基类使用。
如果不想一个类作为基类使用,可用C#提供的sealed(密封)关键字防止类被用作基类。例如:
sealed class Horse:Grazingtamal,ILandBound
{
	...
}
任何试图将 Horse用作基类都会发生编译时错误。密封类中不能声明任何虚方法,而且抽象类不能密封。
注意 结构(struct)隐式密封。永远不能从一个结构派生。
密封方法
可用sealed关键字声明非密封类中的一个单独的方法是密封的。这意味着派生类不能重写该方法。只有用 override 关键字声明的方法才能密封,而且方法要声明为 sealed 
override.可像下面这样理解interface,virtual,override和sealed等关键字。
inerface(接口)引入方法的名称,virtual(虚)方法是方法的第一个实现。override(重写）)方法是方法的另一个实现。sealed(密封)是方法的最后一个实现。

实现并使用抽象类
以下练习用一个抽象类对上个练习中开发的代码进行归纳。Square和Circle类包含高度重复的代码。合理做法是将这些代码放到名为DrawingShape 的抽象类中,以便将来 可以方便地维护 Square和Circle类。
创建DrawingShape抽象类
1.返回VisualStudio 中的Drawing项目
注意 上个练习已完成的项目副本存储在"文档"文件夹下的Microsof
PressVCSBSIChapter 13Drawing-Complete 子文件夹。
2.在解决方案资源管理器中单击Drawing解决方案中的Drawing项目。从"项目"菜单中选择"添加类"。随后会出现"添加新项-Drawing"对话框。
3.在"名称"文本框中输入DrawingShape.es,单击"添加"。
Visual Studio 会创建文件并在"代码和文本编辑器"中显示。
4.在DrawingShape cs 文件顶部添加以下 using指令:
using Mindows.UI; 
using Mdndos.UT.Xaml.NedHa; 
using MndowS.UI.Xam1.Shapes; 
using wMindows,UI.Xaml.Controls;
该类作用是包含 Circle 和 Square 类的通用代码。程序不能直接实例化
DrawingShape对象。
5.修改 DrawingShape类的定义,把它声明为抽象类,如加粗的部分所示:
abstract class DrawingShape
{
}
6.以下加粗的变量添加到DrawingShape类中:
abstract class DrawingShape
{
	protected int size;
	protected int locX=e,locY =8;
	protected Shape shape= null;
}
Square和Circle类都用locX和locY字段指定对象在画布上的位置,所以可将这些字段移至抽象类。类似地,Square 和Circle 类都用一个字段指定对象描绘时的大小;虽然在不同类中有不同名字(sideLength和diameter),但从语义上说,该字段在两个类中执行相同的任务。size这个名字是对该字段的一个很好的抽象。在内部,Square类用一个Rectangle对象将自己画到画布上,而Circle类用一个E1l1pse对象。两个类都是基于.NETFramework抽象类Shape的一个层次结构的一部分。所以DrawingShape类用一个Shape字段代表两个类型。
7.为 DrawingShape类添加以下构造器:
abstract class DradngShape
{
	...
	public DradingShape(int size)
	{
		this.size size;
	}
}
上述代码对DrawingShape对象中的size字段进行初始化
8.在 DrawingShape类中添加 SetLocation和 SetColor方法,如以下加粗的代码所示。这些方法提供了由DrawingShape 的所有派生类继承的实现。注意它们没有标记为virtual(虚方法),派生类不用重写。另外,DrawingShape类没有被声明为实现IDraw或IColor接口(实现接口是 Square和 Circle类的事儿,不是抽象类的事儿),所以这些方法直接声明为 public abstract class DradngShape
{
	...
	public vold SetLocation(int xCoord, int yCoord)
	{
		this.locX = xCoord;
		this.locY = ycoord;	
	}
}
public void SetColor(Color color)
{
	if(this.shape 1= null)
	{
		SolidColorBrush brush = new SolidColorBrush(color);
		this.shape.F1ll = brush;
	}
}
9.为DrawingShape类添加Draw方法。和之前的方法不同,该方法要声明为虚,派生类应重写以扩展功能。方法中的代码验证 shape字段不为nul1,并在画布上把它画出来。继承该方法的类必须提供自己的代码来实例化 shape 对象。(Square类是创建一个Rectangle对象,而Circle类是创建一个Ellipse对象。)
abstract class DradingShape
{
	...
	public virtual void Drau(Canvas canvas)
	{
		if(this.shape m null)
		{
			throw new IivalidoperationException("Shape is null");
		}
		this.shape.Height = this.Ssize;
		this.shape.width = this.size;
		Canvas.SetTop(this.shape, this.locY);
		Canvas. SetLeft(this.shape, this.locX);
		canvas.Children.Add(this.shape);
	}
}
现已完成了DrawingShape抽象类的编写。下一步是更改 Square和 Circle类,使它们从这个类继承并删除重复代码。修改Square和Circl类从 DrawingShape类继承
1 在"代码和文本编辑器"中显示Square类的代码。
2. 修改 Square类定义,从DrawingShape类继承,并实现IDraw和IColor接口。
class Sqare:DraudingShape,IDraw,IColol
{
	...
}
注意 Square要继承的类必须在任何接口之前指定.
3.在Square 中删除 sideLength,rect,locX和locY字段的定义。它们现由
DrawingShape类提供,所以不需要了。
4.将现有构造器替换成以下代码,它直接调用基类构造器。注意,构造器主体是空白的,因为基类构造器执行了所有必要的初始化:
class Square:DradngShape,IDraM,IColor
{
	public Square(int sideLength):base(sideLength)
	{
	}
	...
}
5. 从Square 类删除 IDraw.SetLocation 和IColor.SetColor方法。现IDrawingShape类提供它们的实现。
6.修改 Draw 方法定义。把它声明为 public override,删除方法名前的 IDraw接口引用(即不再显式实现接口)。由于DrawingShape类已提供该方法的基本功能,用Square类特有的代码扩展一下即可
public overrlde vold Draw(Canvas canvas)
{
	...
}
7.将Draw方法主体替换为以下加粗的语句。这些语句将从DrawingShape类继承的shape字段实例化成 Rectangle类的新实例（如果还没有实例化的话),然后直接调用DrawingShape类的 Draw 方法。
public overrlde vold Draw(Canvas canvas)
{
	if(this.shape la null)
	{
		camvas.Children.Remove(this.shape);
	}
	else
	{
		this.shape = new Rectangle();
	}
	base.Drao(camvas);
}
8.为 Circle 类重复步骤 2到7,只是把构造器的名字改成Circle,把参数改成diameter。在Draw 方法中将shape字段实例化成新的Ellipse对象。Circle类的完整代码如下所示:
class Circle:DradngShape,IDraw,IColor
{
	public Circle(int diameter):base(diameter)
	{
	}
	public override void Dra(Camvas canvas)
	{
		if(this.shape l= null)
		{
			canvas.Children.Remove(this.shape);
		}
		else
		{
			this.shapea new Elipse();
		}
		base.Drau(canvas);
	}
}
9.在"调试"菜单中选择"开始调试"。等 Drawing Pad 窗口出现时,验证左键单击显示 Square对象,右键单击显示Circle对象。应用程序的外观和感觉和以前完全一样。
10. 返回Visual Studio并停止调试。
再论 Windows Runtime 兼容性
Windows8起,是将Windows Runtime(WinRT作为原生Windows API顶部的一层来实现,提供简化的编程接口来生成非托管应用程序(非托管应用程序不通过NETFramework运行,使用C+这样的语言而不是C#进行编写).托管应用程序使用CLR来运行..NETFramework提供了完备的库和功能。在Windows7和更早的版本中,CLR是用原生WindowsAPI实现这些功能。在Windows10中开发桌面或企业应用程序/服务时仍可使用这些功能(虽然.NETFrmework本身已升级到版本4.6.1).任何C#程序只要能在Windows7上运行,就能不加改变地在Windows10上运行但在Windows10上,UWP应用总是用WinRT运行。这意味着如果使用C#这样的托管语言开发UWP应用,CLR实际调用WinRT而不是原生WindowsAPI.Microsoft在CLR和WinRT之间提供了一个映射层,能将发送给.NETFramework的对象创建与方法调用请求透明转换成 WimRT中的对应请求,例如,在创建.NET Framework Int32值时(C#的一个int),代码会转换成使用等价的WinRT数据类型来创建但是,虽然CLR和WinRT在功能上有许多重叠的地方,并非.NETFramework4.6的所有功能都在WinRT中进行了实现,因此,UWP应用能用的只是NETFramework4.6类型和方法的一个子集.用C创建UWP应用程序时,Visual Studio 2017的"智能感知"会自动显示可用功能的一个受限视图,在WinRT中用不了的类型和方法不会显示.另一方面,WinRT的许多功能和类型在.NETFramework中也没有直接对应物,或者工作方式显著不同,所以不能简单地转换。WinRT通过映射层向CLR 提供这些功能,使之看起来就像是.NETFramework的类型和方法,可直接在托管代码中调用。所以,CLR和WinRT的集成使CLR能透明使用WinRT类型,但同时也支持反方向的互操作性。也就是说,可用托管代码定义类型,使其能由非托管应用程序使用,只要这些类型符合WinRT的期待即可。如希望类能由非托管应用程序通过WinRT使用,就必须遵守以下规则。任何公共字段,以及任何公共方法的参数和返回值,都必须是WinRT类型或者能由WinRT透明转换成WinRT类型的NETFramework类型。支持的.NET Framewor类型包括合格的值类型(比如结构和枚举),以及和CH#基元类型(int,long,float,double,string等)对应的那些、类可包含私有字段,可以是.NETFramework中的任何类型,不需要相容于WinRT。类不能重写System.0bject的除ToString之外的方法,而且不可声明受保护构造器。定义类的命名空间必须与实现类的程序集同名.另外,命名空间的名称(进而包括程序集名称)一定不能以"Windows"开头。不能在通过WinRT运行的非托管应用程序中从托管类型继承.因此,所有公共类都必须密封.要实现多态性,可创建公共接口并在必须多态的类中实现该接口。可以抛出UWP应用支持的任何.NETFramework异常类型,但不能创建自己的异
常类,从非托管应用程序调用时,如果代码抛出未处理异常,WinRT会在非托管代码中抛出等价的异常。

使用垃圾回收和资源管理
使用垃圾回收管理系统资源
编写销毁对象时运行的代码
编写try/finally语句,以异常安全"的方式,在已知的时间点释放资 
编写using语句,以异常安全的方式,在已知的时间点释放资源
实现IDisposable接口在类中实现异常安全的资源清理

如何创建变量和对象,并理解了在创建变量和对象的时候内存的分配方式(稍微提醒一下:值类型在栈上创建,而引用类型分配的是堆内存)。计算机内存有限,所以当变量或对象不再需要内存的时候,必须回收这些内存。值类型离开作用
域就会被销毁,内存会被回收。这个操作很容易完成。但引用类型呢?对象是用new关键字创建的,但应该在什么时候,采用什么方式销毁对象呢?
对象生存期
先回忆一下创建对象时发生的事情。对象用new操作符创建。下例创建 Square(正方形)类的新实例
int sizeOASquare =9;
Square mquare = new Square(size0esquare);// Square是引用类型
new表面上是单步操作,但实际分两步走
1.首先,new操作从堆中分配原始内存。这个阶段无法进行任何干预。
2. 然后,new 操作将原始内存转换成对象,这时必须初始化对象。该阶段可用构造器控制。
注意 C++程序员注意,C#不允许重载new来控制内存分配.
创建好对象后,可用点操作符(.)访问其成员。例如,Square类提供了Draw方法:
moySquare.Dram();
注意 上述代码基于从DrawingShape抽象类继承的那个版本的 Square类,它不是显j实现IDraw接口。
mySquare变量离开作用域时,它引用的 Square 对象就没人引用了,所以对象可被销毁,占用的内存可被回收(稍后会讲到,这并不是马上发生的)。和对象创建相似,对象销毁也分两步走,过程刚好与创建相反。
1.CLR执行清理工作,可以写一个析构器来加以控制。
2.CLR将对象占用的内存归还给堆,解除对象内存分配。对这个阶段你没有控制权。销毁对象并将内存归还给堆的过程称为垃圾回收。
注意 C+程序员注意,C#没有提供delete操作符。完全由CLR控制何时销毁对象.

编写析构器件
使用析构器(destructor),可在对象被垃圾回收时执行必要的清理。CLR 能自动清理对象使用的任何托管资源,所以许多时候都不需要自己写析构器。但如果托管资源很大(比如一个多维数组),就可考虑将对该资源的所有引用都设为nul1,使资源能被立即清理。另外,如对象引用了非托管资源(无论直接还是间接),析构器就更有用了。
注意 间接的非托管资源其实很常见,例如文件流、网络连接、数据库连接和其他由Windows操作系统管理的资源。所以,如果方法要打开一个文件,就应考虑添加析构器在对象被销毁时关闭文件。但取决于类中的代码的结构,或许有更好、更
及时的办法关闭文件,详情参见稍后对using语句的讨论。析构器的语法是先写一个～符号,再添加类名。例如,下面的类在构造器中打开文件进行读取,在析构器中关闭文件(注意这只是例子,不建议总是像这样打开和关闭文件):
class FlleProcessor
{
	Filestream flle - null;
	public FileProcessor(string filelam）
	{
		this."1le - F1le.0penRead(fleltlme);//打开文件来读取
	}
	~FileProcessor()
	{
		this.ile.Close();//关闭文件
	}
}
析构器存在以下重要限制。
析构器只适合引用类型。值类型（例如 struct)不能声明析构器
struct MStruct
{
	~MStruct()（(...}//编时错误
}
不能为析构器指定访问修饰符（例如 public)。这是由于永远不在自己的代码中调用析构器——总是由垃圾回收器(CLR的一部分)帮你调用。
public ~F1leProcessor() {.}//编译时错误
析构器不能获取任何参数。这同样是由于永远不由你自己调用,~FileProcessor(int parameter)(…..}//编译时错误
编译器内部自动将析构器转换成对0bject.Finalize方法的一个重写版本的调用。β如,编译器将以下析构器
class FileProcesso
{
	~FileProcessor(){//你的代码造到这里}
}
转换成以下形式:
class FileProcessor
{
	protected override vold Finalfze()
	{
		try{//你的代码放在这里}
		finally( base.Finalize();}
	}
}
编译器生成的 Finalize 方法将析构器的主体包含到try块中,后跟 finally块来调用基类的Finalize方法。这样就确保析构器总是调用其基类析构器,即使你的析构器代码发生了异常。
注意,只有编译器才能进行这个转换。你不能自己重写 Finalize,也不能自己调用Finalize。
为什么要使用垃圾回收器
永远不能用C#代码自己销毁对象。没有任何语法支持。相反,CLR在它认为合适的时间帮你做这件事情。注意,可能存在对一个对象的多个引用。在下例中,变量myFp和referenceToMyFp引用同一个 FileProcessor对象。
FileProcessor myfp = new FileProcessor();
FileProcessor referenceToyFp =myfp;
能创建对一个对象的多少个引用?答案是没有限制。这对对象的生存期产生了影响。CLR 必须跟踪所有引用。如果变量myFp不存在了(离开作用域),其他变量(比如eferenceToMyFp)可能仍然存在,Fi1leProcessor对象使用的资源还不能被回收(文件还不能被关闭)。因此,对象的生存期不能和特定的引用变量绑定。只有在对一个对象的所有引用都消失之后,才可以销毁该对象,回收其内存以便重用。
可以看出,对象生存期管理是相当复杂的一件事情,这正是C#的设计者决定禁止由你销毁对象的原因。如果由程序员负责销毁对象,迟早会遇到以下情况之一忘记销毁对象。这意味着对象的析构器(如果有的话)不会运行,清理工作不会进
行,内存不会回收到堆。最终的结果是,内存很快被消耗完。试图销毁活动对象,造成一个或多个变量容纳对已销毁的对象的引用,即所谓的虚悬引用。虚悬引用要么引用未使用的内存,要么引用同一内存位置风马牛完全不相及的对象。无论如何,使用虚悬引用的结果都是不确定的,甚至可能带来安全风险。什么都可能发生。试图多次销毁同一对象。这可能是、也可能不是灾难性的,具体取决于析构器中的代码怎么写。对于C#这种将健壮性和安全性摆在首要位置的语言,这些问题显然不能接受。取而代之的是,必须由垃圾回收器负责销毁对象。垃圾回收器能做出以下几点担保。每个对象都会被销毁,它的析构器会运行。程序终止时,所有未销毁的对象都会被销毁。

每个对象只被销毁一次
每个对象只有在它不可达时(不存在对该对象的任何引用)才会被销毁。这些担保的好处明显,它们使程序员可以告别麻烦且易出错的清理工作。从此只需将注意力集中在程序本身的逻辑上,从而显著提升了开发效率。
那么,垃圾回收在什么时候进行?这似乎是一个奇怪的问题。毕竟,肯定是在对象不再需要的时候进行。但要注意,垃圾回收不一定在对象不再需要之后马上进行。垃圾回收可能是一个代价较高的过程,所以"运行时"只有在觉得必要时才进行垃圾回收(例如,在它认为可用内存不够的时候,或者堆的大小超过系统定义阀值的时候)。然后,它会回收尽可能多的内存。对内存进行几次大扫除,效率显然高过进行多次"小打小闹"的打扫！
注意 可通过静态方法 System.GC.Collect在程序中调用垃圾回收器。但除非万不得已,否则不建议这样做。System.GC.Collect方法将启动垃圾回收器,但回收过程是异步发生的。方法结束时,程序员仍然不知道对象是否已被销毁。还是让CLR决定垃圾回收的最佳时机!垃圾回收器的特点是,程序员不知道(也不应依赖)对象的销毁顺序。需理解的最后一个重点是,析构器只有在对象被垃圾回收时才运行。析构器肯定会运行,只是不保证在时候运行。所以写代码的时候,不要对析构器的运行顺序或时间做任何假设。

垃圾回收器的工作原理
垃圾回收器在它自己的线程中运行,而且只在特定的时候才会执行(通常是当应用程序抵达一个方法的结尾的时候)。它运行时,应用程序中运行的其他线程将暂停。这是由于垃圾回收器可能需要移动对象并更新对象引用。如对象仍在使用,这些操作就无法执行。
注意 线程是应用程序的一个单独的执行路径。Windows 通过线程使应用程序能同时行多个操作。
垃圾回收器是非常复杂的软件,能自行调整,并进行了大量优化以便在内存需求与应用程序性能之间取得良好平衡。内部算法和结构超出了本书的范围(Microsoft 自己也在不断改进垃圾回收器的性能),但它采取的大体步骤如下。
1.构造所有可达对象的一个映射(map）。为此,它会反复跟随对象中的引用字段。垃圾回收器会非常小心地构造映射,确保循环引用(你引用我,我引用你）不会造成无限递归。任何不在映射中的对象肯定不可达。
2检查是否有任何不可达对象包含一个需要运行的析构器(运行析构器的过程称为"终结")。需终结的任何不可达对象都放到一个称为 freachable（发音是F-reachable)的特殊队列中。
3.回收剩下的不可达对象(即不需要终结的对象）。为此,它会在堆中向下面移动可达的对象,对堆进行"碎片整理",释放位于堆顶部的内存。一个可达对象被移动之后,会更新对该对象的所有引用。
4.然后,允许其他线程恢复执行。
5.在一个独立线程中,对需终结的不可达对象(现在,这些对象在freachable 队列中了)执行终结操作。

慎用析构器
写包含析构器的类,会使代码和垃圾回收过程变复杂。此外,还会影响程序的运行速度。如程序不包含任何析构器,垃圾回收器就不需要将不可达对象放到 freachable队列并对它们进行"终结"(也就是不需要运行析构器)。显然,一件事情做和不做相比,不做会快一些。所以,除非确有必要,否则请尽量避免使用析构器。例如,可改为使用using语句
析构器时要小心。尤其注意,如果在析构器中调用其他对象,那些对象的析构器可能已被垃圾回收器调用。记住,"终结"(调用析构器的过程)的顺序是得不到任何保障的。所以,要确定析构器不相互依赖,或相互重叠(例如,不要让两个析构器释放同一个资源)。

资源管理
有时在析构器中释放资源并不明智。有的资源过于宝贵,用完后应马上释放,而不是等待垃圾回收器在将来某个不确定的时间释放。内存、数据库连接和文件句柄等稀缺资源应尽快释放。这时唯一的选择就是亲自释放资源。这是通过自己写的资源清理(disposal)"方 法来实现的。可显式调用类的资源清理方法,从而控制释放资源的时机
注意 资源清理(disposal)方法强调的是方法的作用而非名称,可用任何有效C#标识符来命名。

资源清理方法
实现了资源清理方法的一个例子是来自 System.IO命名空间的TextReader类。该类提供了从顺序输入流中读取字符的机制。TextReader包含虚方法Close,它负责关闭流,这就是一个资源清理方法。StreamReader类从流(例如一个打开的文件)中读取字符,StringReader 类则从字符串中读取字符。这两个类均从 TextReader 类派生,都重写了 Close方法。下例使用 StreamReader类从文件中读取文本行并在屏幕上显示：
TextReader reader · new StreanReader(filename);
string line;
while（(line - reader,ReadLine())l- null)
{
	Console.writeLine(ine);
}
reader.Close();
ReaLine方法将流中的下一行文本读入字符串。如果流中不剩下任何东西,ReadLine方法将返回null。用完reader后,很重要的一点就是调用Close来释放文件句柄以及相关的资源。但这个例子存在一个问题,即它不是异常安全的。如果对 ReadLine(或writeLine)的调用抛出异常,对Close 的调用就不会发生。如经常发生这种情况,最终会耗尽文件句柄资源,无法打开任何更多文件。
异常安全的资源清理
TextReader reader = new StreamReader(filename);
try
{
	string ling;
	while（(line = reader.ReadLine())l null)
	{
		Console.writeLine(line);
	}
}
finally
{
	reader.Close();
}
像这样使用finally块可行,但由于它存在几个缺点,所以也不是特别理想。
要释放多个资源,局面很快就会变得难以控制(将获得嵌套的try和finally块)。有时可能需要修改代码来适应这一惯用法(例如,可能需要修改资源引用的声明顺序,要记住将引用初始化为nul1,还要记住查验finally块中的引用不为null)。它不能创建解决方案的一个抽象。这意味着解决方案难以理解,必须在需要这个功能的每个地方重复代码。
对资源的引用保留在finally块之后的作用域中。这意味着可能不小心使用一个已释放的资源
using语句就是为了解决所有这些问题而设计的。
using语句和 IDisposable接口
using 语句提供了一个脉络清晰的机制来控制资源的生存期。可创建一个对象,该对象在using语句块结束时销毁。
重要提示 不要混淆本节描述的 using语句和用于将命名空间引入作用域的using指令。很遗憾,同一个关键字具有两种不同的含义．
using语句的语法如下:
using( type variable initialization )
{
	statementBlock
}
下面是确保代码总是在TextReader上调用Close的最佳方式:
using(（TextReader reader · new StreamReader(filenane))
{
	string line;
	while（(line = reader.ReadLine())1= null)
	{
		Console.Mrlteline(line);
	}
}
这个using语句完全等价于以下形式:
{
	TextReader reader new StreamReader(fllename);
	try
	{
		string line;
		while（(line = reader.ReadLine()la null)
		{
			Console.writeLine(line);
		}
	}
	finally
	{
		if(reader! null)
		{
			((IDisposable)reader).Dispose();
		}
	}
注意 using 语( 袁 using语句引入了它自己的代码块,这个块定义了一个作用城。也就是说,在语 句块的末尾,using语句所声明的变量会自动离开作用域,所以不可能因为不小 心而访问已被清理的资源.
using 语句声明的变量的类型必须实现 IDIsposable 接口。IDIsposable 接口在System命名空间中,只包含一个名为 Dispose的方法：
namespace System
{
	interface IDisposable
	{
		void Dispose();
	}
}
Dispose方法的作用是清理对象使用的任何资源。StreamReader类正好实现了IDisposable接口,它的Dispose方法会调用Close来关闭流。可将using语句作为一种清晰、异常安全以及可靠的方式来保证一个资源总是被释放。这解决了手动 try/finally方案存在的所有问题。新方案具有以下特点。需要清理多个资源时,具有良好的扩展性。不影响程序代码的逻辑。对问题进行良好抽象,避免重复性编码,
非常健壮;using语句结束后,就不能使用using语句中声明的变量(前一个例子是reader),因为它已离开作用域。非要使用会发生编译时错误。

从析构器中调用 Dispose 方法
写自己的类时,是应该写析构器,还是应该实现IDisposable接口,使using语句能管理类的实例?对析构器的调用肯定会发生,只是不知确切时间。另一方面,能准确知道什么时候调用Dispose方法,只是不能保证它真的会发生,因为它要求使用类的程序员记住写using语句。不过,从析构器中调用Dispose方法就能保证它的运行。这样可以多一层保障。忘记调用Dispose也没有关系,程序关闭时它总是会被调用。本章最后的练习将体验这个功能,下例演示了如何实现IDisposable接口。
class Example:IDisposable
{
	private Resource scarce; /要管理和请理的稀缺资源
	private bool disposed false; //指示资源是否已被清理的标志
	...
	~Example()
	{
		this.Dispose(false);
	}
	public vrtual void Dispose()
	{
		this.Dispose(true);
		GC.Suppressrinalize(this);
	}
	protected vrtual void Dispose(bool disposing)
	{
		if(Ithis.disposed)
		{
			//在此释放大型托管资源
			...
		}
		//在此释放非托管资源
		...
		this. disposed = true;
	}
}
public void SomeBehabior()
{
	checkIfDisposed();
	{
		checkIfoisposed(); //每个常规方法都要调用这个方法来检查对象是否已经清理
		...
	}
}
	...
	private void checkIfDisposed()
	{
		if(this.disposed)
		{
			throw new CbjectDisposedException("示例:对象已经清理");
		}
	}
注意以下几点。
类实现了IDisposable接口
公共 Dispose方法可由应用程序代码在任何时候调用公共 Dispose方法调用Dispose方法获取一个Boolean参数的受保护重载版本,向其传递 true。后者实际清理资源。析构器调用Dispose方法获取一个 Boolean 参数的受保护重载版本,向其传递 false.析构器只由垃圾回收器在对象被终结时调用。受保护的 Dispose方法可以安全地多次调用。变量 disposed 指出方法以前是否 运行过。这样可防止在并发调用方法时资源被多次清理。(应用程序可能调用Dispose,但在方法结束前,对象可能被垃圾回收,CLR会从析构器中再次运行Dispose方法。)方法只有第一次运行才会清理资源。

受保护的Dispose方法支持托管资源（比如大的数组)和非托管资源(比如文件句柄)的清理。如disposing参数为true,该方法肯定是从公共Dispose方法中调用的,所以托管和非托管资源都会被释放。如disposing参数为false,该方法肯 定是从析构器中调用的,而且垃圾回收器正在终结对象,所以不需要释放托管资 源(真要那样做也不是异常安全的),因为它们将由(或已由)垃圾回收器处理;在这种情况下只需释放非托管资源。公共Dispose方法调用静态GC.SuppressFinalize方法。该方法阻止垃圾回收器为这个对象调用析构器,因为对象已经终结。
类的所有常规方法（如 SomeBehavior)都要检查对象是否已清理;是就抛出异常。

实现异常安全的资源清理
下面这一组练习将演示如何通过 using语句确保对象使用的资源被及时释放(即使应用程序发生异常)。首先实现一个包含析构器的类,然后检查垃圾回收器在什么时候调用该析构器。
注意 练习创建的 Calculator类旨在演示垃圾回收基本原则。类实际不消耗任何托管或非托管资源,这种筒单类一般无需创建析构器或实现IDisposable接口.
创建使用了析构器的简单类
1.如Microsoft Visual Studio2017尚未启动,请启动。
2. 在"文件"菜单中选择"新建"│"项目"。
3.在"新建项目"对话框的左侧模板列表中单击"VisualC",在中间窗格选择"控制台应用(NETFramework)",在"名称"框中输入GarbageCollectionDemo.在"位置"框中指定"文档"文件夹下的MicrosoftPressVCSBSChapter14子文件
夹。然后单击"确定"按钮。
提示 可利用"位置"旁边的"浏览"按钮切换到MicrosoftPressVCSBSChapter1文件类而不必手打.
Visual Studio 新建控制台应用程序,在"代码和文本编辑器"中显示 Program.cs。
4.选择"项目"|"添加类"。
5. 在"添加新项-GarbageCllctionDemo"对话框中,验证中间窗格选定了"类"模板。在"名称"文本框中输入 Calculator,cs,单击"添加"。将创建Calculator类并在"代码和文本编辑器"窗口中显示。
6.将以下加粗的公共 D4vide方法添加到Calculator类。
class Calculator
{
	public int Divide(int first,int second)
	{
		returm first/second;
	}
}
方法很简单,就是第一个参数除以第二个,返回结果。提供它的目的是为类添一些功能,以便应用程序调用。
7.在Calculator类开头(Divide方法上方)添加以下加粗的公共构造器。构造器作用是验证 Calculator对象已成功创建:
class Calculator
{
	public Calculator()
	{
		Console.Mriteline("Calculatorbeing created");
	}
}
8.在Calculator类中添加以下加粗的析构器:
class calculator
{
	...
	~Calculator()
	{
		Console.MriteLine("Calculator being finalized");
	}
	...
}
析构器只是显示一条消息让人知道在什么时候垃圾回收器运行并终结类的实例。
真正写程序时一般不在析构器中输出文本。
9.在"文本和代码编辑器"窗口中显示Program.cs 文件。
10.在 Program类的 Main方法中添加以下加粗的语句:
static void Min(string[] args)
{
	Calculator calculator new Calculator(); Console.MriteLine($"120/15=(calculator.Divide(120,15))") Console.MriteLine("Program finishing");
}
代码创建一个Calculator对象,调用对象的Divide方法并显示结果,然后输出 表明程序结束的消息。
11.选择"调试"|"开始执行(不调试)"。验证程序显示以下消息:
Calculator being create
120/15=8
Program findishing 
Calculator being finalized
注意 只有在Main方法完成之后、程序要结束时才运行 Calculator对象的终结器
12.在控制台窗口中按 Enter键返回Visual Studio 2017。
CLR保证应用程序创建的所有对象都被垃圾回收,只是不保证在什么时候进行。在这个练习中,应用程序的执行时间较短,所以Calculator对象很快就随着程序的结束而被终结了。但如果是大型应用程序,其中的类使用了稀缺的资源,除非采取必要的步骤来进行资源清理,否则创建的对象也有可能要等到应用程序结束时才被释放。如果资源是文件,别的用户将长时间无法访问文件;如果资源是数据库连接,别的用户将长时间无法连接同一个数据库:如果资源是网络连接,别的用户可能出现网络连接不上的情况。理想情况是资源用完就释放,而不是被动地等着应用程序终止。
下个练习要在Calculator类中实现IDisposable 接口,使程序能在它选择的时间终结 Calculator对象
实现 IDisposable 接口
1.在"代码和文本编辑器"窗口中显示Calculator.cs 文件。
2. 修改Calculator类的声明来实现IDisposable接口,如以下加粗的部分所示。
class Calculator:IDisposable
{
	...
}
3.在类中添加IDisposable 接口要求的Dispose方法。
class Calculator:IDisposable
{
	...
	public void Dispose()
	{
		Console.iriteLine("Calculator being disposed");
	}
}
一般要在Dispose方法中添加代码来释放对象占用的资源。但这里只是输出一条消息,在Dispose方法运行时通知你。如你所见,析构器和Dispose方法的代码可能存在一定的重复。为避免重复,要将代码统一放到一个地方,再从另一个地
方调用。既然不能从 Dispose 方法中显式调用析构器,就只能从析构器中调用Dispose方法,并将资源释放逻辑放到Dispose方法中。
4.修改析构器来调用 Dispose方法,如以下加粗的语句所示。(保留显示对象已被终结的语句,以便知道垃圾回收器在什么时候运行。)
~Calculator()
{
	Console.MriteLine("Calculator being finalized");
	this.Dispose();
}
想在应用程序中销毁Calculator对象时,Dispose不会自动运行;代码要么显式调用它(使用 calculator.Dispose()这样的语句),要么在 using 语句中创建Calculator对象。本例准备采用第二个方案。
5.在"代码和文本编辑器"中显示Program.cs 文件,修改 Main 方法中创建Calculator对象并调用Divide方法的语句,如以下加粗的语句所示:
static voild Nain(string[] args)
{
	using(Calculator calculator = newe Calculator())
	{
		Console.MwriteLdne("120/15=(calculator.Divide(120,15)");
	}
	Console.writelLine("Program fintshing");
}
6.选择"调试"|"开始执行(不调试)"。验证程序显示以下消息:
	Calculaton being created
	120/15=8
	Calculator being disposed 
	Program finishing 
	Calculator being finalized 
	Calculator being disposed
using语句造成Dispose方法先于显示 Program finishing消息的语句运行。但应用程序终止时仍会运行Calculator 对象的析构器,它会再次调用Dispose方法。这显然有点重复了,也是对处理器资源的浪费
7.在控制台窗口中按 Enter 键返回Visual Studio2017。
多次清理对象使用的资源可能是、也可能不是灾难性的,但绝不是好的编程实践。推荐方案是在类中添加一个私有 Boolean 字段来指出 Dispose 方法是否已被调用,再在Dispose方法中检查该字段。

防止对象被多次清理
1.在"代码和文本编辑器"窗口中显示Calculatorcs 文件
2.在Calcuator类中添加私有Boolean字段 disposed,初始化为false,如以下加粗的语句所示:
class Calculator:IDisposable
{
	privte bool disposed = false;
	...
}
字段作用是跟踪对象状态,指出是否已在对象上面调用过Dispose方法。
3.修改 Dispose方法的代码,只有disposed字段为false才显示消息。显示消息后,将disposed字段设为true,如以下加粗的语句所示:
public void Dispose()
{
	if(ldisposed)
	{
	Console.writeLine("Calculator being disposed");
	}
	this.disposed = true;
}
4 选择"调试"|"开始执行(不调试)"。验证程序显示以下消息:
Calculator being created
120/158
Calculator being disposed
Program finishin
Calculator being fina
Calculator对象现在只被清理一次,但析构器仍会运行。这同样是一种浪费,所以下一步是在对象的资源已被释放的前提下阻止运行析构器。
5.在控制台窗口中按 Enter键返回Visual Studio2017。
6.将以下加粗的语句添加到Calculator类的Dispose方法末尾:
public void Dispose()
{
	if(ldisposed)
	{
		Console.writetine("Calculator being disposed");
	}
	this.disposed = true;
	GC.suppressFlnalize(this);
}
GC 类允许访问垃圾回收器,提供了几个静态方法来控制它的部分行动。其中,SuppressFinalize方法告诉垃圾回收器不要对指定的对象执行终止操作,阻止析构器运行。
重要提示 GC类公开了许多配置垃圾回收器的方法。但一般还是让CLR自己管理垃圾回收器,若调用不当,可能严重影响应用程序性能,SuppressFinalize方法的使用需要绝对的谨慎,因为清理对象失败可能丢失数据。（例如,如果
没有正确关闭文件,内存中缓存但尚未写入磁盘的任何数据都会丢失．)只有在知道对象已被清理的前提下(就像本练习展示的那样)才可调用该方法。
7.选择"调试"|"开始执行(不调试)",验证程序显示以下消息
Calculator being created
120/15-8
Calculator being disposed
Program finishing
可以看到,析构器不再运行,因为在程序结束运行之前,对象已被清理了。
8.在控制台窗口中按 Enter 键返回Visual Studio。
线程安全和 Dispose 方法
用disposed 字段防止对象被多次清理,这个方法大多数时候都适用,但注意终结器的运行时间无法控制,对于本章的练习,它总是在程序结束时执行,但其他时候并非一定如此,事实上,在对象的所有引用都消失之后的任何时间都可能调用终结器。所以,终结器甚至可能在 Dispose 方法运行时由垃圾回收器调用(记住垃圾回收器在自己的线程上运行),尤其是在Dispose方法有大量工作要做的时候,为了减少资源被多次释放的概率,可将this.disposed= true;语句挪动到更接近Dispose方法开头的位置,但如果这样做,从设置该变量开始到释放资源之前发生的异常将导致资源得不到释放。为了完全阻止两个线程争着清理同一个对象中的相同资源,可用线程安全的方式写代码,把它们嵌入一个C#lock语句中,如下所示：
publc void Dispose()
{
	lock(this)
	{
		if(!disposed)
		{
			Console.MriteLine("calculator being disposed");
		}
		this.disposed a true; 
		GC.SuppressFinalize(this);
	}
}
lock语句旨在阻止一个代码块同时在不同线程上运行.lock语句的实参(上例是 this)是对象引用。大括号中的代码定义了lock语句的作用域。执行到lock语句时,如果指定的对象目前已被锁定,请求锁的线程就会阻塞,代码将暂停执行。一旦当前拥有锁的线程抵达lock语句结束大括号,锁将被释放,允许被阻塞的线程获得锁并继续.然而,由于此时disposed字段已被设为true,所以第二个线程不再执行if（ldisposed)块中的代码。
这样使用锁能确保线程安全,但对性能有一些影响,一个替代方案是使用本章早先描述的策略,即只禁止重复清理托管资源(多次清理托管资源不是异常安全的;虽然不会损害计算机的安全性,但试图清理不存在的托管对象,可能影响应用程序的逻辑完整性),该策略要求实现Dispose方法的重载版本;using语句自动调用无参的Dispose(),后者调用重载的Dispose(true),而析构器调用 Dispose(false).调用重载Dispose时,只有在参数为true时才释放托管资源。using语句的目的是保证对象总是得到清理,即使使用期间发生了异常。本章最后一个练习将在using块中间生成异常来加以验证。验证对象在发生异常后也得到清理
1.在"代码和文本编辑器"窗口中显示Program.cs 文件。
2.修改调用Calculator对象的Divide方法的语句,如加粗的语句所示：
static vold Main(string[] args)
{
	using（Calculator calculator a new Calculator()
	{
		Console.writeldine($"120/e=(calculator.Divide(1280,e)");
	}
	Console.MriteLine("Progam fintshing")
}
注意,修改过的语句试图120除以0。
3.选择"调试"|"开始执行(不调试)"或者按Cr+F5。如预期的那样,程序抛出未处理的 DivideByZeroException异常。
4.关闭可能出现的GarbageCollectionDemo 消息框。如消息框中有"调试"选项,请忽略。验证在未处理异常后显示了消息"Calculator being disposed"
5.在控制台窗口中按Enter键返回Visual Studio 2017

用C#定义可扩展类型
许多高级C#功能,比如属性、索引器、泛型和集合类．要解释如何用事件构建响应灵敏的系统,如何用委托从一个类调用另一个类的逻辑,同时两个类不用紧密结合。这是很强大的一个技术,能显著增强系统的扩展性。要介绍C#的语言集成查询(LINQ)功能,它允许以清楚而自然的方式在对象集合上执行可能非常复杂的查询。还要介绍如何重载操作符,使C#常规操作符也能作用于你的类和结构。

实现属性以访问字段
使用属性封装逻辑字段
声明get 访问器(取值方法)控制对属性的读取
声明 set 访问器(赋值方法)控制对属性的写入
创建声明了属性的接口
使用结构和类实现包含属性的接口
根据字段定义自动生成属性
用属性初始化对象

如何定义和使用属性来封装类中的字段和数据。之前强调过,应将类中的字段设为私有,并提供专门的方法来存取值。这样就可以安全地、受控制地访问字段。另外,还可封装附加的逻辑和规则,规定哪些值能访问,以及以什么方式访间。但这样一来,字段的访问语法就会变得有一点儿奇怪。读写变量时,你会自然地想要使用赋值语句。如果必须调用方法才能在字段上达到同样的效果,肯定会感觉不自然。毕竟,这些字段本质上就是变量。属性正是为了减少这些麻烦而设计的。

使用方法实现封装
首先回忆一下使用方法隐藏字段的原始动机
以下结构用坐标(X,y)表示屏幕位置。假定×坐标有效范围是0～1279,y是0～1023:
struct ScreenPosition
{
	public int X;
	public int Y;

	public ScreenPosition(intx,inty)
	{
		this.X = rangeCheckedX(x);
		this.Y= rangeCheckedY(y);
	}
	private static int rangeCheckedX(int x)
	{
		if (x<0||x>1279)
		{
			throw new ArgumentOutOfRangeException("X");
		}
		return x;
	}
	private static int rangeCheckedY(int y)
	{
		if(y <0 || y > 1823)
		{
			thow new ArgumentoutOofRangeException("Y");
		}
		return y;
	}
}
该结构的问题在于违反了封装原则,没有保持数据的私有状态。将数据公开是个糟糕的主意,因为类控制不了应用程序对数据的访问。例如,虽然ScreenPosition构造器会对它的参数进行范围检查,但在创建好ScreenPosition对象之后,就可以随便访问公共 字段了,而此时不存在任何检查。迟早(早的概率更大),X或Y将超出允许的范围(可能是 因为编程错误,也可能是因为开发人员理解错误):
ScreenPosition origin = new ScreenPosition(0,0);
...
int xpos = origin.x;
origin.Y =-100/可以随使赋值
解决问题的常规手段是使字段成为私有,并添加取值和赋值方法,分别读取和写入 每个私有字段的值。这样,赋值方法就可对新字段值执行范围检查。例如,以下代码为 X字段添加了取值方法(GetX)和赋值方法(SetX),注意SetX会检查参数值:
struct ScreenPosltior
{
	...
	public int GetX()
	{
		return this.X;
	}
	public void SetX(int new)
	{
		this.X=rangeCheckedX(newx);
	}
	...
	prlvate static int rangeCheckedx(int x){...}
	private static int rangeCheckedY(int y)(... ) 
	private int x,y;
}
好了,上述代码已成功施加了范围限制,这是好事。但为了达到目的,也付出了不小的代价——现在的ScreenPosition不再具有自然的语法形式;它现在使用的是不太方便的、基于方法的语法。下例使X的值递增16。为此,它必须使用取值方法GetX从X读取，
再用赋值方法 SetX向X写入:
int xpos = origin.GetX();
origin.SetX(xpos＋10);
而在使用公共字段X时,上述代码是像下面这样写的:
rigtin.X+= 10;
使用公共字段,代码无疑更简洁,缺点是会破坏封装性。不过,在属性的帮助下,可以获得两全其美的结果——既维持了封装性,又能使用字段风格的语法。
AccessDdifier Type ProperName
{
	get
	{
		//取值代码
	}
	set
	{
		//赋值代码
	}
}
属性可包含两个代码块,分别以get和 set关键字开头。其中,get 块包含读取属性时执行的语句,set 块包含在向属性写入时执行的语句。属性的类型指定了由 get 和set访问器读取和写入的数据的类型。
以下代码段展示了使用属性改写的ScreenPosition结构。阅读代码时注意以下几点:
小写的_×和y是私有字段;大写的X和Y是公共属性:所有set 访问器都用一个隐藏的、内建的参数(名为value)来传递要写入的数据。
truct ScreenPosition
{
	private int _x,_y;
	public ScreenPosition(intX,int Y)
	{
		this.X - rangeCheckedX(X);
		this. y= rangeCheckedY(Y);
	}
	public int X
	{
		get{return this.X;
		set{this._X - rangeCheckedX(value);}
	}
	public int Y
	{
		get{retumn this._y;}
		set{this.y= rangeCheckedY(value);}
	}
	private static int rangeCheckedX(int x){...}
	private static int rangeCheckedY(int y){...}
}
本例每个属性都直接由一个私有字段实现。但这只是实现属性的方式之一。属性唯一要求的就是由 get 访问器返回指定类型的值。值还可动态计算获得,不一定要从存储好的数据中获取。如果像这样实现属性,就不需要物理字段了。
注意 虽然本章的例子演示的是如何为结构定义属性,但它们也适合类,语法是相同的。简单属性不需要为get和set 访问器使用正规方法语法,设计成表达式主体成员即可。
例如,上例可这样简化X和Y属性:
public int X
{
	get =>this.X;
	set =>this.X· rangeOheckedX(value);
}
public int Y
{
	get =>thds5.y;
	set =>this. y= rangeCheckedY(value);
}
注意，get访问器不需要指定 return关键字;提供读取属性时要求值的一个表达式即可。语法简洁了不少,且更自然(虽然这一点有争议)。无论怎么写,属性执行的都是相同的任务。虽然有个人喜好在里面,但对于简单属性,真的建议采用表达式主体语法。当然,混着用也行。例如,简单get 访问器作为表达式主体成员实现,较复杂的set 访问器则使 用正规方法。
关于属性和字段名称的注意事项
前面介绍了变量命名规范,尤其强调要避免标识符以下划线开头.但ScreenPosition 结构没有完全遵循该规范,它的两个字段被命名为_x和_y.这样做是有原因的.以后补充的内容"命名和可访问性"指出公共方法和字段一般以大写字母开头,私有方法和字段一般以小写字母开头。这两个规范可能造成你的属性和私有字段名称只是首字母大小有别,许多公司正是这样千的．如果你的公司也在此列,那么注意它的一个重要缺陷.例如以下代码,它实现了名为Employee 的类.EmployeeID属性提供对私有字段
employeeID字段的公共访问。
class Employe
{
	private int employeeID;
	public int EmployeeID
	{
		get > this.EmployeeID;
		set a> this.EmployeeID = value;
	}
}
代码编译没有问题,但每次访问 EmployeeID属性都会抛出 StackOverflowException异常。这是由于get和set访问器不小心引用属性(以大写字母E开头)而不是私有字段(小写e),这造成了无限递归,最终造成可用内存被耗尽.这种 bug很难发现!有鉴于此,本书以下划线开头命名为属性提供数据的私有字段,这样可更明显地和属性区分,除此之外的其他所有私有字段还是使用不以下划线开头的camelCase标识符。

使用属性
在表达式中使用属性时,要么从中取值,要么向其赋值。下例从 ScreenPosition结构的X和Y属性中取值：
ScreenPosition origin= new ScreenPosition(0,0);
int xposorigin.X; tin.X;//实际调用origin.X.get
int ypos= origin.Y; //实际调用origin.Y.get
注意,现在属性和字段是用相同的语法来访问。从属性取值时,编译器自动将字段风格的代码转换成对属性的get 访问器的调用。类似地,向属性赋值时,编译器自动将字段风格的代码转换成对该属性的set 访问器的调用:
origin.X= 46;//实际调用origin.X.set,value设为40
origin.Y=106;）| //实际调用origin.Y.set,value 设为100
如前所述,要赋的新值通过 value 变量传给 set 访问器。"运行时"自动完成传值。
还可同时对属性进行取值和赋值。在这种情况下,get 和 set 访问器都会被用到。例如,编译器白动将以下语句转换成对get和 sct 访问器的调用:
origin.X += 10;
提示 可采取和声明静态字段及方法一样的方式声明静态属性．访问静态属性时,要附加类或结构名称作为前缓,而不是附加类或结构的实例名称作为前缓。

只读属性
可声明只含get访问器的属性,这称为只读属性。例如,以下代码将ScreenPosition结构的 X属性声明为只读属性:
struct ScreenPosition
{
	private int _X;
	...
	public int X
	{
		get=>this.X;
	}
}
X属性不含 set 访问器,向X写入会报告编译时错误,例如:
origin.X = 14e;//编译时错误
只写属性
类似地,可声明只包含 set 访问器的属性,这称为只写属性。例如,以下代码将 ScreenPosition结构的X属性声明为只写属性:
struct ScreenPosition
{
	private int X;
	...
	public int X
	{
		set =>this._X= rangeCheckedX(value);
	}
}
X属性不包含get访问器。所以,读取X会报告编译时错误,例如:
Console.MFiteLne(origin.X); //编阐时错误 
orlgin.X = 200; /编译通过
origin.X += 10; //编译时错误
注意只写属性适合对密码这样的数据进行保护。理想情况下,实现了安全性的应用程序允许设置密码,但不允许读取密码。登录时用户要提供密码.登录方法将用户提供的密码与存储的密码比较,只返回两者是否匹配的消息．属性的可访问性声明属性时要指定可访问性(publicC,private或 protected)。
但在属性声明中,可为get和set 访问器单独指定可访问性,从而覆盖属性的可访问性。例如,下面这个版本的ScreenPosition结构将X和Y属性的set访问器定义成私有,而get 访问器仍为公共（(因为属性是公共的):
struct ScreenPosition
{
	private int _x,_y;
	...
	public  int X
	{
		get=> this._X;
		private set s>this._X = rangeCheckedX(value);
	}
	public int Y
	{
		set => this._y;
		private set => this._y a rangeCheckedY(value);
	}
	...
}
为两个访问器定义不同的可访问性时,必须遵守以下规则。
只能改变一个访问器的可访问性。例如,将属性声明为公共,但将它的两个访问器都声明成私有是没有意义的。
访问器的访问修饰符(也就是 public,private或者 protected)所指定的可访问性在限制程度上必须大于属性的可访问性。例如,将属性声明为私有,就不能将get 访问器声明为公共（相反,应该属性公共,set访问器私有）。

理解属性的局限性
属性在外观、行为和感觉上都像字段。但属性本质是方法而非字段。此外,属性存在以下限制只有在结构或类初始化好之后,才能通过该结构或类的属性来赋值。下例非法，因结构变量localion 尚未用 new初始化:
ScreenPosition location;
location.X=40;//编译时错误,location 尚未赋值
注意 如X是字段而不是属性,上述代码合法。听起来再正常不过,但弦外之音是强调字段和属性的区别。定义结构和类时,一开始就应该使用属性。而非先用字段,后又改成属性。字段改成属性后,以前使用了这个类或结构的代码就可能无法正
常工作。不能将属性作为ref或out参数传给方法:但可写的字段能作为 ref或out 参数传递。这是由于属性并不真正指向一个内存位置:相反,它指向的是一个访问器方法,例如:
MyMethod(ref location.X);//编译时错误
属性最多只能包含一个get和一个set访问器。不能包含其他方法、字段或属性。set和 set 访问器不能获取任何参数。要赋的值会通过内建的、隐藏的value变量自动传给 set 访问器。
不能声明 const属性,例如:
const int X
{
	get=>...
	set=>...
} //译时错误

合理使用属性
属性功能强大,且具有清晰的、字段风格的语法。合理使用属性,代码更易理解和维护。但仍应尽量采取面向对象的设计,将重点放在对象的行为而非属性上。通过常规方法访问私有字段,或是通过属性访问,本身并不会使代码的设计变得良好。例如,假定银行账户有一笔余额,你可能想在BankAccount(银行账户)类中创建Balance(余额)属性,如下
所示:
class BankAccount
{
	private decimal _balance;
	...
	public decimal Balance
	{
		set =>this._balance;
		set => ths.balance= value;
	}
}
这是个糟糕的设计,因其未能表示存取款时必要的功能(任何银行都不允许不存取款而更改余额)。编程需尽量在解决方案中表示要解决的问题,避免迷失于大量低级语法中。
例如,应该为BankAccount类提供 Deposit（存款)和withdram(取款)方法,而不是提供属性取值方法:
class Bankaccount
{
	private decimal_balance;
	...
	public decimal Balance { get w>this.balance;）
	public void Deposit(decinal amount){.}
	public bool withdraw(decimal amount){...}
}

在接口中声明属性
前面讲述了接口。接口除了能定义方法,还能定义属性。为此,需要指定 get或set关键字,或同时指定两者。但将get或 set 访问器主体替换成分号,例如
interface IScreenPosition
{
	int X {get;set;）
	int Y(get; set;）
}
实现该接口的任何类或结构都必须实现X和Y属性,并在属性中定义get和set访问器,例如:
struct ScreenPosition:IScreenPosition
{
	...
	public int X
	{
		get{...}//或get =>...
		set{...}//或set=>...
	}
	public int Y
	{
		get{...}
		set {...}
	}
	...
}
在类中实现接口规定的属性时,可将属性的实现声明为virtual,允许派生类重写实现,例如
class ScreenPosition:IScreenPosition
{
	...
	public virtual int X
	{
		get{.…}
		set{...}
	}
	public virtual int Y
	{
		get{...}
		set{..）
	}
	...
}
注意 本例展示的是类．virtual关健字在结构中无效,结构隐式密封,不支持继承。还可以使用显式接口实现语法来实现属性。属性的显式实现是非公共和非虚的(所以不能重写),例如:
struct ScreenPosition:IScreenPositior
{
	...
	int IScreenPosition.X //显式实现接中的属性时,要附时加核名作为前缀
	{
		get{...}
		set{...}
	}
	int IScreenPosition.Y//显式实现接口中的属性时,要附加接口名作为前缀
	{
		get{...}
		set{...}
	}
	...
}
用属性替代方法
前面创建了一个绘图应用程序,允许在画布上画圆和正方形。抽象类DrawingShape包含了Circle和Square类的通用功能。它提供了SetLocation和 SetColor方法,允许应用程序指定形状在屏幕上的位置和颜色。以下练习将修改 DrawingShape 类,将形状的位置和颜色作为属性公开

使用属性
1.如 如Microsoft Visual Studio 2017尚未启动,请启动。
打开 Drawing 解决方案,它位于"文 档"文件夹下的 MicrosoftPress\VCSBS\Chapter 15\Drawing Using Properties 子文件夹。
2.在"代码和文本编辑器"中显示 DrawingShape.cs 文件。
3.该文件包含和前面一样的DrawingShape类,只是遵照本章前面的建议,将size字段重命名为_s1ze,locCX和locY字段重命名为_x和_y。
 abstract class DrawdingShape
 {
 	protected int_size;
	protected int X = 6,y =6;
	...
 }
 4. 在"代码和文本编辑器"窗口中打开Drawing项目的IDraw.cs 文件。该接口指定了SetLocation方法,如下所示:
inteface IDrw
{
	void SetLocation(int xCoord,in yCoord);
	...
}
方法作用是用传入的值设置DrawingShape对象的_x和_y字段。该方法可用一对属性代替。
5.删除方法,把它替换成属性X和Y,如加粗的代码所示:
interface IDraw
{
	int X{get;set;}
	int Y{get;set;}
	...
}
6.在 DrawingShape类中删除 SetLocation方法,替换成X和Y属性的实现:
public int X
{
	get =>this._X;
	set => this._X= value;
}
public int Y
{
	get m>this._y;
	set => this._y= value;
}
7.在"代码和文本编 辑器"窗口中显示DrawingPad.xaml.cs 文件,找到drawingCanvas_Tapped方法。
该方法在手指点击屏幕或单击鼠标左键时运行,会在点击或单击位置画正方形。
8. 找到调用 SetLocation方法来设置正方形位置的语句,它在下面的if 块中:
if(mySquare is IDraw)
{
	IDraw draSquaremy5quare;
	dramSquare.SetLocation((int)mouseLocation.X,(int)mouseLocation.Y);
	draquare. Draw(dramdngCanvas);
}
9. 修改该语句来设置Square对象的X和Y属性,如加粗的语句所示:
if(mySquare is IDraw)
{
	IDraw dranSquare = mySquare;
	dramSquare.X =（int)mouseLocation.X;
	drauSquare.Y =(int)mouseLocation.Y;
 	dra5quare.Dram(dradngCanvas);
}
10.找到 drawingCanvas RightTapped方法。
该方法在手指长按屏幕或单击鼠标右键时运行,会在长按或右击位置画圆。
11.不再调用Circle对象的SetLocation方法,而是改为设置X和Y属性,如加粗
的语句所示:
if(myCircle is IDraw)
{
	IDraw dramCircle =myCircle;
	draMCircle.X =(int)mouselocation.X
	dramCircle.Y =(int)mouseLocation.Y;
 	dramcCircle.Draw(drawdngCanvas);
}
12."代码和文本编辑器"窗口中打开Drawing项目的IColor.cs 文件。该接口指定了SetColor方法,如下所示:
inteface IColor
{
	void Setcolor(Color color);
}
13.删除该方法,替换成Color属性,如加粗的代码所示:
interface IColor
{
	Color Color{set;} 
}
这是只写属性,只有set 访问器,没有get 访问器。这是由于颜色实际不存储在DrawingShape类中,仅在每个形状描绘时指定,无法通过查询形状来了解它的颜
色是什么。
注意 属性一般和类型的名称(本例就是Color)相同。
14 返回"代码和文本编辑器"中的DrawingShape类。将SetColor方法替换成Color属性,如下所示:
public color Color
{
	set
	{
		if(ths.shape l null)
		{
			SolidcolorBrush brush = new SolidcolorBrush(value);
			this.shape.Fill a brush;
		}
	}
}
提示 set访问器的代码和原始 SetColor方法几乎完全相同,只是向SolidColorBrush构造器传递的是 value参数．另外,本例证明有的时候,正规的方法语法优于表达式主体成员。
15.提示 set访问器的代码和原始 SetColor方法几乎完全相同,只是向SolidColorBrush构造器传递的是 value参数．另外,本例证明有的时候,正规的方法语法优于表达式主体成员。
if(mySquare is IColor)
{
	IColor colorSquare= mySquare;
	colorSquare.colora Colors.Blueviolet;
}
17.在"调试"菜单中选择"开始调试"命令,生成并运行应用程序。
18.验证应用程序和以前一样工作。手指点击或鼠标单击画布,应用程序应该画正方
形;长按或右击则画圆。
19.返回Visual Smdio 2017并停止调试。

生成自动属性
前面说过,属性旨在向外界隐藏字段的实现。如果属性确实要执行一些有用的工作,该设计毫无问题。但如果get和set访问器封装的操作只是读写字段,你或许就会质疑其价值。但至少出于两方面的考虑,应坚持定义属性,而不是将数据作为公共字段公开。与应用程序的兼容性字段和属性在程序集中用不同元数据进行公开。如开发一个类,并决定使用公共字段,使用该类的任何应用程序都将以字段形式引用这些数据项。虽然字段和属性的读写语法相同,但编译后的代码截然不同。换言之,是C#编译器隐藏了两者的差异。如以后决定将字段变成属性(可能是业务需求发生了变化,在赋值时需要额外的逻辑),现有的应用程序除非重新编译,否则就不能使用类的新版本。如果是大企业的开发人员,为大量用户的台式机都部署了相同的应用程序,这会造成巨大的麻烦。虽然有办法可以解决这个问题,但最好还是未雨绸缪。
与接口的兼容性 要实现接口,而且接口将数据项定义成属性,就必须实现这个属性,使之与接口规范相符———即使这个属性只是读写私有字段的数据。不可以只是添加一个同名的公共字段来"交差"。
C#语言的设计者知道程序员都是"大忙人",不该花时间写多余的代码。所以,C#编译器现在能自动为属性生成代码,如下所示:
class Circle
{
	public int Radius( get;set;}
	...
}
这个例子中,Circle类包含名为 Radus的属性。除了属性的类型,不必指定这个属性是如何工作的——get和set 访问器都是空白的。C#编译器自动将这个定义转换成私有字段以及一个默认的实现,如下所示
class Circle
{
	private int _radius;
	public int Radius{
		get {
			return this._radfus;
		}
		set
		{
			this._radius= value;
		}
		...
}
所以,只需写很少的代码就能实现简单属性。以后如果添加了额外的逻辑,也不会干扰现有的任何应用程序。
注意 注意 自动属性的语法与接口中的属性语法几乎完全相同。区别是能为自动属性指定访问修饰符,例如 private,public或者 protected。在属性声明中省略空白set 访问器就可创建只读自动属性,例如:
class Circle
{
	public DateTime CirclecreatedDate { get;}
	...
}
该技术适合用来创建不可变属性;即属性在对象构造时设好,以后便不可更改。例如,你可能想设置对象的创建日期,或者设置创建者的用户名,或者为对象生成唯一标识符。这些值通常都是设好了就不动。为此,C#允许选择两种方式初始化只读自动属性。可以从构造器中初始化:
class Circle
{
	public Circle()
	{
		CircleCreatedDate DateTime.How;
	}
	public DateTime CircleCreatedDate {get;}
	...
}
也可以在声明时初始化:
class Circle
{
	publlc DateTime CirclecreatedDate{get;)- DteTime.Now;
	...
}
注意，以这种方式初始化属性,又在构造器中设置它的值,那么后者会覆盖前者。两 种方式只选择一种,不要都用!
注意，不能创建只写自动属性。创建无 get访问器的自动属性会造成编译时错误。

用属性初始化对象
前面解释了如何定义构造器来初始化对象。对象可以有多个构造器,可为不同构造 器指定不同参数来初始化对象中的不同元素。例如,三角形建模可定义下面这个类
public class Triangle
{
	//声明三个边长
	private int sideiLength; 
	private int side2Length; 
	private int side3Length;
	//默认构造器-所有边长都取默认值10
	public Triangle()
	{
		this.sidelLength -this.side2Length a this.side3Length = 10;
	}
	//指定side1Length的长度,其他边长仍然默认为10
	public Trlangle(int lengthi)
	{
		this.sidelLength = length1; 
		this.side2Length a this.side3Length = 10;
	}
	//指定sidelLength和side2Length的长度
	//side3Length为默认值10
	public Triangle(int lengthi, int length2)
	{
		this.side1Length = length2;
		this.side2Length = length2;
		this.side3Length =10;
	}
}
//指定所有边长,都没有默认值
public Triangle(int lengthi, int length2,int length3)
{
	this.sidelLength = length1;
	this.side2Length = length2;
	this.side3Length = length3;
}
取决于类包含多少个字段,以及想用什么组合来初始化字段,最终可能要写非常多的构造器。另外,如多个字段具有相同类型,还可能遇到一个令人头痛的问题:无法为字段的每种组合都写唯一的构造器!例如在前面的Triangle类中,不能轻易添加一个构造器,让它只初始化 side1Length和side3Length字段,因其没有唯一性的签名。如果真的要写这样的构造器,构造器就必须获取两个 int 参数,但现在已经有一个构造器(负责初始化side1Length和side2Length的那个)具有这个签名了。一个解决方案是定义获取可选参数的构造器,并在创建Triangle对象时,通过指定参数名的方式为特定参数传递实参(这称为具名参数)。然而,一个更好和更透明的方式是将私有变量初始化为一组默认值并将它们作为属性公开,如下所示:
public class Triangle
{
	private int sidellength =10;
	private int side2Length =10;
	private int side3Lengt =10;
	public int SidelLength
	{
		set => this.sidedLength = value;
	}
	public int Side2Length
	{
		set => this.side2Length value;
	}
	public int Side3Length
	{
		set s）this.side3Length = value;
	}
}
创建类的实例时,可为具有set访问器的任何公共属性指定名称和值。例如,可创建riangle 对象,并对三边的任意组合进行初始化
Trlangle trl1 = new Triangle { Side3Length · 15 ); 
Triangle tr2= new Trlangle { Sideftength = 15,Side3Length · 20 ); 
Triangle tri3= new Triangle（Side2Length · 12, Side3Length = 17); 
Triangle tri4 a new Triangle{ SideiLength =9,Sidezlength = 12, Side3Length = 15 )};
这种语法称为对象初始化器或初始化列表。像这样调用对象初始化器,C#编译器会自动生成代码来调用默认构造器,然后调用每个具名属性的set访问器,把它初始化成指定值。对象初始化器还可以和非默认构造器配合使用。例如,假定 Triangle 类还有一个构造器能获取单个字符串参数(描述是哪种三角形),就可调用该构造器,同时对其他属性进 行初始化:
Triangle tr15a new Triangle("等边三角形"){SideLlength =3, 
										Side2Length 3,
										Side3ength =3 };
重点在于,肯定是先运行构造器,再对属性进行设置。如构造器将对象中的字段设为 特定的值,再由属性更改这些值,这个顺序就显得至关重要了。
对象初始化器还可和自动属性配合使用,这将在下个练习中演示。将定义一个类米资 模正多边形,用自动属性访问多边形的边数和边长。
注意 自动只读属性不能像这样初始化;只能使用上一节描述的两种方式之一
定义自动属性并使用对象初始化器
1.在Visual Studio 2017中打开AutomaticProperties 解决方案,它位于"文档"文件夹下的Microsoft PressVCSBS\Chapter 15\AutomaticProperties 子文件夹。AutomaticProperties项目包含Program.cs文件,定义了Program类。类中含有Main和 dowork方法,以前的练习出现过。
2.在解决方案资源管理器中右键单击 AutomaticProperties 项目,从弹出菜单选择"添加"|"类"。在"添加新项-AutomaticProprties"对话框中,在"名称"框中输入Polygon.es,单击"添加"。随后会自动创建并打开 Polygon.cs 文件,其中包含了自动添加的 Polygon类。
3.在 Polygon类中添加自动属性 NumSides(边数)和SideLength(边长),如加粗的代码所示:
class Polyg
{
	public int Numsides{get;set;）
	public double Sidelength {get;set;）
}
4.为 Polygon 类添加以下加粗的默认构造器,用默认值初始化 NumSides和SideLength字段:
class Polygon
{
	...
	public Polygon()
	{
		this.Numsides 4;
		this.SideLength =19.9;
	}
}
这个练习的默认多边形是边长为16.0的正方形。
5.在"代码和文本编辑器"窗口中打开Program.cs 文件。
6.将以下加粗的代码添加到 domork方法,替换其中的//TOD0:注释:
static vold dohork()
{
	Polygon square = new Polygon();
	Polygon trlangle = new Polygon{MumSides= 3);
	Polygon pentagon a new Polygon （ SideLength = 15.5,Mmsides=5 );
}
这些语句创建三个 Polygon对象。square(正方形)变量使用默认构造器初始化。triangle(三角形)和pentagon(五边形)变量先用默认构造器初始化,再通过"对象初始化器"更改Polygon类所公开的属性的值。在triangle变量的情况下,Numsides(边数)属性设为 3,但SideLength(边长)属性保持默认值10.6。在pentagon变量的情况下,SideLength和 NumSides 属性的值都进行了修改。
7.在doWork 方法末尾添加以下加粗的代码:
static vofid doWwork()
{
	...
	Console.writeLine($"Square:nmber of sides is(square.un6ides),length of each side is{square.SideLength}");
	Console.writeLine($"Triangle:number of sides is(trliangle.MunSides),length of eac
	side is {triangle.Sidelenth}");
	Console.MriteLine($"Pentagon:mnumber of sides is(pentagon.MumnSides), length of ea
	side is {pentagon. SideLength}");
}
这些语句显示每个 Polygon对象的NumSides 和SideLength属性值。
8.选择"调试"| "开始执行(不调试)"。
验证程序顺利生成并运行。
9.按 Enter键关闭应用程序,返回Visual Studio 2017。

处理二进制数据和使用索引器
以二进制和十六进制存储和显示整数数据
对二进制数据执行按位操作
使用索引器以数组风格访问对象
声明get访问器控制索引器的读取访问
声明 set访问器控制索引器的写入访问

在接口中声明索引器
在从接口继承的结构和类中实现索引器前面讲述如何实现属性,以受控制的方式访间类中的字段。处理含单个值的字段时属性很有用。但要以一种自然和熟悉的语法访问含有多个值的对象,索引器更有用。
什么是索引器
属性可被视为一种智能字段:类似地,索引器可被视为一种智能数组。属性封装类中的一个值,索引器封装一组值。使用索引器时,语法和使用数组完全相。理解索引器的最佳方式就是从例子中学习。首先展示一个例子,说明在不使用索引器的前提下,解决方案会存在哪些缺陷。再用索引器对解决方案进行优化。本例围绕整数（(更准确地说是int类型)展开,将用C#整数存储和查询二进制数据。

存储二进制值
通常用int容纳整数值。int内部将值存储为32位,每一位要么为O,要么为1。作为程序员,大多数时候都不需要关心内部二进制表示;相反,直接将int类型作为整数值的容器。但有时需要将int类型用在其他地方。例如,某些程序将int作为二进制标志(bitfags)集合使用,需单独操作其中的二进制位。换言之,是因为int 能容纳32个二进制位才用它,而不是因为它能代表一个整数。（C程序员肯定明白我的意思！）
注意 一些老程序通过int类型节省内存,那时的计算机内存以KB计,而不是以GB计。每KB内存都非常宝贵。一个int 能容纳32位,每一位都可以是1或6.为了省内存,程序员用1表示 true值;用6表示 false值,然后将这个int作为
位集合使用。
C#允许用二进制记号法指定整数常量,这样在处理位集合时就要容易一些。一个常量要作为位集合处理,附加0b0前缀即可。例如,以下代码将二进制值1111(十进制15)赋给变量:
uint binData = 0b0111;
注意,只有4位,比整数实际占用的少;未指定的位会被初始化为零。另外,好的实践是在将整数作为二进制位的集合使用时,将结果存储到一个无符号整数(uint)中。如提供完整32位二进制值,C#编译器甚至会坚持你使用uint。
一串较长的二进制位,甚至可以插入下划线（_)作为分隔符:
uint moreBiroata = 0b0 11110000_01011010_11001100_00001111;
本例用下划线标记不同的字节(32位共4字节)。二进制常量的任何地方都可插入,不一定要作为字节分隔符。下划线只用于增加可读性,会被C#编译器忽略。
如果觉得二进制串有点长,可考虑附加oxo 前级来使用十六进制(base 16）。以下语句将和之前一样的两个值赋给两个变量。同样可用下划线分隔。
uint hexData = 0x0_0F; 
uint moretexData = 0x0_F0_ 5A_CC_OF ;
显示二进制值
用Convert.ToString 方法显示整数的二进制表示。方法有多个重载版本,能生成各类数据的字符串形式。转换整数数据时可额外指定一个基数(2,8,10或16)。方法会用本书以前讲过的算法将整数换算成相应进制的值。下例打印 moreHexData变量的二进制值:
int moreHexData =0x0_F0_5A_CC_OF;
Console.writeline($"(Covert.ToString(moreHexData,2)}");
//显示11100001011010110011000000111

操纵二进制值
c#供以下操作符来访问和操纵int中单独的二进制位。
NOT(~)操作符一元操作符,执行按位求补。例如,对8位值0b0_11001100(十进制204)应用~操作符,结果是0b0_00110011(十进制51)。原始值中的所有1都变成0,所有0都变成1。
注意  这些例子仅供演示,只适合8位整数。C#的int类型是32位的,所以在C#应用程序中试验这些例子,得到的是和这些例子有区别的32位结果,例如,32位的264 是 00000000000000000011001100,所以在 C#中,~264 的结果是
1111111111111111111100110011(相当于C#int值-205).左移位(<<)操作符 二元操作符,执行左移位。表达式204< 2将返回值48(在二进制中,204 对应 0b0_11001100,,所有位向左移动2 个位置,结果是0b0_00110000,也就是十进制48)。最左边的位会被丢弃,最右边用0补足。还有一个对应的右移位操作符>>。OR(|)操作符二元操作符,执行按位OR。两个操作数中,任何一个的某一位是1,返回值的对应位置就是1。例如,表达式 204 I 24返回 220(204对应0b0_11001100,24对应 0b0_00011000,而220对应0b0_11011100)。
AND(&)操作符 二元操作符,执行按位AND。与按位OR 操作符相似,但只有两个操作数的同一个位置都是1,返回值的对应位置才是1.所以,284&24返回8(204对应0b0_11001100,24对应 0b0_0011000,而8对应 Ob0_00001000)。
XOR(︿)操作符 二元操作符,执行按位XOR(异或),只有在两个位置的值不同的前提下,返回值的对应位置才是1。所以,204︿24返回 212(0b011001100 ︿Ob0_0011000的结果是 0b0_11010100)。
可综合运用这些操作符来判断一个int 中单独位的值。例如,以下表达式使用左移位(<<)和按位AND(8)操作符判断在名为 bits的一个int 中,位于位置5（右数第6位)的二进制位是0还是1:

(bits &(1<< 5)!=0
注意 按位操作符从右向左计算位置。最右侧的位是位置0,右数第6位就是位置5。如bits变量包含十进制值42,即二进制Ob0_00101010。十进制值1的二进制是0b0_00000001,所以表达式1<<5的结果是0b0_00100000，,右数第6位是1。.因此,表达式bits &(1<<5)相当于0b0_00101010 & 0b0_00100000，,结果是Ob0_00100000(非零)。如bits 变量包含65,或者 0b0_01000001,那么表达式 0b0_0100001&0b0_00100000结果是0b0_0000000(零)。
虽然这已经是一个比较复杂的表达式,但和下面这个表达式(使用复合赋值操作符&=将位置6的位设为0)相比,其复杂性又显得微不足道了:
bits &=~(i<<5)
类似地,要将位置6的位设为1,可用按位OR(|)操作符。下面这个复杂的表达式以复合赋值操作符|=为基础:
bits |=(1 <<5)
这些例子的通病在于,虽然能起作用,但不能清楚表示为什么要这样写,我们搞不清楚它们是如何工作的。过于复杂,解决方案很低级。也就是说,无法对要解决的问题进行抽象,会造成难以维护的代码。

用索引器解决相同问题
现在,暂停对前面的低级解决方案的思索,将重点放在问题的本质上。现在需要的是将int作为一个由32个二进制位构成的数组使用,而不是作为int使用。所以,解决问题的最佳方案是将int想象成包含32位的一个数组!也就是说,如果bits是int,那么为了访问右数第6个二进制位,我们想这样写(记住索引从0开始):
 bits[5]
 为了将右数第4位设为true,我们希望能像下面这样写
bits[3]= true;
注意 C开发人员注意,Boolean值true等同于二进制值1,false等同于二进制值1所以,表达式bits[3] = true是指"将 bits变量右数第4位设为1".
遗憾的是,不能为int使用方括号记号法。该记号法仅适合数组或行为与数组相似的类型。所以,解决方案是新建一种类型,它在行为、外观和用法上都类似于bool数组,但用int实现。需为此定义一个索引器。假定新类型名为IntBits,其中包含一个int值(在构造器中初始化),但要将IntBits作为由bool变量构成的数组使用:
struct IntBits
{
	private int bits;
	//简单构造器,表达式主体方法足矣
	public IntBits(int initialBitvalue)s>bits = initialBitValue;
	//在这里写索引器
}
提示 由于IntBits很小,是轻量级的,所以有必要把它作为结构而不是类来创建。
定义索引器要采取一种兼具属性和数组特征的记号法。索引器由this关键字引入。在this之前指定索引器的返回值类型。在this之后的方括号中指定索引器的索引值类型。IntBits结构的索引器用整数作为索引类型,返回bool值,如下所示:
struct IntBits
{
	...
	public bool this[int index ]
	{
		get=>(bits &(1< index))!=0;
		set
		{
			if(value)//如value为true,就将指定的位设为1(开):否则设为0(关)
				bits | =(1<< index);
			else
				bits &=~(1 < index);
		}
	}
}
注意以下几点。
索引器不是方法———没有一对包含参数的圆括号,但有一对指定了索引的方括号。索引指定要访问哪一个元素。所有索引器都使用this关键字取代方法名。每个类或结构只允许定义一个索引器（虽然可以重载并有多个实现),而且总是命名为this。和属性一样,索引器也包含get和set这两个访问器。本例的get和set访问器包含前面讨论过的按位表达式。索引器声明中指定的index将用调用索引器时指定的索引值来填充。get和set访问器方法可以读取该实参,判断应访问哪一个元素。
注意 索引器应对索引值执行范围检查,防止索引器代码发生任何不希望的异常。好的实践是同时提供一种显示结构数据的方式。可重写ToString方法将值转换成二进制表示,例如:
struct IntBits
{
	...
	public override string ToString()
	{
		return(Comvert.ToString(bits,2);
	}
}
声明好索引器后,就可用IntBitS(而非int)类型的变量并使用方括号记号法:
int adapted =0b0_0111116;
IntBits bits = new IntBits(adapted);
bool peek =bits[6]; /获取索引位置6的bool值:应该是true(1)
bits[0] = true; //将索引e的位设为true(1)
bits[3]=false; //将索引3的位设为false(0)
Console.sriteLine($"(bits)"); //显示111011(0b0 01110111)
这个语法显然更容易理解。非常直观,而且充分捕捉到了问题的本质

理解索引器的访问器
读取索引器时,编译器自动将数组风格的代码转换成对那个索引器的get 访问器的调用。例如,以下代码转换成对bits的 get访问器的调用,index参数值设为6:
bool peek=bits[6];
类似地,向索引器写入时,编译器将数组风格的代码转换成对索引器的set访问器的调用,并将index参数设为方括号中指定的值。例如:
bits[3]= true;
该语句将转换成对 bits的set 访问器的调用,index值设为3。和普通属性一样,向索引器写入的值(本例是true)是通过 value关键字来访问的。value的类型与索引器本身的类型相同(本例是bool)。
还可在同时读取和写入的情况下使用索引器。这种情况要同时用到get 和set访问器。
例如,以下语句使用XOR操作符(")反转bits 变量索引6的二进制位
bits[6] ^= true;
它自动转换成以下形式:
bits[6]= bits[6]^true;
上述代码之所以能奏效,是由于索引器同时声明了get和set访问器。
注意 还可声明只包含get 访问器的索引器(只读索引器),或声明只包含set访问器的索引器(只写索引器)。

对比索引器和数组
索引器的语法和数组非常相似,但仍然存在一些重要区别。
索引器能使用非数值下标,而数组只能使用整数下标,示例如下:
public int this[string name ]{...}//合法
提示 一些集合类以键/值(key/value)对为基础实现了关联式(associative)查找功能。许多这样的集合类(如 Hashtable)都实现了索引器,从而避免了使用不直观的Add方法来添加新值,还避免了遍历Values属性来定位特定的值。
例如,可以不这样写:
Hashtable ages = new Hashtable();
ages.Add("John",42);
而是像这样写
Hashtable ages = new Hashtable();
ages["John"]= 42;
索引器能重载(和方法相似),数组则不能:
public Name this [PhoneNumber number]{...}
public PhoneNumber this[Name name ]{...}
索引器不能作为 ref或out 参数使用,数组元素则能:
IntBits bit: //bits 包含一个索引器
Method(ref bits[1]);// 编译错误
属性、数组和索引器
可让属性返回一个数组,但记住数组是引用类型,数组作为属性公开可能不慎覆盖大量数据.以下结构公开了名为Data的数组属性：
struct Wrapper
{
	private int[] data;
	...
	public int[] Data
	{
		get> this.data;
		set=> this.data =value;
	}
}
再来看看使用了这个属性的代码:
wrapper wrap = new wrapper();
...
int[]myData = wrap.Data;
mypata[0]++;
myData[1]++;
表面上这些代码无害。但由于数组是引用类型,所以变量myData引用的对象就是wrapper结构中的私有data变量所引用的对象.对myData中的元素进行的任何修改,都会同时作用于data数组;表达式myData[9]++的效果与data[6]++完全相同.如果这并非你的本意,那么为了避免发生问题,应该在 Data属性的 get和set 访问器中使用Clone方法返回data数组的拷贝,或者创建要设置的值的拷贝,如下所示，注意Clone方法返回一个object,必须把它转型为整数数组
struct wrappe
{
	private int[]data;
	...
	public int[] Data
	{
		get(return this.data.Clone() as int[];) 
		set(this.data= value.Clone()as int[];)
	}
}
但这会造成相当大的混乱,而且内存的利用率也会显著下降。索引器提供了这个问题的一个自然解决之道——不将整个数组都作为属性公开;相反,只允许其中单独的元素通 过索引器来访问：
struct Wrapper
{
	private int[]data;
	...
	public int this [int i]
	{
		get => this.data[1];
		set => this.data[1]= value;
	}
}
以下代码采用和前面使用属性相似的方式使用索引器:
Wrapper wrap = new urapper();
...
int[]myData= new int[2];
myData[e]= wrap[0];
myData[1]= wrap[1]
myData[e]++;
myData[1]++;
这一次,对MyData 数组中的值进行递增,不会影响 Mrapper对象中的原始数组,如果真的想修改wrapper对象中的数据,必须像下面这样写：
 wrap[0]++;
这显得更清晰、也更安全!

接口中的索引器
接口可以声明索引器。为此需要指定get以及/或者set关键字,但get和set访问器 的主体要替换成分号。实现该接口的任何类或结构都必须实现接口所声明的索引器的访问器,例如:
interface IRawInt
{
	bool ths[int index ]{get;set;}
}
struct RawInt:IRawInt
{
	...
	public bool this[int index ]
	{
		get{ ..)
		set{..）
	}
}
在类中实现接口要求的索引器时,可将索引器的实现声明为virtual,从而允许派生类重写get和set 访问器。例如,前面的例子可改写成以下形式:
class RaInt:IRawInt
{
	...
	public vrtual bool this[int index ]
	{
		get {..}
		set{...）
	}
	...
}
还可附加接口名称作为前缀,通过"显式接口实现"语法来实现索引器。索引器的显式实现是非公共和非虚的(所以不能被重写),例如:
struct RawInt:IRawInt
{
	...
	bool IRasInt.this[int index ]
	{
		get{...）
		set{...)
	}
	...
}
在 Windows 应用程序中使用索引器
以下练习将研究一个简单的电话簿应用程序,并完成它的实现。任务是在PhoneBook类中写两个索引器:一个获取Name参数并返回PhoneNumber;另一个获取PhoneNumber参数并返回Name。Name和PhoneNumber这两个结构已经写好了。还要从程序的正确位置调用这些索引器,熟悉应用程序
1.如果MicrosoftVisual Studio 2017尚未启动,请启动。
2.打开 Indexers 解决方 案,它位于"文档"文件夹下的Microsof
Press\VCSBS\Chapter16\lndexers 子文件夹。
该图形应用程序允许根据联系人查找电话号码,或根据电话号码查找联系人。
3.选择"调试"|"开始调试"。
随后生成并运行项目。屏幕显示一个窗体,其中包含两个空白文本框,标签分别是Name(姓名)和Phone Number(电话号码)。窗体最开始显示两个按钮:一个根据姓名查电话号码,另一个根据电话号码查姓名。展开底部的命令栏显示附加的Add按钮,它将一对姓名/电话号码添加到应用程序维护的姓名和电话号码清单中。目前,这些按钮什么都不做。你的任务是完成应用程序,使这些按钮能够工作。
4.返回Visual Studio 2017并停止调试。
5.在"代码和文本编辑器"中打开Name.cs 源代码文件。检查 Name结构,它用于容纳所有姓名。
姓名作为字符串提供给构造器。通过只读字符串属性Text 获取姓名(在由Name值构成的数组中搜索时,要使用Equals和GetHashCode方法比较Name,暂时可以忽略这两个方法)。
6.在"代码和文本编辑器"中打开 PhoneNumber.cs 源代码文件,检查 PhoneNumber结构。它和Name结构非常相似。
7.在"代码和文本编辑器"中打开PhoneBook,cs源代码文件,检查 PhoneBook 类。该类包含两个私有数组:一个数组由 Name 值构成,名为 names;另一个数组由PhoneNumber值构成,名为phoneNumbers。PhoneBook 类还包含一个Add方法,用于向电话簿添加电话号码和姓名。单击窗体上的 Add 按钮将调用该方法。Add会调用enlargeIfFul1方法,以便在用户添加数据项时检查数组是否已满。如有必要,enlargeIfFull方法会创建两个新的、更大的数组,将现有数组的内容复制过去,然后丢弃旧数组。
Add方法故意设计得这么简单,它不检查要添加的姓名或电话号码是否重复。PhoneBook 类目前没有提供查找姓名或电话号码的功能,要在下个练习中添加两个索引器来提供这些功能。
编写索引器
1.在 PhoneBook.cs 源代码文件中删除//TO0O:write 1st indexer here注释,替换成 PhoneBook类的公共只读索引器（如加粗的代码所示),它返回一个Name,接受一个 PhoneNumber作为索引。让 get访问器的主体为空。
索引器应该像下面这样:
sealed class PhoneBook
{
	...
	public Name this[PhoneNumber number]
	{
		get
		{
		}
	}
	...
}
2.实现get访问器,如加粗的代码所示。该访问器作用是查找与指定电话号码匹配的姓名。为此需要调用Array类的静态方法IndexOf。IndexOf方法搜索数组,返回和指定值匹配的第一项的索引。IndexOf方法第一个参数是要搜索的数组
(phoneNumbers);第二个是要搜索的项。找到匹配项,IndexOf 就返回该元素的整数索引;否则返回-1.索引器找到电话号码应返回对应的姓名,否则应返回一
个空的Name 值。(注意 Name是结构,所以肯定有一个默认构造器将它的私有name字段设为null。)
sealed class PhoneBook
{
	...
	public Name this[PhoneNumber number]
	{
		get
		{
			int 1= Array.IndexOf(this.phoneNumbers, number);
			if(1l= -1)
			{
				return this.names[1];
			}
			else
			{
				 return new Name();
			}
		}
	}
}
3.在 PhoneBook类中删除//TODO:write 2nd indexer here注释,替换成第二个公共只读索引器,它返回一个PhoneNumber,接受一个Name 参数。采用和第一个索引器相同的方式实现。(再次提醒,PhoneNumber是结构,始终有默认构造器)。
第二个索引器如下所示:
sealed class PhoneBook
{
	...
	public PhoneNumber this [Name name]
	{
		get
		{
			int i Array.IndexOf(this.names,name);
			if(i1=-1)
			{
				return this.phoneNlumbers[i];
			}
			else
			{
				return new PhoneNumber();
			}
		}
	}

}
注意,两个重载索引器之所以能共存,是因为它们索引的是不同类型的值,这意 味着签名不同。将 Name和PhoneNumber 结构替换成简单字符串(也就是它们包装的内容),两个重载的索引器就具有相同的签名,类将无法通过编译。
4.选择"生成"|"生成解决方案",纠正任何打字错误;如有必要,请重新生成。
调用索引器
1.在"代码和文本编辑器"中打开 MainPage.xaml.cs 源代码文件,找到其中的findByNameclick方法。
单击Find by Name(按姓名搜索)按钮将调用该方法。方法目前空白。将//T000:注释替换成后面加粗的代码来执行以下任务。
1.1 读取窗体上的name文本框的Text属性值。这是一个字符串,其中包含用户键入的联系人姓名。
1.2 如果字符串不为空,就使用索引器在 PhoneBook 中搜索与那个姓名对应的电话号码(注意,MainPage类包含名为phoneBook的私有PhoneBook 字段);基于字符串来构造 Name对象,把它作为参数传给 PhoneBook索引器。
1.3 如果索引器返回的 PhoneNumber结构的Text属性值不为null或空白字符串,就将该属性的值写入 phoneNumber 文本框:否则显示文本"Not Found"。完成后的findByNameClick方法应该像下面这样:
private vold findByName(lick(object sender,RoutedEventArgse)
{
	string text = name.Text;
	if(IString.IsullorEmpty(text))
	{
		Name personsName = new Name(text);
		Phonenumber personsPhonelumnber= this.phoneBook[personsName];
		Phonenumber. Text =String.IsNullOrEmpty(personsPhoneNumber.Text)?
							"Not Found":personsPhoneNumber.Text;
	}
}
除了访问索引器的语句,上述代码还有两个值得注意的地方。
第一,String的静态方法IsNullOrEmpty判断字符串是否空白或包含null值。这是测试字符串是否包含值的首选方法。包含null或空字符串("")将返回true,否则返回false。
第二,?:操作符就像嵌入的if_else 语句那样填充 phoneNumber 文本框的Text属性。作为三元操作符,它要获取以下三个操作数:Boolean表达式,在 Boolean表达式为true 时求值并返回的表达式,以及在Boolean表达式为false 时求值并返回的表达式。上述代码如果表达式IsNul1OrEmpty(personsPhoneNumber.Text)为 true,表明电话簿中未找到匹配项,所以显示文本"Not Found",否则显示personsPhoneNumber 变量的Text属性值?:操作符的常规形式如下:Result-<Boolean 表达式>?<为true时求值的表达式>:<为false时求值的表达式

2. 在 MainPage.xaml.cs 文 件中找 到 findByPhoneNumberClick 方法（位于findByNameClick方法下方)。单击Find by Phone Number(按电话号码搜索)按钮将调用该方法。方法目前空白,只有一条//TO0O:注释。需要像下面这样实现它。(要添加的代码加粗显示。)
2.1 读取窗体上的phoneNumber 文本框的Text属性值。这是字符串,其中包含用户键入的电话号码。
2.2 如果字符串不为空,就使用索引器在PhoneBook中搜索与电话对应的姓名。
2.3 将索引器返回的Name结构的Text属性的值写入 name 文本框。
完成之后的方法应该像下面这样
private vold findByPhoneNumberClick(object sender,RoutedEventArgs e)
{
	string text= phoneNumber.Text;
	if(IString.IsAullorEmpty(text))
	{
		honeNlumber personsPhoneNumber = new Phoneumber(text);
		Name personsName = this.phoneBook[personsPhoneNumber];
		name Text =String.IsNullOrEmpty(personsName.Text)?
					"Not Found":personsName.Text;
	}
}
3.选择"生成"|"生成解决方案"命令。纠正所有打字错误。

测试应用程序
1.选择"调试"|"开始调试"命令。
2.在相应的文本框中输入你的姓名和电话号码,点击命令栏,单击Add按钮。单击Add按钮后,Add方法会将数据项放到电话簿中,并清除所有文本框,使它们准备好执行一次搜索。
3.重复步骤 2数次,每次都输入不同的姓名和电话号码,使电话簿中包含多个数据项。注意,应用程序不对输入进行有效性检查,而且允许多次输入相同的姓名和电话号码。为免混淆,请确定每次都提供不同的姓名和电话号码。
4. 将步骤2~3输入的一个姓名输入Name 文本框,单击Find byName。随即从电话簿中检索到添加的电话号码,并在Phone Number 文本框中显示。
5.在 Phone Number 文本框中输入不同联系人的电话号码,单击Find by PhoneNumber。会从电话簿中检索到联系人的姓名,并在Name 文本框中显示。
6.在Name文本框中输入没有在电话簿中输入过的姓名,单击 Find by Name。这一次,Phone Number文本框显示""Not Found"。
7.关闭窗体,返回Visual Studio2017.

泛 型 概 述
解释泛型的用途
使用泛型定义类型安全的类
指定类型参数来创建泛型类的实例
实现泛型接口

定义泛型方法,实现独立于要操作的数据类型的算法
前面讲述了如何使用object类型引用任何类的实例。可用object类型存储任意类型的值。此外,要将任意类型的值传给方法,可定义object类型的参数。还可将object作为返回类型,让方法返回任意类型的值。虽然这是一个十分灵活的设计,但也增加了程序员的负担,因为程序员必须记住实际使用的是哪种数据。如果不小心犯错,就可能造成运行时错误。本章将探讨泛型的概念,它的设计宗旨就是帮助程序员避免这种错误。
object的问题
为理解泛型,首先要理解它们解决的是什么问题。
假定要建模一个先入先出队列,可创建一个下面这样的类
class Queue
{
	private const int DEFAUTQUEUESIZEa 109;//默认队列大小
	private int[] data;
	private int head=6,tall =6;//头和尾
	private int numElements= 0;

	public Queue()
	{
		this.data new int[DEFAULTQUEUESIZE];
	}
	public Queue(int size)
	{
		if(size>0)
		{
			this.data= new int[size];
		}
	else
	{
		throw new ArgumentOutOfRangeException("size","Must be greater than zero");
	}
	}
	public void Enqueue(int item)//入队
	{
		if(this.numElements mm this.data.Length)
		{
			throw new Exception("Queue full");
		}
		this.data[this.head]= item;
		this.head++;
		ths.head this.data.Length
		this. nunElementS++;
	}
	public int Dequeue()// 出队
	{
		if(this.numElements == 0)
		{
			throw new Exception("Queue empty");
		}
		int queueItem = this.data[this.tail];
		this.tail+;
 		this.tall?this.data.Length;
		this.numElements--;
		return queueltem;
	}
}
该类利用一个数组提供循环缓冲区来容纳数据。数组大小由构造器指定。应用程序使用 Enqueue(入队)方法向队列添加数据项,用Dequeue(出队）方法从队列中取出数据项。私有head(头)和 tail(尾)字段跟踪在数组中插入和取出数据项的位置。numElements字段指出数组中有多少数据项。Enqueue和Dequeue方法利用这些字段判断在哪里存储或获取数据项,以及执行一些基本的错误检查。应用程序可像下面这样创建Queue对象并调用这些方法。注意数据项出队顺序和入队顺序一样。
Queue queue = new Queue();//新建队列
queue.Enqueue(100);
queue.Enqueue(-25)
queue. Enqueve(33);
Console.iriteLine($"(queue.Dequeue()}");//显示100 Console.iriteLine($"(queue.Dequeue()}");//显示-25
Console.writeLine($"(queve.Dequeve()");//显示33
Queue类能很好地支持 int 队列,但如果要创建字符串队列,float 队列,甚至更复杂类型(比如Circle,或者Horse或whale)的队列又该怎么办呢?现在的问题是,Queue类的实现限定int类型的数据项。试图入队一个Horse会发生编译时错误。
Queue queue new Queue();
Horse myHorse = new Horse();
queue.Enqueue(mytorse);/编译时错误:不能将Horse转换成int
绕开该限制的一个办法是指定Queue类包含 object类型的数据项,更新构造器,修改Enqueue和 Dequeue方法来获取object 参数并返回 object,如下所示:
class Queue
{
	...
	private object[]data;
	...
	public Queue()
	{
		this.data a new object[DEFAULTQUEUESIZE];
	}
	public Queue(int size)
	{
		...
		this.data = new object[size];
		...
	}
	public void Enqueue(object item)
	{
		...
	}
	public object Dequeue()
	{
		...
		object queueItem = this.data[this.tail];
		...
		return queueItem;
	}
}
可用object 类型引用任意类型的值或变量。所有引用类型都自动从.NET Framework的 System.0bject 类继承(无论直接还是间接)。C#的 object是System.0bject的别名。
现在,由于Enqueue和Dequeue 方法操纵的是 object,所以可以处理Circle、Horse、whale或其他任何类型的队列。但必须记住将Dequeue方法的返回值转换为恰当的类型,因为编译器不自动执行从object 向其他类型的转换。
Queue qeue = new Qeue();
Horse mybrse new Horse();
queue.Enqueue(myHorse);//现在合法了-Horse是objet
...
Horse dequeuedHorse =(Horse)queue.Dequeue();//需要将object转换回Horse
如果没有对返回值进行类型转换,就会报告如下所示的编译器错误:
无法将类型从"object"隐式转换为Horse"
由于要求显式类型转换,导致 object类型所提供的灵活性大打折扣。很容易写出下面这样的代码:
queue queue - new Queue();
Horse myHorse = new Horse();
queue.Enqueue(myHorse);
...
Circle myCircle =(Circle)queue.Dequeue();//运行时错误
上述代码能通过编译,但运行时会抛出System.InvalidCastException异常。之所以出错,是因为代码试图将一个Horse引用存储到Circle变量中,但两种类型不兼容。这个错误只有在运行时才会显现,因为编译器在编译时没有足够多的信息来执行检查。只有运行时才能确定出队对象的实际类型。
使用object类型创建常规类和方法的另一个缺点是,如果"运行时"需要先将object转换成值类型,再从值类型转换回来,就会消耗额外的内存和处理器时间。例如,以下代码对包含int 变量的队列进行操作:
Queue queue a new Queue()
int myInt 99;
queue.Enqueue(myInt); //将int装箱成object
...
myInt -(int)qucuo.Dequcuc(); ();//将 objoct 拆箱成int
Queue数据类型要求它容纳的数据项是 object,而 object是引用类型。对值类型(例如int)进行入队操作,要求通过装箱转换成引用类型。类似地,为了出队成int,要求通过拆箱转换回值类型。虽然装箱和拆箱是透明的,但会造成性能开销,因为需进行动态内存分配。虽然对于每个数据项来说开销不大,但创建由大量值类型构成的队列时,累积起来的开销就不容乐观了。

泛型解决方案
C#通过泛型避免强制类型转换,增强类型安全性,减少装箱量,并让程序员更轻松地创建常规化的类和方法。泛型类和方法接受类型参数,它们指定了要操作的对象的类型。
C#是在尖括号中提供类型参数来指定泛型类,如下所示:
class Queue<T>
{
	...
}
T是类型参数,作为占位符使用,会在编译时被真正的类型取代。写代码实例化泛型Queue时,需指定用于取代T的类型(Circle,Horse,int等)。在类中定义字段和方法时,可用同样的占位符指定这些项的类型,例如:
class Queue(T>
{
	...
	private T[]data;//数组是'T'类型,'T'称为类型参数
	...
	public Queue()
	{
		this.data new T[DEFAULTQUEUESIZE];//'T'作为数据类型
	}
	public Queue(int size)
	{
		...
		this.data = nesw T[size];
		...
	}
	public void Enqueue(Titem)//'T'作为方法参数类型
	{
	...
	}
	public TDequeue()//'T'作为返回址的类型
	{
		...
		T queueItem = this.data[this.tail];//数组中的数据是'T''类型
		...
		return queueItem;
	}
}
虽然一般都使用单字符T,但类型参数T可以是任何合法C#标识符。它会被创建Queue忖象时指定的类型取代。下例创建一个int 队列和一个 Horse 队列
<Qeuexint> intQueue new Queue<int>();
QueuecHorse>horseQueue = new Queue(Horse>();
另外,编译器有足够的信息在生成程序时执行严格的类型检查。无需在调用 Dequeue方法时执行强制类型转换,编译器能提早(而非等到运行时)发现任何类型匹配错误:
intQueue. Enqueue(99);
int myInt = intQeue.Dequeue(); //无需转型
Horse myrorse= intQueue.Dequeue(); //编附时错误
									//无法将类型从"int"隐式转换为"Horse"
要注意,用指定类型替换T不是简单的文本替换机制。相反,编译器会执行全面的语义替换,所以可为T指定任何有效的类型。下面列出了更多的例子。
strut Person
{
	...
}
...
Queue<int》intQueue new Queue<int>();
Queue<Person> persorQueue = new Queue<Person>();
第一个例子创建整数队列,第二个创建 Person值的队列。编译器为每个队列生成各I版本的 Enqueue和 Dequeue方法。intQueue 队列的方法如下:
public void Enqueue(int item);
public int Dequeue();
personQueue 队列的方法如下:
public void Enqueue(Person item);
public Person Dequeue();
将这些定义与上一节基于object的版本比较。在从泛型类派生的方法中,Enqueue的item参数作为值类型传递,所以不要求在入队时装箱。类似地,Dequeue 返回的值也是值类型,不需要在出队时拆箱。
注意 System. Collections.Generics命名空间提供了Queue 类的实现,它的工作式和刚才描述的类相似。该命名空间还包含其他集合类。
类似参数不一定是简单类或值类型。例如,可创建由整数队列构成的队列(如果觉得有用的话):
QueuecQueue<int>qeueQueue = new Queue<Queue<int>>();
泛型类还可指定多个类型参数。
例如泛型类 System.Collections.Generic.Dictionary
需要两个类型参数:一个是键(key)的类型,另一个是值(value)的类型。
注意 还可使用和定义泛型类一样的语法定义泛型结构和接口。

对比泛型类和常规类
必须注意,使用类型参数的泛型类（generic cla)有别于常规类(generalized class),后者的参数能强制转换为不同的类型。例如,前面基于 object 的Queue类就是常规类,该类只有一个实现,它的所有方法获取的都是 object 类型的参数,返回的也是object类型。
可用这个类来容纳和处理int、string以及其他许多类型的值,但任何情况使用的都是同一个类的实例,必须将使用的数据转型为object,或者从object转型为正确的数据类型。
把它和泛型类Queue<T>类比较。每次为泛型类指定类型参数时(例如Queuexint>或者Queue<Horse>),实际都会造成编译器生成一个全新的类,它"恰好"具有泛型类定义的功能。这意味着Queue<int>和Queue<Horse>是全然不同的两个类型,只是"恰好"具有相同的行为。可以想象泛型类定义了一个模板,编译器根据实际情况用该模板生成新的、有具体类型的类。泛型类的具体类型版本(例如Queue<int>,Queue<Horse>等)称为已构造类型(constructed type)。它们应被视为不同的类型(尽管有一组类似的方法和属性)。

泛型和约束
有时要确保泛型类使用的类型参数是提供了特定方法的类型。例如,假定要定义一个PrintableCollection(可打印集合)类,就可能想确保该类存储的所有对象都提供了Print方法。这时可用约束来规定该条件。
约束限制泛型类的类型参数实现了一组特定接口,因而提供了接口定义的方法。例如,假定IPrintable接口定义了Print方法,就可像这样定义 PrintableCollection类:
public class PrintableCollection<T>where T:IPrintable
该类编译时,编译器验证用于替换T的类型实现了IPrintable接口。没有就报告编译错误。

创建泛型类
.NET Framework类库在System.Collections.Generic命名空间提供了大量现成的泛型类。当然也可定义自己的,但在此之前,首先要掌握一些背景知识。
二叉树理论
以下练习将定义并使用一个代表二叉树的类。
二叉树或二分树(binary tree)是一种有用的数据结构,可用它实现大量操作,其中包括以极快速度来排序和搜索数据。
二叉树是一种递归(自引用)数据结构,要么空,要么包含3个元素:一个数据,通常把它称为节点;以及两个子树(本身也是二叉树)。两个子树通常称为左子树和右子树,因其分别位于节点左侧和右侧。每个左子树或右子树要么为空,要么包含一个节点和另外两个子树。理论上说,整个结构可以无限继续下去。下图展示了一个小型二叉树结构。二叉树的强大体现在数据排序上。假定最开始的是一组无序排列的对象,所有对象都是相同类型,就可用它们构造一个排好序的二叉树,然后遍历该树,访问其中每一个节点。
下面是在排好序的二叉树8中插入数据项I的算法(伪代码):
If the tree,8,is empty //如果树2 
Then
	Construct a new tree Bwith the new item I as the node, and empty left and right sub-trees es//就构造树B,新项I作为节点,并构造空白的左右子树
Else
	Examine the value of the current node,N,of the tree,B//检查树B的节点N的值 
	If the value of N is greater than that of the new item,I //如课果N大于新项I的值
	Then
		If the left sub-tree of B is empty s empty//如果B的左子树为空 
		Then
			Construct a new left sub-tree of 8 with the item I as the node, empty left and right sub-trees //就为B构造一个新的左子树,I作为节点,
							//左右树空白
		Else
			Insert I into the left sub-tree of B//将I插入B 的左子树 
		End If
	Else
		If the right sub-tree of 8 is empty //如果8的右子树 
		Then
			Construct a new right sub-tree of B with the item I as the node,and empty left and right sub-trees trees//就为8构一个新的右子树,I作为
										//左右子树空白 
		Else
			Insert I into the right sub-tree of 8//将I插入8的右子树
		End If
	End If
End If
注意，这是递归算法,反复调用自身,将数据项插入左子树或右子树——具体取决于数据项与树的当前节点进行比较的结果。
注意 在伪代码中,表达式 greater than(大于)的定义依赖于数据类型。对于数值数据,greater than可能是一个简单的算术比较;对于文本数据,它可能是一个字符串比较;但是,其他形式的数据必须提供自己的比较算法。
如果刚开始拿到的是一个空二叉树和一个无序对象序列,可遍历该序列,用上述算法将每个对象插入二叉树,最终获得一个有序树。有序二叉树之后,就可依次访问每个节点,打印找到的值,最终完整显示这个树的内容。完成这个任务的算法也是递归的:
If the left sub-tree is not epty //如果左子树非空
Then
	Display the contents of the left sub-tred //显示左子树的内容
End If
Display the value of the node //显示节点的值
If the right sub-tree is not empt) //如果右子树控
Then
	Display the contents of the right sub-tree //显示右子树的内容
End If

使用泛型构造二叉树类
以下练习将用泛型来定义一个二叉树类,它能容纳几乎任意类型的数据。唯一的限制 是:任何类型都必须提供一种方式来比较两个实例的值。
二叉树类在许多应用程序中都能大显身手。所以最好把它作为一个类库来实现,而不 是作为单独的应用程序来实现。这样就可以在其他地方重用该类,无需复制源代码,也无 需重新编译。类库是已经编译好的多个类(以及其他类型,例如结构和委托)的集合,所有这些类型都存储在程序集中。程序集是一个通常采用.d扩展名的文件。为了在其他项目和 应用程序中使用类库,可添加对它的程序集的引用,然后使用using语句将它的命名空间 引入当前作用域。稍后测试二叉树类时将展示具体做法。
System.IComparable和 System.IComparable<T)接口
在二叉树中插入节点要求将播入节点的值与树中现有节点比较、如使用数值类型,比 如int,那么完全可以使用<,>和=m操作符,但如果使用其他类型,比如以前描述的Mammal或Circle,如何比较对象?
如创建的类要求能根据某种自然(或非自然)的排序方式比较值,就应实现IComparable接口,该接口包含 CompareTo方法,它接受单个参数(指定要和当前实例比较的对象),返 回代表比较结果的整数,如下表所示
值 				含义
小于0 		当前实例小于参数值
0			当前实例等于参数值
大于0		当前实例大于参数值
以描述的Circle类为例。类的定义如下:
class Circle
{
	public Circle(int initialRadius)
	{
		radius initialRadius;
	}
	public double Area()
	{
		return Math,PI*radius*radius;
	}
	private double radius;
}
为使Circle类变得"可比较",可实现 System.IComparable接口并提供CompareTo方法,下例的 CompareTo 方法将根据面积来比较两个Circle 对象.我们说面积较大的圆"大于"面积较小的圆。
class Circle:System,IComparable
{
	...
	public int CompareTo(object obd)
	{
		Circle circ0bj=(CIrcle)ob;//将参数转换为它的真正类型
		if(this.Area()m- circObj.Area())
			return 0;
		if(ths.Area()> circObj.Area())
			return 1;
		return -1;
	}
}
研究一下System.IComparable接口,会发现它的参数被定义成一个object.但这不是类型安全的.为了理解原因,请考虑一下这种情况:试图将一个不是Circle的东西传给CompareTo方法会发生什么?System.IComparable接口要求使用一次强制类型转换来访问Area方法,如实参不是Circle,而是其他类型的对象,转型就会失败.为确保类型安全,应使用System命名空间定义的泛型IComparable<T>接口,它定义了以下方法：
int Comparefo(T other);
注意，方法获取的是类型参数（T,而不是object.所以,它们比接口的非泛型版本安全得多,以下代码在Circle类中实现该接口:
class Circle:System.IComparable<Circle>
{
	...
	public int ConpareTo(Circle other)
	{
		if(this.Area()=other.Area()
			return 0;
		if(this.Area()>other.Area())
			return 1;
		return -1;
	}
}
ComareTo方法的参数必须与接口IComparable<Circle>中指定的类型匹配,最好是实现 SystemIComparable<T>而非System.IComparable接口.当然也可同时实现两个;
事实上,.NETFramework中的许多类型都是这样做的(同时实现两个版本的接口)。
创建Tree<TItem>类
1.如果Visual Studio 2017尚未启动,请启动
2..选择"文件"|"新建"|"项目"。
3.在"新建项目"对话框中,在左侧的模板窗格中单击Visual CH。在中间窗格选择"类库(NET Framework)"模板。在"名称"文本框中输入BinaryTree.在"位置"文本框中指定"文档"文件夹下的Microsoft Press\VCSBSIChapter 17\子文件夹。单击"确定"按钮。
注意 一定要选择"类库(NETFramework)"模板,而不是"类库(NETStandard)".前者包含Windows 专用功能,这些功能是.NET Standard模板不提供的。
类库模板创建由多个程序重用的程序集。要在应用程序中使用某个类库中的类,必须先将包含已编译代码的程序集复制到自己的电脑（如果不是自己创建的话),并添加对该程序集的引用。
4.在解决方案资源管理器中右键单击Classl.cs,从弹出菜单中选择"重命名",将文件名改成Tees.如看到提示,请允许Visual Studio更改类名和文件名。
5.在"代码和文本编辑器"中将Tree类的定义改成Tree<TItem>,如加粗部分所示:
public class Tree<TItem>
{
}
6.在"代码和文本编辑器"中修改Tree<TItem>类的定义,指定类型参数TItem必须是实现了泛型IComparable<TItem>接口的类型,如加粗部分所示:
public class Tree<TItem> where TItem:IComparable<TItem>
{
}
7.在Tree<TItem>类中添加三个公共自动属性:一个是TItem属性,名为NodeData;另两个是 Tree<TItem>属性,,分别名为LeftTree和 RightTree,如加粗代码所示:
publicclass Tree<TItemy where TItem:IComparable<TItem>
{
	public TItem NodeData{get;set;}
	public Tree<TItem LeftTree{ get;set;
	public Tree<Ttem RightTree（get;set;)
}
8.在Tree<TItem>类中添加构造器,获取一个名为 nodeValue的TItem参数。在构造器中将NodeData属性设为 nodevalue,并将 LeftTee和RightTree属性初始化为null,如加粗的代码所示:
public class Tree(TItemwhere TItem:IComparable<TItem>
{
	public Tree(TItem nodevalu)
	{
		this.NodeOata nodeValue;
		this.LeftTree a null;
		this.RightTree a null;
	}
	...
}
注意 构造器名称不能包含类型参数,它名为Tree,而不是Tree<TItem>
9.在Tree<TItem>类中添加公共方法Insert,如加粗的代码所示.用于将一个TItem值插入树
public class Tree<TItem>where TItem:IComparable<TItem>
{
	...
	public vodd Insert(TItem newItem)
	{
	}
}
Insert方法将实现早先描述的递归算法,从而创建一个排好序的二叉树。由于程序员要用构造器在树中插入初始节点(类没有默认构造器),所以Insert方法可以假定树非空。下面重复了前面的伪代码算法的一部分,它们是在检查了树是否空白之后执行的。稍后将根据这些伪代码编写Insert方法:
...
Example the value of the node,N,of the tree,B      //检查树B的节点N的值
If the value of N is greater than that of the new item,I   //如果N大于新项I的值
Then
	If the left sub-tree of B is empty
	Then
		Construct a new left sub-tree of B with the item I as the node,and empty left and right sub-trees	//就为B检一个新的左子树,I作为节点
									//左右子树空自

	Else
		InsertI into the left sub-tree of i //将I插入B的左子树
End if 
...
10.在 Insert 方法中添加一个语句来声明 TItem 类型的局部变量,命名为currentNodevalue。将该变量初始化成树的NodeData属性的值,如下所示:
public void Insert(ITem newItem)
{
	TIem currentNodeValue = this.NodeData;
}
11.在Insert方法中,在刚才添加的currentNodevalue变量定义之后,添加以下加粗的if-else 语句。该语句使用 IComparable<TItem>接口的CompareTo方法判断当前节点的值是否大于新项(newItem)的值:
public void Insert(TItem nesaItem)
{
	Item currentNodevValue - this.NodeData;
	if(currentNodevalue.CompareTo(newItem)>0)
		{
			//将新项插入左子树
		}
	else
	{
		//将新项插入右子树
	}
}
12.将注释"//将新项插入左了树"替换成以下代码块:
if(thds.LeftTree = null)
{
	this.LeftTree = new Tree<TItem）(newItem);
}
else
{
	this.LeftTree.Insert(nesdItem);
}
这些语句检查左子树是否为空。是就用新项来创建一个新树,并把它设为当前节点的左子树:否则递归调用Insert方法,将新项插入现有的左子树中。
13.将注释"//将新项插入右子树"替换成相似的代码,将新节点插入右子树:
if(this.RightTree = null)
{
	this.RightTree = new Tree<TItem>(nesMItem);
}
else
{
	this.RightTree.Insert(neMatem);
}
14.在Tree<TItem>类中添加另一个公共方法,命名为walkTree。该方法将遍历树,顺序访问每个节点,并生成节点数据的字符串形式。方法定义如下所示:
public string WalkTree()
{
}
15.在MalkTree方法中添加以下加粗的语句。这些语句实现了早先描述过的二叉树遍历算法。访问每个节点时,都将节点值连接到结果字符串中。
public string MalkTree()
{
	string result = "";

	if (this.LeftTree ! = null)
	{
		result · this.LeftTree. MalkTree();
	}
	result = $"{this.Modeota.ToString()}";

	if(this. RightTree I= null)
	{
		result = this.RdghtTree.kalkTree();
	}
	return result;
}
16.选择"生成""|"生成解决方案"。类应该正确通过编译。如有必要,纠正任何打字错误,并重新生成解决方案。
下个练习将创建由整数和字符串构成的二叉树,从而测试 Tree<TItem>类。
测试 Tree<TItem>类
1. 在解决方案资源管理器中右键单击BinaryTree 解决方案,从弹出菜单中选择"添加"│"新建项目"。
注意 一定要右键单击BinaryTree解决方案而不是 BinaryTree项目。
2. 新项目使用"控制台应用(.NETFramework)"模板,命名为BinaryTreeTest,位为"文档"文件夹下的Microsoft Press\VCSB\Chapter 17子文件夹。单击"确定"按钮。
3.在解决方案资源管理器中右键单击BinaryTreeTest 项目。从弹出菜单中选择"设为启动项目"命令。
BinaryTreeTest 项目会在解决方案资源管理器中突出显示。运行应用程序时实际执行的就是该项目。
4.在解决方案资源管理器中右键单击BinaryTreeTest 项目。选择"添加"│"引用"。
5.在"引用管理器"对话框左侧窗格展开"项目",单击"解决方案",在中间窗格勾选BinaryTee项目,单击"确定"。
BinaryTree程序集将在解决方案资源管理器的BinaryTreTest项目的引用列表中出现。检查 BinaryTreeTest 项目的"引用"文件夹,会发现最顶部就是 BinaryTree程序集。现在可以在BinaryTreTest项目中创建 Tree<TItem）对象了。
注意 如果类库项目和使用该类库的项目不在同一个解决方案中,就必须添加对程序集(dl文件)的引用,而不是添加对类库项目的引用。为此,需要在"引用管理器"对话框中浏览程序集。本章最后一个练习将采用这个技术.
6.在"代码和文本编辑器"中显示 Program类,在类的顶部添加以下 using指令:
using BinaryTree；
7.在 Main方法中添加以下加粗的语句:
static void Nain(string[] args)
{
	Tree<int> tree = new Treecintb(10);
	treel.Insert(5);
	treel.Insert(11);
	tree1.Insert(5);
	tree1.Insert(-12);
	treel.Insert(15);
	tree1.Insert(0);
	tree1.Insert(14);
	treel.Insert(-8);
	tree1.Insert(19);
	tree1.Insert(8);
	tree1.Insert(8);

	string sortedData = tree1.salkTree();
	Console.MriteLine($"sorteddata is:(sortedDrta)";
}
这些语句新建二叉树来容纳 int值。构造器创建包含值19的初始节点。Insert语句在树中添加节点,MalkTree方法返回代表树内容的字符串,内容按升序排序。
注意 C#的int关健字实际是System.Int32类型的别名。每次声明int变量,实际声明的是 System.Int32类型的结构变量.System.Int32类型实现了IComparable和IComparable<T>接口,因此才可以创建Tree<int>对象.类似地,string关健字是System.String的别名,它也实现了IComparable和IComparable<T>。
8.选择"生成"|"生成解决方案",验证解决方案能正常编译,纠正任何错误。
9.选择"调试"|"开始执行(不调试)"。
程序将运行并显示以下值序列:
12-8 0 5 5 8 8 10 10 11 14 15
10.按 Enter 键返回Visual Studio 2017
11.在Main方法的尾部添加以下加粗的语句(在现有代码之后):
static void 地ain(string[] args)
{
	...
	Tree(string tree2 = new Tree(string("hello");
	tree2.Insert("world");
	tree2.Insert("how");
	tree2.Insert("Are");
	tree2.Insert("You");
	tree2.Insert("Today");
	tree2.Insert("I");
	tree2.Insert("hope");
	tree2.Insert("You");
	tree2.Insert("Are");
	tree2.Insert("Feeling");
	tree2.Insert("hel1");
	tree2.Insert("!");

	sortedData tree2.alkTree();
	Console.MriteLine($"Sorted data is:(sortedData)");
}
这些语句创建另一个二叉树来容纳字符串,在其中填充一些测试数据,然后打印树的内容。这一次,数据将按字母顺序排序。
12.选择"生成"|"生成解决方案"。验证解决方案能正常编译,纠正任何错误。
13.选择"调试"|"开始执行(不调试)"。
程序将运行,显示刚才展示过的整数值,然后显示以下字符串序列。
14.按 Enter键返回Visual Studio 2017。

创建泛型方法
除了定义泛型类,还可创建泛型方法。泛型方法允许采取和定义泛型类相似的方式,用类型参数指定参数和返回类型。这样可以定义类型安全的常规方法,同时避免强制类型转换(以及某些情况下的装箱)所造成的开销。泛型方法常与泛型类组合使用——例如,方法获取泛型类型的参数,或者返回泛型类型。
定义泛型方法需使用和创建泛型类时相同的"类型参数"语法(同样能指定约束)。例如,以下泛型方法Swap<T>可交换它的参数中的值。由于需要忽略所交换数据的类型,所以适合定义成泛型方法:
static void Shap<T>( ref T frst, ref T second)
{
	T temp-first; 
	first = second;
	second a temp;
}
调用方法时必须为类型参数指定具体类型。下例展示了如何使用Swap<T>方法来交换两个int和两个string:
int a 1,b=2;
SWap<int>(ref a, ref b);
...
string s1"Hello",s2= "world";
Swap<string>(ref s1,ref s2);
注意 我们 我们知道,对指定了不同类型参数的泛型类进行实例化,会造成编译器生咸不同类型。类似地,每次为SMwap<T>方法中的T传递不同的类型参数,都会造成编译器生成方法的不同版本,Swap<int>和Swap<string>是不同的方法;它们恰好从同一个泛型方法"模板"生成,所以具有相同行为,但这些行为作用于不同类型。

定义泛型方法来构造二叉树
上个练习展示了如何创建泛型类来实现二叉树。Tree<TItem>类提供了Insert方法在树中添加数据项。然而,如果想添加大量数据项,反复调用Insert方法显得很繁琐。以下练习要定义名为InsertIntoTree的泛型方法。使用这个方法,只需一次方法调用,即可将一个数据项列表插入树中。为了测试方法,我们准备将一个字符列表插入一个字符树中。
编写InsertIntoTree方法
1.在 Visual Studio 2017中,使用"控制台应用(NETFramework)"模板新建项目。在"新建项目"对话框中将项目命名为BuildTree.将"位置"设为"文档"文件夹下的MicrosoftPrss\VCSBS\Chapter17子文件夹。从"解决方案"下拉列表选择"创建新解决方案"。单击"确定"按钮。
2.选择"项目"|"添加引用"。在"引用管理器"对话框中单击"浏览"按钮(不是左侧窗格的"浏览"标签),
3.在"选择要引用的文件"对话框中,切换到"文档"文件夹下的Microsoft\PressVCSBS\Chapter 17\BinaryTreebin\Debug 子文件夹,单击BinaryTreedl再
单击"添加"按钮。
4.在"引用管理器"对话框中,验证BinaryTreedll 程序集已列出,单击"确定"。随后,BinaryTree程序集将添加到解决方案资源管理器显示的引用列表中。
5.在"代码和文本编辑器"中,在Program.cs 文件顶部添加以下 using指令:usingBinaryTree;该命名空间包含 Tree<TItem>类。
16. 在Program类中添加名为InsertIntoTree的方法(可放到Main方法后面)。这应该是一个static void 方法,获取两个参数。一个是名为 tree的Tree<TItem>参数。另一个是名为 data的、由TItem 元素构成的参数数组。tree 参数应该传引用,原因稍后再解释。方法定义如下所示:
static vold InsertInto ree<TItemo(ref TreeItem tree，rams TItem[] data）
{
}
7.插入二叉树的元素的类型(TItem类型)必须实现IComparable<TItem>接口。修改InsertIntoTree方法定义,添加恰当的 where子句来定义约束。如加粗部分所示:
static void InsertIntoTree<TItem)(ref Tree<Ttem> tree,
params TItem[] data)where TItem:IComparable<TItemp>
{
}
8.将以下加粗的语句添加到InsertIntoTree 方法。它们遍历 params 列表,使用Insert方法将每个数据项添加到树中。如果 tree 参数指定的值最初是null,就创建一个新的Tree<TItem>;这正是tree参数要传引用的原因。
static void InsertIntoTree(TItem>(ref Tree<TItem) tree,
	params TItem[] data) where TItem:IComparable<TItem)
	{
		foreach(TItem datunm in data)
		{
			if(tree m null)
			{	
				tree = new Tree<Ttem>(datum);
			else
			{
			tree.Insert(datum);
			}
		}
	}
测试InsertIntoTree方法
1.在 Program类的Main方法中添加以下加粗的语句,新建一个Tree来容纳字符数据。然后使用InsertIntoTree 方法在其中填充样本数据。最后显示Tree 的WalkTree方法所返回的树的内容:
static vwold Main(string[] args)
{
	Tree<char> charTree = null; 
	InsertintoTree<char>(ref charTree,'N','X','A','','Z','Z','N'); 
	string sortedData = charTree.kalkTree(); 
	Console.writeLine($"sorted data is:(sortedDatal)");
}
2.选择"生成"|"生成解决方案"。纠正任何错误;如有必要,请重新生成。
3.选择"调试"|"开始执行(不调试)"。程序开始运行并显示排好序的字符值:
A M M M X Z Z
4.按 Enter键返回Visual Studio 2017。

可变性和泛型接口
前面讲到可用 object类型容纳其他任何类型的值或引用。例如,以下代码正常编译:
string mystring="Hello";
object myobject = myString;
用继承的话来说,String类派生自Object 类,因此所有字符串都是对象。再来看看以下泛型接口和类:
interface IMrapper<T>
{
	void SetData(T data);
	T GetData();
}
class Mrapper<T>:IMrapper<T>
{
	private T storedData;
	void IWrapper<T>.SetData(T data)
	{
		this.storedData data;
	}
	T Iwrapper<T>.GetData()
	{
		return this.storedData;
	}
}
Wrapper<T>类围绕指定的类型提供了一个简单的包装器(wrapper)。IMrapper接口定义了SetData和GetData方法,Mrapper<T类实现这些方法来存储和获取数据。可以像下面这样创建该类的实例并用它包装一个字符串:
Wrapper<string>stringwrapper = new wrapper<string();
IWrapper<string> storedStringhrapper = stringlrapper;
storedStringirapper.SetData("Hello");
Console.whriteline($"存储的值是(storedstringlrapper.CetData()");
代码创建 Mrapper<string>类型的实例,通过 IMrapper<string>接口引用该对象并调用 SetData 方法。(Mrapper<T>类型显式实现它的接口,所以必须通过正确的接口引用来调用方法。）代码还通过IMrapper<string>接口调用GetData方法。运行上述代码,
应输出消息"存储的值是Hello"。
再来看看下面这行代码:
IWrappercobject>stored0bjectirapper = stringrapper;
该语句和前面创建IMrapper<string>引用的语句相似,区别在于,类型参数是 object而非string.该语句合法吗?记住,所有字符串都是对象(可将string值赋给一个object引用),所以该语句理论上可行。但如果尝试执行,会出现编译错误并显示消息:无法将类型I"wrapper<strIng)"隐式转换为"IMrapper<object>",存在一个显式转换(是否缺少强制转换?)可以尝试显式转换:
IWhrapper《object>storedObjecthrapper (Iarapoper<object>)stringrapper;
上述代码能够编译,但在运行时会抛出InvalidCastException异常。问题在于,虽然所有字符串都是对象,但反之不成立。如上述语句合法,就可像下面这样写代码,造成将Circle对象存储到string字段中都是合法的,这显然有悖于常理:
IWrappercobject>storedObjecthrapper = (Ihrappersobject>)stringhurapper; 
Circle myCircle= new Circle();
storedObjecthrapper.Setbata(mycircle);
IWrapper<T>接口称为不变量(invariant)。不能将IMrapper<A>对象赋给 IArapper<B>
类型的引用,即使类型A派生自类型B。C#默认强制贯彻了这一限制,确保代码的类型安全性。

协变接口
假定像下面这样定义 IStorewrapper<T>和 IRetrievewrapper<T>接口以替代
IMrapper<T>,并在Mrapper<T>类中实现这些接口：
interface IStorewrapper<T>
{
	void SetData(T data);
}
interface IRetrieverapper<T>
{
	 T GetData();
}
class Wrapper<T>:IStorewrapper<T>,IRetrieveirapper<T>
{
	private T storedData;

	void IStoresirapper<T>.SetData(T data)
	{
		this.storedData = data;
	}
	T IRetrlevewrapper<T>.GetData()
	{
		return this.storedData;
	}
}
Wrapper<T>类功能上和以前完全一样,只是要通过不同接口访问 SetData和GetData
方法:
Wrapper<string>stringWrapper= new Wrapper<string>();
IStoreWrapperstring storedStringWrapper = stringWrapper;
storedstringWrapper.SetData("Hello");
IRetrievekWrapper<string> retrlevedStringWrapper = stringWrapper;
Console.WriteLine($"存储的值是(retrlevedstringrapper.GetData()");
现在,以下代码合法吗?
IRetrlevekWrapper<object> retrievedObjectWrapper = stringWrapper;
简单回答是"不合法,会和前面一样编译失败,显示同样的错误消息。"但仔细想一想,就会发现虽然C#编译器认定该语句不是类型安全的,但这个认定有一点儿武断,因为这个认定的前提条件已经不存在了。IRetrieveNrapper<T>接口只允许使用GetData方法读取 IMrapper<T>对象中存储的数据,没有提供任何途径更改数据。对于泛型接口定义的方法,如果类型参数(T仅在方法返回值中出现,就可明确告诉编译器一些隐式转换是合法的,没必要再强制严格的类型安全性。为此,要在声明类型参数时指定 out关键字:
interface IRetrleveWrapper<out T>
{
	T GetData();
}
这个功能称为协变性(Covariance)。只要存在从类型A到类型B的有效转换,或者类型A 派生自类型B,就可以将IRetrieveWrapper<A>对象赋给 IRetrieveWrapper<B>引用。

以下代码现在能成功编译并运行:
//string派生自object,所以现在是合法的
IRetrieveshrapper<object>retrievedObjectirapper = stringlirapper;
只有作为方法返回类型指定的类型参数才能使用out限定符。如类型参数作为方法的参数类型,添加out限定符则为非法,代码不会通过编译。另外,协变性只适合引用类型,因为值类型不能建立维承层次结构。以下代码无法编译,因为int是值类型:
Wraper<int>intirapper-new wrapper<int>();
IStoreWrapper<int> toredIntWrapper = intWrapper;//这是合法的
...
//以下语句非法-int是值类型
IRetrievehiWrapper<object>retrievedObjectWrapper = intWrapper;
.NET Framework 定义的几个接口支持协变性。
注意 只有接口和委托类型(第18章讲述)才能声明为协变量.不能为泛型类使用out们饰符

逆变接口
有协变性自然还有逆变性(Contravariance)。它允许使用泛型接口,通过 A 类型(比如String类型)的一个引用来引用B类型(比如Object类型)的一个对象,只要A从B派生(或者说B的派生程度比A小)。听起来有点复杂,所以让我们用.NETFramework类库的一个例子来解释。
.NET Framework的System.Collections.Generic命名空间提供了名为IComparer的接口,如下所示:
public interface IComparer<in T>
{
	int Compare(T x,T y);
} 
实现该接口的类必须定义Compare方法,它比较由T类型参数指定的那种类型的两个对象。Compare方法返回一个整数值:如果×和y有相同的值,就返回o;如果x小于y,就返回负值;如果×大于y,就返回正值。以下代码展示了如何根据对象的哈希码对它们进行排序。(GetHashCode方法已由0bject类实现。它只是返回一个代表对象的整数。所有引用类型都继承了该方法并可用自己的实现重写。)
class Cbjectcomparer:IComparer<Cbject>
{
	int IComparer<Object>.Compare(0bject x,bject y)
	{
		int wash = x.GethashCode();
		int yHash = y.GethashCode();
		if(xHash == yHash) return 6;
		if(Xhash< yHash) return -1;
		return 1;
	}
}
可创建一个ObjectComparer对象,并通过 IComparer<Object>接口调用Compare 方法来比较两个对象,如下所示:
0bject x...;
0bject y=...;
ObjectComparer objectComparer = new ObjectComparer();
ICcomparer<Object>objectComparator= objectComparer;
int result = objectComparator.Compare(x,y);
目前,似乎一切再普通不过。但有趣的是,可通过对字符串进行比较的IComparer接口来引用同一个对象,如下所示:
IComparer<String>stringComparator = objectComparer;
表面上看,该语句似乎违反了类型安全性的一切规则。但如果仔细考虑IComparer<T>接口所做的事情,就明白上述语句是没有问题的。Compare方法的作用是对传入的实参进行比较,根据结果返回一个值。能比较Object,自然就能比较 String。String不过是Object 的一种特化的类型而已。毕竟,一个String应该能做Object 能做的任何事情——那正是继承的意义!
当然,这样说仍有一点牵强。编译器怎么知道你不会在Compare方法的代码中执行依赖于特定类型的操作,造成用基于不同类型的接口调用方法时失败?所以,必须让编译器安心!检查IComparer接口的定义,会看到在类型参数前添加了in限定符:
public interface IComparerin T>
{
	int Compare(T x,T y);
}
in关键字明确告诉 C#编译器:程序员要么传递T作为方法的参数类型,要么传递T的派生类型。程序员不能将T用作任何方法的返回类型。这样就限定了通过泛型接口引用对象时,接口要么基于T,要么基于T的派生类型。简单地说,如果类型A公开了一些操
作、属性或字段,那么从A派生出类型B时,B也肯定会公开同样的操作(允许重写这些操作来提供不同的行为)、属性和字段。因此,可以安全地用类型B的对象替换类型A的对象。
协变性和逆变性在泛型世界中似乎是一个边缘化的主题,但它们实际是有用的。例如,List<T>泛型集合类(在 System.Collections.Generic命名空间中)使用IComparer<T>对象实现 Sort和BinarySearch 方法。一个List<Object>对象可包含任何类型的对象的集合,所以Sort和BinarySearch方法要求能对任何类型的对象进行排序。如果不使用逆变,Sort方法和BinarySearch方法就必须添加逻辑来判断要排序或搜索的数据项的真实类型,然后实现类型特有的排序或搜索机制。
当然,协变性和逆变性这两个词确实有些拗口,所以刚开始可能搞不清楚两者的作用。
根据本节的例子,我是像下面这样记忆它们的。
协变性(Covariance) 如果泛型接口中的方法能返回字符串,它们也能返回对象(所有字符串都是对象。）
逆变性(Contravariance)如果泛型接口中的方法能获取对象参数,它们也能获取字符串参数。(对象能执行的操作字符串也能,因为所有字符串都是对象。
注意 和协变一样,只有接口和委托类型能声明为逆变量。泛型类不能使用in修饰符。

使用集合
解释NETFramework不同集合类的功能
创建类型安全的集合
用一组数据填充集合
操纵和访问集合中的数据项
使用谓词在面向列表的集合中查找匹配项

前面讲了如何用数组容纳数据。数组很有用,但限制也不少。数组只提供了有限的功能,例如不方便增大或减小数组大小,还不方便对数组中的数据进行排序。另一个问题是必须用整数索引来访问数组元素。如果应用程序需要使用其他机制存储和获取数据,数组就不是最合适的数据结构了。这正是集合可以大显身手的地方。

什么是集合类
Mirosoft.NET Framework提供了几个类,它们集合元素,并允许应用程序以特殊方式访问这些元素。它们在System.Collections.Generic命名空间中。
从名字可以看出,这些集合都是泛型类型,都要求提供类型参数来指定存储什么类型的数据。每个集合类都针对特定形式的数据存储和访问进行了优化,每个都提供了专门的 方法来支持集合的特殊功能。例如,Stack<T>类实现了后入先出模型,Push方法将数据项 添加到栈顶,Pop 方法则从栈顶取出数据项。Pop 总是获取并删除最新入栈的项。相反, Queue<T类型提供了Enqueue和 Dequeue 方法。Enqueue使一个项入队, Dequeue按相同顺序获取并删除项,从而实现了先入先出的数据结构。还有其他许多集合类,下表总结了最常用的。
集合                                      说明
List<T> 					 可像数组一样按索引访问列表,但提供了其他方法来搜索和排序
Queue<T> 					 先入先出数据结构,提供了方法将数据项添加到队列的一端,从另一
							 端删除项,以及只检查而不删除
Stack<T> 					 先入后出数据结构,提供了方法将数据项压入栈顶,从栈顶出栈,以
							 及只检查栈项的项而不到除
LinkedList<T> 				 双向有序列表,为任何一端的插入和删除进行了优化。这种集合既可
							 作为队列,也可作为栈,还支持列表那样的随机访问
HashSet<T) 					 无序值列表,为快速数据获取而优化。提供了面向集合的方法来判断
							 它容纳的项是不是另一个 HashSet<T>对象中的项的子集,以及计算
							 不同HashSet<T对象的交集和并集
Dictionary<TKey,TValue> 	 字典集合允许根据键而不是索引来获取值
SortedList<TKey, TValue> a） 键/值对的有序列表。健必须实现IComparable<T）接口每个类的更多细节请参见MSDN 文档。

注意 .NET Framework还在System.Collections命名空间中提供了另一套集合类它们是非泛型集合,是在C#支持泛型类型之前设计的.(泛型是在为.NETFramework2.0开发的C#版本中加入的。)除了一个例外,这些类型全都存储对象
引用,必须在存储和获取数据项时执行恰当的类型转换。这些类的作用是和现有的应用程序向后兼客,新解决方案不推荐使用,事实上,如果开发的是通用Windows平台(UWP)应用,这些类甚至不可用.
例外的是BitArray类,它不存储对象引用。该类使用一个int实现精简的Boolean数组。int的每一位都代表true(1)或false(0),它类似于IntBits结构.BitArray类是可以在UWP应用中使用的。
System.Generic.Concurrent命名空间定义了另一组重要的集合.它们是线程安全的集合类,可在开发多线程应用程序时利用。
List<T>集合类
泛型List<T>类是最简单的集合类。用法和数组差不多,可用标准数组语法(方括号和元素索引)引用集合中的元素(但不能用这种语法在集合初始化之后添加新元素)。List<T>类比数组灵活,避免了数组的以下限制。
为了改变数组大小,必须创建新数组,复制数组元素（如果新数组较小,甚至还复制不完),然后更新对原始数组的引用,使其引用新数组。
删除一个数组元素,之后所有元素都必须上移一位。即使这样还是不好使,因为最后一个元素会产生两个拷贝。
插入一个数组元素,必须使元素下移一位来腾出空位。但最后一个元素就丢失了!
List<T>集合类通过以下功能来避免这些限制创建List<T>集合时无需指定容量,它能随元素的增加而自动伸缩。这种动态行为当然是有开销的,如有必要可指定初始大小。超过该大小,List<T>集合自动增大:
可以用Remove方法从List<T>集合删除指定元素。List<T>集合自动重新排序并关闭裂口。还可用RemoveAt方法删除 List<T>集合指定位置的项。
可以用Add方法在List<T>集合尾部添加元素。只需提供要添加的元素,List<T>集合的大小会自动改变。
可用Insert方法在List<T>集合中间插入元素。同样地,List<T>集合的大小会自动改变。
可调用Sort方法轻松对List<T>对象中的数据排序。
注意 和数组一样,用foreach遍历List<T集合时,不能用循环变量修改集合内容.另外,在遍历List<T>的 foreach循环中不能调用 Remove,Add或 Insert方法,否则会抛出InvalidOperationException。
下例展示了如何创建、处理和遍历一个List<int>集合的内容。
using System;
using System.Collections.Generic;
...
List<int>numbers= new List<int>();
//使用Add方法填充List<int>
foreach(int number in new int[12]{18,9,8,7,7,6,5,16,4,3,2,1})
{
	numbers,Add(number);
}
/在列表倒数第二个位置插入一个元素
//第一个参数是位置,第二个参数是要插入的值
numbers.Insert(numbers.Count-1, 99);
//删除值是7的第一个元素(第4个元素,索引3)
number.Remove(7);
//删除当前第7个元素,索引6(10)
numbers.RemoveAt(6);
//用for 语句遍历剩余11个元素
Console.writeline("Iterating using a for statement:");
for(int i =6;i<numbers.Count;i++)
{
	int number a numbers[1];//注意。这里使用了数维语法
	Console.WriteLine(number);
}
//用foreach 语句遍历同样的11个元素
Console.writeLine("\nIterating using a foreach statement:");
foreach(int number in numbers)
{
	Console.iriteLine(number);
}
代码的输出如下所示:
Iterating using a for statement:
(...省略)
Iterating using a foreach statement:
(...省略)
注意 List<T>集合和数组用不同的方式判断元素数量,列表是用 Count属性,数组是用Length属性.

LinkedList<T>集合类
LinkList<T>集合类实现了双向链表。列表中每一项除了容纳数据项的值,还容纳对下一项的引用(Next 属性)以及对上一项的引用(Previous属性)。列表起始项的 Previous属性设为nul1,最后一项的Next属性设为null。和List<T>类不同,LinkedList<T>不支持用数组语法插入和检查元素。相反,要用AddFirst方法在列表开头插入元素,下移原来的第一项并将它的Previous属性设为对新项的引用。或者用AddLast方法在列表尾插入元素,将原来最后一项的Next属性设为对新项的引用。还可使用AddBefore和AddAfter方法在指定项前后插入元素(要先获取项)。First属性返回对 LinkedList<T>集合第一项的引用,Last属性返回对最后一项的引用。遍历链表可从任何一端开始,查询 Next 或Previous 引用,直到返回 nul1为止。还可使用foreach 语句正向遍历LinkedList<T>对象,抵达末尾会自动停止。从LinkedList<T>集合中删除项是使用Remove,RemoveFirst和RemoveLast方法。
下例展示了一个LinkedList<T集合。注意如何用 for语句遍历列表,它查询Next(或Previous)属性,直到属性返回 null引用(表明已抵达列表末尾)。
using System;
using System.Collections.Generic;
...
LinkedList<int>numbers = new LinkedList<int>();

//使用AddFirst方法填充列表
foreach(int number in new int[]{18,8,6,4,2 })
{
	numbers.AddFirst(number);
}
//用for语句遍历
Console.writeLine("Iterating using a for statement:");
for(LinkedListNode<int>node = numbers.First;node l= null; node = node.Next)
{
	int number= node.Valut
	Console.hriteLine(number);
}
//用foreach 语句遍历
Console.iriteLine("\nLterating using a foreach statement:");
foreach(int number in number
{
	Console.MriteLine(number);
}
代码的输出如下所示:
Iterating using a for statement:(...省略)
Iterating using a foreach statement:(...省略)
Iterating list in reverse order:(...省略)

 Queue<T>集合类
Queue<T>类实现了先入先出队列。元素在队尾插入(入队或Enqueue),从队头移除(出
队或Dequeue).
下例展示了一个Queue<int>集合及其常见操作
using System;
using System.Collections.Generic; 
...
Queue<int> numbersa new Queue<int>();
//填充队列
Console.MriteLine("Populating the queue:");
foreach(int number in new int[4](9,3,7,2)
{
	numbers.Enqueue(number);
	Console. iriteLine($"(number} has joined the queue");
}
//遍历队列
Console.writeLine("\nThe queue contains the following items:");
foreach（int number in numbers)
{
	Console.Mriteline(number);
}
//清空队列
Console.writeLine("\nDraining the queue: ");
while(numbers.Count>0)
{
	int number = numibers.Dequeue();
	Console. writeLine(${number} has left the queue");
}
上述代码的输出如下:
Populating the queue:
9 has joined the queue
3 has joined the queue
7 has joined the queue
2 has joined the queue
The queue contains the following items:
9
3
7
2
Draining the queue:
9 has left the queue
3 has left the queue 
7 has left the queue 
2 has left the queue
Stack<T>集合类
Stack<T>类实现了类实现了后入先出的栈。元素在顶部入栈(push),从顶部出栈(pop)。通常可以将栈想象成一叠盘子:新盘子叠加到顶部,同样从顶部取走盘子。换言之,最后一个入栈的总是第一个被取走的。下面是一个例子(注意 foreach循环列出项的顺序):
using System; 
using System.Collections. ceneric;
...
Stack<int>numbers= new Stack<int>();
//填充栈
Console.iriteLine("Pushing items onto the stack:");
foreach(int number in new int[4]{9,3,7,2})
{
	numbers.Push(number);
	Console.iriteLine($"{number} has been pushed on the stack");
}
//遍历栈
Console.iriteLine("nThe stack now contains:");
foreach(int number in numbers)
{
	console.HriteLine(number);
}
//清空栈
Console.iriteLine("\nPopping items from the stack:");
while(numbers.Count >0)
{
	int number numbers.Pop();
}
Console. MriteLine($"{number} has been popped off the stack");
}

Dictionary<TKey,TValue>集合类
数组和 List<T>类型提供了将整数索引映射到元素的方式。在方括号中指定整数索引来获取索引4的元素(实际是第5个元素)。但有时需要从非int类型(比如string,double或TIme)映射。其他语言一般把这称为关联数组。C#的Dictionary<TKey,TValue>类在内部维护两个数组来实现该功能。一个存储要从其映射的键,另一个存储映射到的值。分别称为键数组和值数组。在Dictionary<TKey,TValue>集合中插入键/值对时,将自动记录哪个键和哪个值关联,允许开发人员快速、简单地获取具有指定键的值。Dictionary<TKey,TValue>类的设计产生了一些重要后果。Dictionary<TKey,TValue>集合不能包含重复的键。调用 Add 方法添加键数组中已有的键将抛出异常。但是,如果使用方括号记号法来添加键/值对(参见后面的例子),就不用担心异常——即使之前已添加了相同的键。如果键已经存在,其值就会被新值覆盖。可用 Containkey方法测试Dictionary<TKey,TValue>集合是否已包含特定的键。Dictionary<TKey,TValue>集合内部采用一种稀疏数据结构,在有大量内存可用时才最高效。随着更多元素的插入,Dictionary<TKey,TValue>集合可能快速消耗大量内存。
使用foreach 语句遍历 Dictionary<TKey,TValue>集合返回的是一个
KeyaluePair<TKey,TValue>。这是一个结构,包含的是数据项的键和值元素的拷贝,可通过Key和Value属性访问每个元素。元素是只读的,不能用它们修改Dictionary<TKey,TValue>集合中的数据。
下例将家庭成员年龄和姓名关联并打印信息。
using System;
using System.Collections.Generic;
...
Dictionary<string,int>ages= new Dictionary<string,int>();

//填充字典
ages.Add("John",53);//使用Add方法
ages.Add("Diana",53);
ages["James"] 26;/使用数组语法
ages["Francesca"]= 23;

//用foreach 语句遍历字典
//迭代器生成的是一个KeyaluePair项
Console.writeLine("The Dictionary contains:");
foreach(KeyaluePaircstring,int> element in ages)
{
	string name = element.Key; 
	int age = element.Value;
	Console.MriteLine($"Name:{name),Age:(age)");
}
程序输出如下所示:
The Dictionary contains:
Name:John,Age;53 Name:Diana,Age:53
Name:James,Age:26 Name:Francesca,Age:23
注意 System.Collections.Generic 命名空间还包含 SortedDictionary<TKey
TValue>集合类型。该类能保持集合有序(根据键进行排序)。

SortedList<TKey,TValue>集合类
SortedList<TKey,TValue>类与Dictionary<TKey,TValue>类很相似,都允许将键和值关联。主要区别是,前者的键数组总是排好序的(不然也不会叫 SortedList了)。在SortedList<TKey,TValue>对象中插入数据花的时间比 SortedDictionary<TKey,TValue>对象长,但获取数据会快一些(至少一样快),而且 SortedList<TKey,TValue>类消耗内存较少。
在SortedList<TKey,TValue>集合中插入一个键/值对时,键会插入键数组的正确索引位置,目的是确保键数组始终处于排好序的状态。然后,值会插入值数组的相同索引位置。SortedList<TKey,TValue类自动保证键和值同步,即使是在添加和删除了元素之后。这意味着可按任意顺序将键/值对插入一个 SortedList<TKey,TValue>,它们总是按照键的值来排序。
Dictionary<TKey,TValue>类相似,SortedList<TKey,TValue>集合不能包含重复键。用 foreach 语句遍历 SortedList<TKey,TValue>集合返回的是 KeyaluePair<TKey,TValue>项,只是这些KeyaluePair<TKey,TValue>对象已按 Key属性排好序。
下例仍然将家庭成员的年龄和姓名关联并打印结果。但这次使用有序列表而不是字典。
using System
using System.Collections.Generic
...
SortedList<string,int>ages· new SortedList<string,int>();
//填充有序列表
ages.Add("John",53);//使用Add方法
ages.Ad("Diana",53);
["James"]·27;//使用
ages["Francesca"]=23;
/用foreach语句遍历有序列表
//选代器生成的是一个KeyaluePair项
Console.wiriteLine("The SortedList contains:");
foreach(KeyaluePair<string,int> element in ages)
{
	string name = element.Key;
	int age = element.Value;
	Console.writeline($"Name:(name》,Age:{age]")
}
结果按家庭成员姓名(键)的字母顺序进行排序(D-F-J-J):
The SortedList contains:
Name:Diana,Age:53
Name:Francesca,Age:23
Name:James,Age:26
Name:John,Age:53

HashSet<T>集合类
HashSet<T>类专为集合"操作优化,包括判断数据项是否集合成员和生成并集/交集等。数据项用Add方法插入 HashSet<T>集合,用 Remove方法删除。但HashSet<T>类真正强大的是它的IntersectWith,UnionMith和Exceptwith方法。这些方法修改 HashSet<T>集合来生成与另一个HashSet<T>相交、合并或者不包含其数据项的新集合。这些操作是破坏性的,因为会用新集合覆盖原始 HashSet<T>对象的内容。另外,还可以使用IsSSubsetOF,IsSupersetOf,IsProperSubsetOf和IsProperSupersetOf方法判断一个HashSet<T>集合的数据是否另一个HashSet<T>集合的超集或子集。这些方法返回Boolean值,是非破坏性的。
HashSet<T>集合内部作为哈希表实现,可实现数据项的快速查找。但一个大的HashSet<T>集合可能需要消耗大量内存。
下例展示如何填充 HashSet<T>集合并运用IntersectWith 方法找出两个集合都有的数据。
using System;
using System.Collections.Generic;
...
HashSetstrirg employees =new HashSet<strirg>(new strirg[]{"Fred","Bert",Harry","John"});
HashSetstrirng customers =new Hasiet<strirg(new string[]{"John","Sid","Harry","Diana"});

employees.Add("James");
customers.Add("Francesca");

Console.kiriteLine("Employees:");
foreach(string name in employees)
{
	Console.WriteLine(name);
}
Console.MriteLine("VnCustomers who are also employees:");//既是客户又是员工的人
customers.Intersectwith(employees);
foreach(string name in customers)
{
	Console.MriteLine(name);
}
代码的输出如下所示:
(省略)
注意 System.Collections.Generic命名空间还包含 SortedSet<T>集合类型,工作方式和 HashSet<T）相似.主要区别是数据保持有序.SortedSet<T和 HashSet<T>类可以互操作.例如,可以获取SortedSet<T>集合和HashSet<T>集合的并集。

使用集合初始化器
前面的例子展示了如何使用每种集合最合适的方法来添加元素。例如,List<T>使用Add,Queue<T>使用Enqueue,而Stack<T>使用Push。一些集合类型还允许在声明时使用和数组相似的语法来初始化。例如,以下语句创建并初始化名为numbers的List<int>对象,这样写就不需要反复调用Add方法了:
List<intb numbers=new List<int>(){10,9,8,7,7,6,5,186,4,3,2,1};
c#编译器内部会将初始化转换成一系列Add方法调用。换言之,只有支持Add方法的集合才能这样写(Stack<T>和Queue<T>就不行)。对于获取键/值对的复杂集合(例如 Dictionary<TKey,TValue>),可用索引器语法为每个键指定值,例如:
Dictionarystring,int>ages new Dictionarystring,int>()
{
	["John"]= 51,
	["Diana"]= 56,
	["James"]=23,
	["Francesca"]= 21
};
如果愿意,还可在集合初始化列表中将每个键/值对指定为匿名类型,如下所示:
Dictionary<string,,int> ages =new Dictionary<string,int>()
{
	{"John",51),
	{"Diana",5e),
	{James",23},
	{"Francesca",21}
}；
每一对的第一项是键,第二项是值。为增强代码可读性,建议初始化字典类型时尽量使用索引器语法。

Find方法、谓词和 Lambda表达式
如前所述,面向字典的集合（Dictionary<TKey,TValue>,SortedDictionary<TKey,TValue>和 SortedList<TKey,TValue>)允许根据键来快速查找值,支持用数组语法访问值。对于 List<T>和 LinkedList<T>等支持无键随机访问的集合,它们无法通过数组语法来查找项,所以专门提供了Find方法。Find方法的实参是代表搜索条件的谓词。谓词就是一个方法,它检查集合的每一项,返回Boolean值指出该项是否匹配。Find方法返回的是发现的第一个匹配项。List<T>和LinkedList<T>类还支持其他方法,例如 FindLast 返回最后一个匹配项。List<T>类还专门有一个 FindAll 方法,返回所有匹配项的一个List<T>集合。

谓词最好用Lambda表达式指定。简单地说,Lambda表达式是能返回方法的表达式。这听起来很怪,因为迄今为止遇到的大多数C#表达式都是返回值。但如果熟悉函数式编程语言,比如Haskell,这个概念就一点儿都不陌生。其他人也不必害怕,Lamda 表达式并不复杂,熟悉后会发现它们相当有用。
注意 访问Haskll主页 http:/www.haskellorg/haskellwiki,深入了解如何用 Haskell进行函数式编程。
方法通常由4部分组成:返回类型、方法名、参数列表和方法主体。但Lambda表达式只包含其中两个元素,即参数列表和方法主体。Lambda表达式没有定义方法名,返回类型（如果有的话)则根据Lambda表达式的使用上下文推断。在 Find方法的情况下,谓词依次处理集合中的每一项;谓词的主体必须检查项,根据是否匹配搜索条件返回true或false。以下加粗的语句在一个List<Person>上调用Find方法(Person是结构),返回ID属性为3的第一项。
struct Person
{
	public int ID {get;set;}
	public string Name{ get;set;}
	public int Age{get;set;}
}
...
//创建并填充personnel列表
List<Person> personnel a new List<Person>()
{
	 new Person(){ID = 1,Name·"John",Age 53 },
	new Person(){ ID 2,Name "S1d", Age= 28},
	new Person(){Da 3,Name -"Fred",Age= 34),
	new Person(){ID a 4,Name -"Paul",Age = 22},
};
//查找ID为3的第一个列表成员
Person match = personnel1.Find((Person p)=>{ return p.ID =s 3;));
Console.ariteLine($"ID:{match.ID\nName:{(match.NMame}nAge:{match.Age)");
上述代码的输出如下:
ID: 3 
Name:Fred
Age:34
调用 Find方法时,实参(Person p)=>{return p.ID== 3;}就是实际"干活儿"的Lambda表达式,它包含以下语法元素。圆括号中的参数列表。和普通方法一样,即使Lambda表达式代表的方法不获取任何参数,也要提供一对空白圆括号。对于Find方法,谓词要针对集合中的每一项运行,该项作为参数传给Lambda表达式。=>操作符,它向C#编译器指出这是一个Lambda表达式。
Lambda表达式主体(方法主体)。本例的主体很简单,只有一个语句,返回Boolean值来指出参数所指定的项是否符合搜索条件。然而,Lambda表达式完全可以包含多个语句,而且可以采用你觉得最易读的方式来排版。只是要记住,和普通方法一样,每个语句都要以分号结束。
重要提示  前面曾用=>操作符定义表达式主体方法。为同一个操作符赋予多种含)的确容易使人混淆,虽然概念上有些相似,但表达式主体方法和Lambda表达式无论语义还是功能都截然不同,两者不要弄混了。
严格地说,Lambda表达式的主体可以是包含多个语句的方法主体,也可以只是一个表达式。如果Lambda表达式主体只有一个表达式,大括号和分号就可以省略了(最后仍需一个分号来完成整个语句)。另外,如果表达式只有一个参数,用于封闭参数的圆括号也可省略。最后,许多时候都可以省略参数类型,让计算机根据Lambda表达式的调用上下文推断。下面是刚才的Find语句简化版本,它更容易阅读和理解:
Person match = personnel.Find(p => p.ID = 3);

Lambda 表达式的形式
Lambda表达式是很强大的构造。随着 C#编程的深入,它们会用得越来越多。表达式本身具有多种形式,每种形式的区别需用心体会。Lambda表达式最初是LambdaCalculus(或者称为λ 演算,入的发音就是Lambda)这种数学逻辑系统的一部分,它提供了对函数进行描述的一种记号法(可将函数想象成会返回值的方法)。虽然C#语言所实现的Lambda表达式对入演算的语法和语义进行了扩展,但许多基本概念仍然保留下来了。下面这些例子展
示了C#Lambda表达式的各种形式:
x => x * × //一个简单表达式,返回参数值的平方
			//参数×的类型根据上下文推导
× => {return  x * × ;}	//语义和上一个表达式相同,
						//但将一个C新语句块用作主体,而非只是一个简单表达式
(int x) => x/2			//一个简单表达式,返回参数值除以2的结果
						//参数x的类型显式指定
() => folder.StopFolding(0)		//调用一个方法。
								//表达式不获取参数。
								//表达式可能会、也可能不会返回值
(x, y)=> { x++; return x / y;}	//多个参数;编译器自己相断参数类型
								//参数x以值的形式传递,
								//所以++操作的效果是局部于表达式的
(ref int x,int y){ x++; return x / y;}		//多个参数,都显式指定类型
											//参数x 以引用的形式传递,
											//所以++操作的效果是永久性的
下面总结了Lambda表达式的一些特点。
如Lambda表达式要获取参数,就在=>操作符左侧的圆括号内指定。可省略参数 类型,C#编译器能根据Lambda表达式的上下文进行推断。如希望Lambda表达式 永久(而不是局部)更改参数值,可用"传引用"方式传递参数(使用ref关键字),
但不推荐这样做。
Lambda表达式可返回值,但返回类型必须与对应的委托的类型匹配。
Lambda表达式主体可以是简单表达式,也可以是C#代码块(代码块可包含多个语 句、方法调用、变量定义等等)。
Lambda表达式方法中定义的变量会在方法结束时离开作用域(失效)。
Lambda 表达式可访问和修改Lambda 表达式外部的所有变量,只要那些变量在 Lambda表达式定义时,和Lambda表达式处在相同作用域中。一定要非常留意这个特点!
Lambda表达式和匿名方法
Lambda表达式是C#3.0新增的功能.C#2.0引入的是匿名方法.匿名方法执行相似的任务,但却不如Lambda表达式灵活。之所以设计量名方法,主要是为了方便开发者在定义委托时不必创建具名方法.只需在方法名的位置提供方法主体的定义就可以了,如下所示:
this.stoprachinery += delegate{folder.StopFolding(0);};
还可将匿名方法作为参数传递以取代委托,如下所示
control.Add(delegate { folder.StopFolding(0);});
注意，引入匿名方法时必须附加 delegate前缓。另外,所需的任何参数都在delegate关键字后的圆括号中指定,例如:
control.Add(delegate(int paramt,string param2)
{/*使用 param和param2的代放在这里 */...});
习惯之后,会发现Lambda表达式提供的语法比匿名方法更简洁和自然,另外,C#许多比较高级的领域会大量使用Lambda表达式.总的来说,应该尽可能在代码中使用Lambda表达式而不是匿名方法.

比较数组和集合
数组和集合的重要差异总结如下:
数组实例具有固定大小,不能增大或缩小。集合则可根据需要动态改变大小。数组可以多维,集合则是线性。但集合中的项可以是集合自身,所以可用集合的集合来模拟多维数组。
数组中的项通过索引来存储和获取。并非所有集合都支持这种语法。例如,要用Add或Insert方法在List<T>集合中存储项,用Find方法获取项。
许多集合类都提供了ToArray方法,能创建数组并用集合中的项来填充。复制到数组的项不从集合中删除。另外,这些集合还提供了直接从数组填充集合的构造器。
使用集合类来玩牌
用集合实现扑克牌游戏
1.如Microsoft Visual Studio 2017 尚未启动,请启动。
2.打开Cards解决方案,它位于"文档"文件夹下的Microsoft Press\VCSBS\Chapter18\Cards子文件夹。
该项目更新了前面使用数组实现的版本。修改了PlayingCard类,牌的点数和花色作为只读属性公开
3.在"代码和文本编辑器"窗口中显示Packcs。在文件顶部添加以下 using指令:
using System.collections.Generic;
4. 将Pack类中的二维数组 cardPack改成Dictionary<Suit,List< PlayingCard>>
对象,如加粗的代码所示:
class Pack
{
	...
	private DictionarySuit,List<PlayingCard> cardPack;
	...
}
原始应用程序使用二维数组表示一副牌。这里改用字典,键是花色,值是那个花 色的所有牌的列表。
5.找到Pack构造器。修改构造器的第一个语句,将cardPack变量实例化成新的字典集合而不是数组,如加粗的代码所示:
public Pack()
{
	this.cardPack = new Dictionary<Sudt,List<PlayingCard>>(NumSuts);
	...
}
虽然字典集合能随着数据项的加入而自动改变大小,但如果大小一般不怎么变化，可在实例化时指定初始大小。这有助于优化内存分配(虽然超过这个大小时字典还是会自动增大)。本例的字典集合固定包含4个列表(每种花色一个),所以分配初始大小4(NumSuits 是值为4的常量)。
6.在外层for循环中声明名为cardsInSut的List<PlayingCard>集合对象。它要足够大来容纳每种花色的牌数(使用CardsPerSuit常量),如加粗的语句所示:
public Pack()
{
	this.cardpack- new DictionarySutt,List<PlayingCardb>(Numsuts);
	for (Suit suit = Suit.Clubs;suit <= a Suit.Spades;suit++)
	{
		ListPlayingCard> cardsInsut = new ListcPlayingCard(CardsPerSudt); 
		for(Value value = Value.Two;value( Value.Ace;value+)
		{
			...
		}
	}
}
7.修改内层for循环的代码,将新的PlayingCard对象添加到集合而不是数组中。 如加粗的语句所示:
for(Sut suit= Sut.Clubs;suit<m Sut. Spades;suit++)
{
	List<PlayingCard> cardsInsuit = new List<Playingard>(CardsPerSuit); 
	for (Value value = Value.Tho; value <=Value,Ace;value+t)
	{
		cardsInsuit.Add(new PlayingCard(sudt,value));
	}
}
8.在内层 for循环之后,将列表对象添加到字典集合cardPack中,将suit变量的值指定为字典每一项的键。如加粗的语句所示:
for (Suit suit= suit.Clubs;suit < Suit.Spades;suit++)
{
	List<PlayingCard> cardsInsuit = new ListPlayingCard>(CardsPerSuit);
	for (Value value = Value.Two;value<a Value.Ace;value+)
	{
		cardsInsuit.Add(new PlayingCard(sut,value));
	}
	this.cardpack.Add(sut, cardsInsut);
}
9.找到DealCardFromPack方法。该方法从一副牌中随机挑选一张牌,将牌从牌墩中删除,再返回这张牌。在本例中,挑选牌的逻辑不必进行任何更改,但方法末尾获取牌的语句必须更新以使用字典集合。另外,从数组中删除已发牌的代码也需要修改。现在要在列表中找到牌并将其删除。查找牌要使用Find方法并指定一个谓词来查找具有指定点数（value)的牌。谓词的参数应该是一个PlayingCard对象(列表包含的就是PlayingCard对象修改第二个while循环的结束大括号之后的代码,如加粗的代码所示:
public PlayingCard DealCardFromPack()
{
	Suit suit (Suit)randomCardSelector. Next(NumSuits);
	while(this.IsSuitEmpty(sut))
	{
		suit a(Suit)randomCardSelector.Next(NuiSuits);
	}
	Value value (Value)randomCardselector.Next(CardsPerSut);
	while(this.IsCardAlreadypealt(suit,value))
	{
		value (Value)randomCardSelector.Next(CardsPerSuit);
	}
	List<PlayingCard> cardsInsudt = this.cardPack[suit];
	PlayingCard card = cardsInSuit.Find(c => c. Cardvalue = value);
	cardsInSuit.Remove(card);
	return card;
}
10.找到ISCardAlreadyoealt方法。该方法判断一张牌之前是否已经发过。它采用的办法是检查数组中对应元素是否已被设为null。需修改该方法,判断在字典集合cardPack中,在与指定花色对应的列表中,是否已包含具有指定点数的牌。使用Exists 方法判断List<T）集合是否包含指定数据项。该方法和 Find相似,都是获取一个谓词作为实参。谓词(记住谓词是方法)获取集合中的每一项,如果该项符合指定条件就返回 true,否则返回 false。本例的List<T>集合容纳的是PlayingCard 对象。所以,如果一个 PlayingCard 的花色和点数与传给ISCardAlreadyoealt方法的实参匹配,Exists 谓词就应返回 true。
如以下加粗的代码所示更新方法:
private bool IsCardAlreadyDealt(Suit suit, Value value)
{
	ListPlayingCard> cardsInsuit a this.cardPack[sut]; 
	return（!cardsInsut.Bdsts(c => c.CardSut m= suit && c.Cardalue = value));
}
11.在"代码和文本编辑器"中显示Hand.cs 文件。在文件顶部添加以下using指令:
using System.Collections.Generic
12.Hand 类目前用cards数组容纳一手牌。修改 cards 变量的定义,把它改成一个List<PlayingCard>集合,如加粗代码所示:
class Hand
{
	public const int HandS1ze = 13;
	private List<PlayingCard>cards = new List<PlayingCard>(HandSize);
	...
}
13.找到AddCardToHand方法。该方法目前检查是否已抓满了一手牌。如果还没有,就将作为参数提供的牌(一个 PlayingCard 对象)添加到cards数组中由playingCardCount 变量指定的索引位置。
更新方法,改为使用List<PlayingCard>集合的Add方法。修改后就没必要用个变量显式跟踪集合中的牌数了,因为可以改为使用Count属性。从类中删除playingCardCount变量,修改检查是否已抓满一手牌的if语句来引用Count属性。完成后的方法如下所示,改动的地方加粗显示:
public vold AddCardTorand(Playingard cardDealt)
{
	if(this.cards.Count >= HandSize)
	{
		throw new ArgumentException("To many cards");
	}
	this.cards.add(cardDealt);
}
14.在"调试"菜单中选择"开始调试"来生成并运行应用程序。
15.Card Game 窗口出现后,请单击Deal按钮。
注意 展开底部的命令栏来显示 Deal按钮。验证以前一样,所有牌都会发出去,每手牌都正确显示。再次单击Deal,会重新随机发牌。
16.返回Visual Studio2017并停止调试。

枚举集合
手动定义枚举器来遍历集合中的元素
创建迭代器来自动实现枚举器
提供附加的选代器,按不同顺序遍历集合中的元素
枚举集合中的元素
前面的一个例子展示了如何用 foreach语句列出一个简单数组中的数据项:
int[] pins ={9,3,7,2);
foreach(int pin in pins)
{
	Console.kwriteLine(pin);
}
foreach 极大简化了需要编写的代码,但它只能在特定情况下使用——只能遍历可枚举集合。
什么是可枚举集合?简单地说,就是实现了System.Collections.IEnumerable接口的集合。
注意 C#的所有数组都是 System.Array类的实例,而 System.Array类是实现了IEnumerable接口的集合类．
IEnumerable接口包含一个名为GetEnumerator的方法:
IEnumerator GetEnumerator();
GetEumerator方法应返回实现了System.Collections.IEnumerator接口的枚举器对象。枚举器对象用于遍历(枚举)集合中的元素。IEnumerator接口指定了以下属性和方法:
object Current{get;}
bool Movelext();
void Reset();
可将枚举器视为指向列表中的元素的指针。指针最开始指向第一个元素之前的位置。 
调用MoveNext方法,即可使指针移至列表中的下一项(第一项);如果能实际地移到下一项,MoveNext方法返回true,否则返回 false。可用 Current属性访问当前指向的那一项;
使用Reset方法,则可使指针回到列表第一项之前的位置。使用集合的GetEnumerator方法创建枚举器,然后反复调用MoveNext方法,并获取Current属性的值,就可以每次在该集合中移动一个元素的位置。这正是foreach语句所做的事情。所以,为了创建自己的可枚举集合类,就必须在自己的集合类中实现IEnumerable接口,并提供IEnumerator接口的一个实现,以便由集合类的GetEnumerator方法返回。
重要提示 IEnumerable和IEnumeraton这两个接口名称很容易混淆千万注意区分。
稍微想一下,就会发现IEnumerator接口的Current属性具有非类型安全的行为,因为它返回object 而非具体类型。幸好,.NET Framework类库还提供了泛型IEnumerator<T>接口,该接口同样有Current属性,但返回的是一个T.类似地,还有一个IEnumerable<T>接口,其中的GetEnumerator 方法返回的是一个 Enumerator<T>对象。这两个接口都在System.Collections.Generic命名空间中定义。为2.0或之后的.NETFramework编写应用程序,应在定义可枚举集合时使用这些泛型接口,而不应使用非泛型版本。

手动实现枚举器
下个练习将定义类来实现泛型 IEnumerator<T>接口,并为二叉树类
Tree<TItem）创建枚举器。
前面演示了如何轻松遍历二叉树并显示其内容。这是否意味着定义枚举器,以相同顺序检索二叉树中的每个元素是一件轻松的工作呢?遗憾的是,实情并非如此。主要问题是,定义枚举器要记住自己在结构中的位置,以便后续的MoveNext 方法调用能相应地更新位置。递归算法(例如遍历二叉树时使用的算法)本身无法通过一种易于访问的方式,在方法调用之间维持状态信息。因此,需要对二叉树中的数据进行预处理,把它们转换成更容易访问的数据结构(一个队列),再对该数据结构进行枚举。当然,用户遍历二叉树的元素时,这些幕后操作会在用户面前隐藏起来。
创建 TreeEnumerator类
1.如Microsoft Visual Studio 2017尚未启动,请启动。
2.打开"文档"文件夹下的Microsoft Press\VCSBS\Chapter 19\BinaryTree子文件夹中的BinaryTre解决方案。该解决方案包含前面创建的BinaryTree项目的一个能正常工作的副本。将添加一个新类为二叉树类Tree<TItem>实现枚举器。
3.在解决方案资源管理器中单击BinaryTre 项目。选择"项目"|"添加类",选择"类"模板,在"名称"文本框中输入TreeEnumerator.es,单击"添加"。
TreeEnumerator类为Tree<TItem)对象生成枚举器。为了确保类是类型安全的必须提供类型参数并实现 IEnumerator<T>接口。此外,类型参数对于TreeEnumerator类要枚举的Tree<TItem)对象来说必须是一个有效的类型,所以必须进行约束,规定必须实现 IComparable<TItem>接口。(出于排序的目的,BinaryTree类要求树中的数据项提供一种方式使它们能被比较。)
4 在"代码和文本编辑器"中显示 TreeEnumerator.cs 文件,修改TreeEnumerato.cs类的定义,使之满足上述要求,如加粗的部分所示。
class TreeEnurerator<TItenm:Inumerator<TItem where TItem :IComparable<TItem>
{
}
5.如加粗的语句所示,在TreeEnumerator<TItem>类中添加三个私有变量:
class TretEnuerator<TItem:IEumerator<TItem)where TIten:ICorparable<TItem>
{
	private Tree(TItem> currentData = null;
	private TItea currentItem = default(TIten);
	private Queue<TItem enunData = null;
}
currentData变量容纳对要枚举的树的引用,currentItem变量容纳Current属性返回的值。将用从树的节点提取的值填充enumData队列,并用MoveNext方法依次从队列返回每一项。至于其中的default关键字是什么意思,请参见稍后的补充内容"初始化用类型参数定义的变量"。
6. 为 TreeEnumerator<TItem>类添加一个构造器,获取名为data的Tree<TItem>参数。在构造器主体中添加语句将currentData变量初始化成data:
class TreeEnumerator<TIteD:IEnumerator<TItem where TItem:IComparable<TItem>
{
	...
	public TreeEnumerator(Tree<TItem data)
	{
		this.currentData = data;
	}
	...
}
7.在TreeEnumerator<TItem>类中,紧接在构造器后面添加名为populate(填充)的私有方法:
class TreeEnumerator<TItem:IEnumerator<TItem> where TItem:IComparable<TItem>
{
	...
	private void populate(Queue<TItem> enumQueue,Tree(TItem tree)
	{
		if(tree.LeftTree != null)
		{
			populate(enumQueue, tree.LeftTree);
		}
		enunQueue.Enqueue(tree.NodeOata);

		if(tree.RightTree != null)
		{
			populate(enumQueue, tree.RightTree);
		}
	}
}
该方法遍历二叉树,将二叉树中的数据添加到队列。所用的算法与前面讲过的Tree<TItem>类所用的walkTree方法非常相似。区别是这里不是将NodeData值附加到一个字符串,而是存储到队列中。
8 到TreeEnumerator<TItem>类定义。鼠标移至类声明中的IEnumerator<TItem>字样,从上下文关联菜单中(有一个灯泡图标)选择"显式实现接口"。这个操作将为 IEnumerator<TItem>和IEnumerator 接口中的方法生成存根(即
stub,相当于"占位符",等着你实现),并把它们添加到类的尾部。还会为IDisposable接口生成Dispose方法。
注意    IEnumerator<TItem>接口同时继承了IEnumerator和IDisposable接口,这解释了为什么还会出现这些接口要求的方法.事实上,唯一真正属于IEnumerator<TItem>接口的只有泛型Current属性。MoveNext和Reset方法是
由非泛型IEnumerator接口指定的。
9.检查自动生成的代码。属性和方法主体包含默认实现,它唯一的功能就是抛出NotImplementedException异常。后面的步骤将用真正的实现替换这些代码。
10.用以下加粗的语句更新 MoveNext方法主体:
bool System.Collections.IEnumerator.Novellext()
{
	if (this.enumData == null)
	{
		this.enumData = new Queue<TItem>();
		poulate(this.enumData, this. currentData);
	}
	if (this.enumData,this.currentData);
	{
		this.currentItem = this.enumData.Dequeue();
		return true;
	}
	return false;
}
枚举器的MoveNext方法有两方面的作用。首次调用时初始化枚举器使用的数据，向前跳进到要返回的第一个数据项(记住,首次调用 NoveNext 方法之前,Current属性返回的值是未定义的,会造成异常)。在本例中,初始化过程包括对
队列进行实例化,然后调用 populate方法向队列填充从树中提取的数据。
对 NoveNext方法的后续调用应该只是跳过不同的数据项,直到没有更多的数据项为止。本例就是对队列中的数据项进行出队操作,直到队列变空。重点注意的是,NoveNext 实际并不返回数据项——那是Current属性的事儿。NoveNext 唯一做的事情就是更新枚举器的内部状态(将currentItem变量的值设为出队的数据项),以便由Current属性使用。还有下一个值就返回 true,否则返回 false。
11.如加粗的语句所示修改泛型Current属性的get访问器:
TIten IEnumerator<TItem).Current
{
	get
	{
		if(this.enumOata = null)
		{
			//调用Qurrent 前要先调用一次陷ovetext
			throw neM ImalidoperationEexception("use Novelext before calling urrent");
		}
		return this.currentItem;
	}
}
重要提示 Current属性有两个实现,一定要把上述代码添加到正确的实现中.非泛型版本(System.Collections.IEnumerator.Current)不用管。
Current 属性检查 enumData 变量,确定已调用了一次 MoveNext(首次调用NoveNext前该变量值为nul1)。还没有调用就抛出InvalidOperationException异常——.NETFramework应用程序利用该机制指出某个操作在当前状态下执行不了。如果MoveNext之前调用过,表明已更新好了currentItem变量,所以Current属性唯一要做的就是返回该变量的值。
12． 找到IDisposable.Dispose方法。将 throw new NotImplementedException();
语句注释掉,如加粗代码所示。枚举器未使用任何需显式清理的资源,所以该方法无需做任何事情。但它仍然必须存在。
void IDisposable.Dispose()
{
	//thow new NotImplementedException();
}
13．生成解决方案,纠正报告的任何错误。
初始化用类型参数定义的变量
你或许已注意到,定义并初始化currentItem变量的语句使用了default关键字:
private TItem currentItem = default(TItem);
currentItem变量是用类型参数TItem来定义的.编写和编译程序时,用于替代TItem的实际类型可能是未知的——只有程序运行时才知道具体类型。由于这个原因,难以指定如何对变量进行初始化,有人可能想把它设为null.然而,如果用于替代TItem的类型是值类型,这个赋值就是非法的(不能将值类型设为 null,只有引用类型才可以)。类似地,如果初始化为0并期待提供数值类型、那么一旦提供引用类型,就同样变成非法,还存在其他可能性——例如,TItem可能是Boolean类型,default关键字就是为了解决这个问题设计的、用于初始化变量的值将在语句执行时确定．如果 TItem 是引用类型,default(TItem)返回null;如果TItem是数值,default(TItem)返回0;如果TItem是Boolean类型,default(TItem)就返回 false.如果TItem是结构,结构中各个字段将采取类似的方式来初始化(引用字段初始化为nul1,数值字段初始化为0,Bo0lean 字段初始化为false)。

实现IEnumerable接口
以下练习将修改二叉树类来实现IEnumerable接口。GetEnumerator方法将返回一个TreeEnumerator<TItem>对象,在Tree<TItem>类中实现IEnumerable<TItem>接口
1.在解决方案资源管理器中双击Tree.cs 文件,在"代码和文本编辑器"中显示
Tree<TItem>类。
2. 修改Tree<TItem>类定义来实现IEnumerable<TItem>接口,如加粗部分所示:
public class Tree<TItemp:IEnumerable<TItempwhere TItem:IComparable<TItem>
注意,始终将约束(where子句)放在类声明的末尾。
3.鼠标放到类定义中的IEnumerable<TItem>接口上,点击灯泡图标,选择"显式实现接口"。
将生成 IEnumerable<TItem>.GetEnumerator和IEnumerable.GetEnumerator方法的默认实现,并添加到类的尾部。实现非泛型接口IEnumerable的方法是由于IEnumerable<TItem>接口继承了IEnumerable。
4.找到靠近类尾部的泛型IEnumerable<TItem>.GetEnumerator 方法。修改GetEnumerator()方法主体,将现有的 throw 语句替换成以下加粗的代码
IEnumerator<TItem IEnumerable(TItem).GetEnumerator()
{
	 return new TreeEnumerator<TItem>(this);
}
Enumerator方法的作用是构造枚举器对象来遍历集合。本例唯一要做的就是使用树中的数据来构造一个新的TreeEnumerator<TItem>对象。
5.生成解决方案。如有必要,请改正报告的任何错误,并重新生成解决方案。用foreach 语句遍历二叉树并显示其内容,测试刚才修改好的Tree<TItem>类。

测试枚举器
1.在解决方案资源管理器中右击 BinaryTree解决方案,从弹出菜单选择"添加" "新建项目"。用"控制台应用(NETFramework)"模板添加一个新项目。将项目命名为EnumeratorTest,将位置设为"文档"下的Microsoft Press\VCSBS\Chapter19\BinaryTree子文件夹,单击"确定"按钮。
2.在解决方案资源管理器中右击 EnumeratorTest 项目,选择"设为启动项目"。
3.选择"项目" |"添加引用"。在"引用管理器"对话框左侧窗格展开"项目"并单击"解决方案"。在中间窗格勾选BinaryTree项目,单击"确定"。
随后,在解决方案资源管理器中,Binary/Tree 程序集将出现在EnumeratorTest项目的"引用"列表中。
4.在"代码和文本编辑器"中显示 Program类,在文件顶部添加以下 using指令:
using BinaryTree;
5.在Nain方法中添加以下加粗的代码,创建并填充由int值构成的二叉树:
static vwoid in(string[] args
{
	Treedint>treei = new Treexint>(18);
	tree1.Insert(5);
	tree1.Insert(11);
	treel1.Insert(5);
	tree1.Insert(-12);
	treed.Insert(15);
	treel1.Insert(0);
	treed.Insert(14);
	tree1.Insert(-8);
	tree1.Insert(18);
}
6.如加粗的代码所示,添加 foreach 语句来枚举树的内容并显示结果:
static vold Main(string[] args)
{
	...
	foreach(int item in tree1)
	{
		Console.writeLine(item);
	}
}
7.选择"调试"|"开始执行(不调试)"命令。
8.按 Enter键返回Visual Studio 2017。

用迭代器实现枚举器
如你所见,为了将集合变得"可枚举",其过程非常复杂,且容易出错。为减轻程序员的负担,C#提供了迭代器来帮程序员完成其中大部分工作。
根据C#规范,迭代器(terator)是能生成(yield)已排序值序列的一个代码块。注意迭代器实际不是"可枚举"类的成员。相反,它只是指定了一个序列,枚举器应该用该序列返回值。也就是说,迭代器只是对枚举序列的一个描述,C#编译器可利用它自动生成枚举器。为了正确理解这个概念,先来看一个简单的例子。
一个简单的迭代器
以下BasicCollection<T>类展示了迭代器的基本实现原理。类用一个List<T>容纳数据,并提供了F1List 方法来填充列表。还要注意,BasicCollection<T>类实现了IEnumerable<T>接口。接口规定的GetEnumerator方法用一个迭代器实现。
using System;
using System.Collections.Generic;
using System. Collections;
class BasicCollection<T>:IEnumerable<T>
{
	private List<T>data= new List<T();
	public vold FillList(paramsT[] items)
	{
		foreach(var datum in items)
		{
			data.Add(datum);
		}
	}
	IEnumerator<T>IEnumerable<T>.GetEnumerator()
	{
		foreach(var datum in data)
		{
			yield return datum;
		}
	}
	IEnumerator IEnumerable.GetEnumerator()
	{
		//这是非泛型板本,本例未实现
		throw new NotImplementedException();
	}
}
Getnumerator 方法虽然一目了然,但仍有必要多讨论一下。首先注意,它并不返回IEnumerator<T>类型的对象。相反,它遍历 data 数组中的各项,并依次返回每一项。重点在于yield关键字的使用。yield关键字指定每次迭代(循环重复)要返回的值。可这样理解 yield语句:它临时将方法"叫停",将一个值传回调用者。当调用者需要下一个值时,GetEnumerator方法就从上次暂停的地方继续,生成下一个值。最终,所有数据都被耗尽,循环结束,GetEnumerator方法终止。到这个时候,迭代过程就结束了。
这并不是一个平常所见的方法。GetEnumerator方法中的代码定义了一个迭代器。编译器利用这些代码实现IEnumeratorT）接口,其中包含Current属性和NoveNext方法。这个实现与GetEnumeraton方法所指定的功能完全匹配。但程序员无法看见这些自动生成的代码(除非对程序集进行反编译)。与获得的便利相比,这一点儿代价(看不到自动生成的代码)微不足道。可采取和平常一样的方式调用迭代器生成的枚举器,如以下代码块所示:
Basiccollectionkstring bc = new Basiccollectionkstring>();
bc.FillList("Twas","brl1ig","and","the",slithy,"toves");
foreach(string word in bc)
{
	Console.writeLine(word);
}
上述代码按以下顺序输出bc对象中的内容:
Twas,brlllig, and, the,slithy,toves
要提供不同迭代机制,按不同顺序显示数据,可实现附加属性来实现 IEnumerable接口,并用一个迭代器返回数据。例如,下面展示了BasicCollection<T>类的Reverse 属性,它按相反顺序获取数据：
class BasicCollection<T>:IEnumerable<T>
{
	...
	public IEnumerable<T> Reverse
	{
		get
		{
			for(int 1 = data.Count-1;i>= 0;1--)
			{
				yield return data[i];
			}
		}
	}
}
像下面这样调用该属性:
BasicCollection<string>bc = new BasicCollectioncstring(); bc.FillList("Twas","brillg,"and","the",slithy*,"toves"); 
foreach(string word in bc.Reverse)
{
	Console.writelLine(word);
}
上述代码将按相反顺序输出bc的内容:
toves, slithy,the,and, brillg,TMas

使用迭代器为Tree<TItem>类定义枚举器
以下练习使用迭代器为 Tree<TItem>类实现枚举器。在之前的练习中,要求先用NoveNext方法对树中的数据进行预处理,并在处理得到的一个队列的基础上进行操作。相反,本练习将定义迭代器,使用更自然的递归机制来遍历树,这类似于MalkTree方法。Tree<TItem)类添加枚举器
1.在Visual Studio 2017中打开"文档"文件夹下的Microsoft PressVCSBS\Chapter 19\IteratorBinaryTree子文件夹中的 BinaryTree解决方案。该解决方案包含BinaryTree 项目的副本。
2. 在"代码和文本编辑器"中打开文件Tree.cs。修改Tree<TItem>类的定义来实现IEnumerable<TItem>接口,如加粗部分所示:
public class Tree<TItam:IEumerable<TItem> where TItem:IComparable(TItem>
{
	...
}
3.鼠标放到类定义中的IEnumerable<TItem>上方,点击灯泡图标并选择"显式实现接口"。
IEnumerable<TIten>.GetEnumerator和IEnumerable.GetEnumerator这两个方法将添加到类的尾部(一个是泛型版本,一个是非泛型版本)。
4.找到泛型IEnumerable<TItem>.GetEnumerator方法,将 GetEnumerator方法自主体(原本是一条 throw语句)替换成以下加粗的代码:
IEnumerator<TItem) IEnumerable(TItem>.GetEnumerator()
{
	if(this.teftTree != null)
	{
		foreach（TItem item in this. LeftTree)
		{
			yield return item;
		}
	}
}
yield return this. NodeData;
if(this.RightTree l= null)
{
	foreach（TItem item in this.RightTree)
	{
		yield return item;
	}
}
表面或许不太明显,但上述代码确实遵循了前面描述的用于列出二叉树内容的递归算法。如LeftTree非空,第一个foreach语句将隐式调用它的GetEnumerator方法(也就是当前在定义的方法)。该过程一直持续,直到发现一个没有左子树的节点。这时要生成NodeData属性中的值。然后按相同方式检查右子树。右子树的数据用光后,将返回父节点,输出父节点的NodeData属性,并检查父节点的右子树。这套动作反复进行,直到枚举完整个树,输出所有节点。
测试新枚举器
1.在解决方案资源管理器中右击BinaryTree解决方案,选择"添加"|"现有项目"。在"添加现有项目"对话框中切换到文件夹MicrosoftPress\VCSBS\Chapter19BinaryTree\EnumeratorTest,选择EnumeratorTest项目文件,单击"打开"按钮。
2. 在解决方案资源管理器中右击EnumeratorTest 项目,选择"设为启动项日"。
3. 展开 EnumeratorTest项目的"引用"节点。右击BinaryTree并从弹出菜单中选择 "移除"命令。
4.选择"项目"|"添加引用"。展开"引用管理器"对话框左侧窗格的"项目" 节点并单击"解决方案",在中间窗格勾选 BinaryTree项目,单击"确定"按钮。
新的 BinaryTree程序集会在 EnumeratorTest 项目的引用列表中出现。
注意 这两个步骤确保EnumertorTest项目引用的是用迭代器来创建枚举器的那个版本 的BinaryTee程序集,而不是旧版本.
5.在"代码和文本编辑器"中打开EnumeratorTest 项目的Programcs 文件。检查 Program.cs 文件中的Nain方法。和测试旧版本的枚举器时一样,该方法实例化一个Tree<int>对象,在其中填充一些数据,然后用foreach 语句显示内容。
6、生成解决方案,纠正任何错误。
7.选择"调试"|"开始执行(不调试)"。
程序运行时,应该显示和以前一样的值序列:
-12,-8,θ,5,5,19,18,11,14,15
8. 按 Enter 键返回Visual Studio 2017。

分离应用程序逻辑并处理事件
声明委托类型来抽象方法签名
创建委托实例来引用具体方法
通过委托调用方法
定义Lambda表达式来指定由委托执行的代码
声明event字段
用委托处理事件引发事件

许多示例和练习都强调要精心定义类和结构来强制封装性。这样以后修改方法的实现时,就不至于影响正在使用它们的应用程序。但有时不能或者不适合封装类型的完整功能。例如,类中一个方法的逻辑可能要依赖于调用该方法的组件或应用程序,它可能要执行应用程序或组件特有的处理。问题是,在构造类并实现其方法时,可能还不知道使用它的是哪些应用程序和组件。同时,代码不应具有依赖,以免限制类的使用。委托提供了理想的解决方案,方法的逻辑和调用方法的应用程序可以完全分开(称为解耦或 decouple)。C#事件用于支持与此相关的一种情况。本书各个练习所写的大多数代码都假定语句顺 序执行。这确实很常见,但偶尔必须打断当前执行流程,转为执行另一个更重要的任务。 任务结束后,程序从当初暂停的地方恢复执行。一个经典的例子就是开发图形应用程序时 使用的"通用Windows平台"(UWP)窗体。窗体上显示了按钮和文本框等控件。单击按钮,或者在文本框中输入,我们希望窗体能立即响应。应用程序必须暂停它当前正在做的事情,转为处理我们的输入。这种风格的操作不仅适合图形用户界面(GUI),还适合必须紧急执行某个操作的任何程序——例如在核反应堆过热时关闭。为此,"运行时"必须提供两个机 制:一个机制通知发生了紧急事件;另一个机制规定在发生事件时要运行的代码。这正是事件和委托的用途。

理 解 委 托
委托是对方法的引用。概念很简单,但门道很多。下面详细解释。
注意 之所以称为委托,是因为一旦被调用,就将处理"委托"给引用的方法。
调用方法是指定方法名(可指定方法所属的对象或结构名称)。看代码就知道要运行哪个方法,以及在什么时候运行。下例调用Processor对象的performCalculation方法(它具体做什么以及 Processor类的定义不重要）:
Processor p = new Processor();
P.performCalculation();
委托对象引用了方法。和将int值赋给 int变量一样,是将方法引用赋给委托对象。
下例创建performCalculationDelegate委托来引用 Processor 对象的peformCalculation方法。这里故意省略了委托的声明,因为当前应关注概念而非语法(稍后就会学到完整语法)。
Processor p a new Processor();
delegate... performCalculatiorDelegate...;
performCalculationDelegate= p.performCalculation;
将方法引用赋给委托时,并不是马上就运行方法。方法名之后没有圆括号,也不指定任何参数。这纯粹就是一个赋值语句。将对Processor对象的performCalculation方法的引用存储到委托中之后,应用程序就可通过委托来调用方法了,如下所示:
performCalculatiorDelegate();
看起来和普通方法调用无异:不知 情的话还以为运行的是名为performCalculationDelegate的方法。但CLR知道它是委托,所以自动获取引用的方法并运行之。之后可以更改委托引用的方法,使调用委托的语句每次执行都运行不同的方法。
另外,委托可一次引用多个方法(把它想象成方法引用集合)。一旦调用委托,所有方法都会运行。
注意 如果熟悉C++,会发现委托和画数指针很相似。但和函数指针不同,委托是类型安全的;换言之,只能让委托引用与委托签名匹配的方法。另外,尚未引用有效方法的委托是不能调用的。
.NET Framework 类库的委托例子.NET Framework类库在它的许多类型中广泛运用了委托,已遇到其中两个例子:List<T>类的 Find和 Exists方法。这两个方法搜索 List<T>集合,返回匹配项或测配项是否存在。设计 List<T类时肯定不知道何谓"匹配",所以要让开发人员自己 定义,以"谓词"的形式指定匹配条件。谓词其实就是委托,只不过它恰好返回 Boolean值而已。以下代码帮你复习Find方法的用法,
struct Person
{
	Public int ID{ get;set;}
	public string Name (get;set;}
	public int Age{ get;set;}
}
...
List<Person> personnel = new List<Person>()
{
	new Person(){ID =1,Mame="John",Age = 53}, 
	new Person(){ID =2,Name="Sid",Age= 28}, 
	new Person()(ID =3,Name "Fred",Age=34 },
	new Person(){ID=4,Name ="Paul",Age= 22},
};
...
//查找ID为3的第一个列表成员
Person match = personnel.Find(p => p.ID == 3);
List<T>类利用委托执行操作的其他方法还有Average,Max,Min,Count和Sum。这些方法获取一个Func 委托作为参数。Func委托引用的是要返回值的一个方法(一个函数)。
下例使用 Average方法计算personnel集合中的人的平均年龄(Func<T>委托只是返回集合 中每一项的Age字段的值),使用Max方法判断ID最大的人,并用Count方法计算多少个 人年龄在30到39岁(含)之间
double averageAge = personnel,Average(p =>p.Age); 
Console.writeLine($"Average age is{averageAge}");
...
int id =personnel.Max(p=>p.ID);
Console.writeLine($"Person with highest ID is{(id}");
...
int thirt int thirties= personnel.Count(p=>p.Age >= 38.&& p.Age (<= 39);
Console.lwriteLine($"Mumber of personel in their thirttes is{thirties}");
代码输出如下:

Average age is 34.25 
Person with highest ID is 4 
Number of personnel in their thirties is 1
本书剩余部分还会演示.NETFramework类库的其他许多委托类型。当然还能定义自i的委托。下面用例子来演示如何以及在什么时候创建自己的委托
Func<T, ...）和Action<T,...>委托类型
List<T>类的 Average、Max、Count 和其他方法获取的参数实际是泛型 Func<T,TResult>委托;两个类型参数分别是传给委托的类型和返回值的类型,对于List<Person>的Average,Max和Count方法,第一个类型参数T是列表数据的类型(Person结构),而TResult类型参数根据委托的使用上下文推断.下例的TResult是int,因为Count方法返回整数:
int thirties= personnel.Count(p >p.Age >= 36 8& p.Age<= 39);
所以，这个例子中,Count方法期待的委托类型是Func<Person,int>.这听起来有点学究气,因为编译器会根据 List<T>的类型自动生成委托,但最好还是熟悉一下这个机制,因为它在.NETFramework类库中实在是太常见了.事实上,System命名空间定义了一整套Func委托类型,从不获取参数而返回结果的 Func<TResult>,到获取16个参数的 Func<T1,T2,T3,T4,…T16,TResult>.如果发现需要自己创建符合这种模式的委托类型,就应考虑改为使用一个合适的Func委托类型.
除了Func,System命名空间还定义了一系列Action委托类型。Action委托引用的是采取行动而不是返回值的方法,即 void方法.同样,从获取单个参数的Action<T>到Action<T1,T2,3,T4,...,T16>一应俱全.
自动化工厂的例子
要为一间自动化工厂写控制系统。工厂包含大量机器。生产时,每台机器都执行不同任务:切割和折叠金属片、将金属片焊接到一起以及印刷金属片等。每台机器都由一家专业厂商制造和安装。机器均由计算机控制,每个厂商都提供了一套 API,可利用这些API来控制他们的机器。你的任务是将机器用的不同系统集成到单独一个控制程序中。作为控制程序的一部分,你决定提供在必要时快速关闭所有机器的一个机制。每台机器都有自己的、由计算机控制的过程(和函数)来实现安全停机。具体如下:
StopFolding();//折叠和切密
Finishaelding()://焊接
Paintoff(): //彩和机
不用委托实现工厂控制系统
为了在控制程序中实现停机功能,可采用以下简单的方式:
class Controller
{
	//代表不同机器的字段
	private FoldingMchine folder;
	private WeldingMachine welder;
	private PaintingMachine painter;
	...
	public void ShutDown()
	{
		folder.StopFolding();
		welder.FinishMelding();
		painter.PaintOff();
	}
	...
}
虽然种方式可行,但扩展性和灵活性都不好。如果工厂采购了新机器,就必须修改这些代码,因为Controller类和机器是紧密联系在一起的。

用委托实现工厂控制系统
虽然每个方法的名称不同,但都具有相同的"形式",即都不获取参数,也都不返回值(以后会解释如果情况不是这样会发生什么）。所以,每个方法的常规形式如下:
void methodName();
这正是委托可以发挥作用的时候。可用和上述形式匹配的委托引用任意停机方法。像下面这样声明委托:
delegate volid stopMachineryDelegate();
注意以下几点。
声明委托要使用 delegate关键字。
委托定义了它所引用的方法的"形式"。要指定返回类型(本例是void)、委托名称(stopMachineryoDelegate)以及任何参数(本例无参)。
定义好委托后,就可创建它的实例,并用+=操作符让该实例引用匹配的方法。在Controller类的构造器中可以这样写：
class Control
{
	delegate void stopMachineryoelegate(); //声明委托类型
	private stopMtachineryDelegate stopMachinery;//创建委托实例
	...
	public Controller()
	{
		this.stopMachinery += folder.StopfFolding;
	}
	...
}
上述语法需要一段时间来熟悉。它只是将方法加到委托中;此时并没有实际调用方法。操作符+已进行了重载,所以在随同委托使用时,才具有了这个新的含义。注意只需指定方法名,不要包含任何圆括号或参数。
可安全地将操作符+用于未初始化的委托。该委托将自动初始化。还可使用 new关键字显式初始化委托,让它引用一个特定的方法,例如:
this.stopMachinery = new stopMachinerypDelegate(folder.stopFolding);
可通过调用委托来调用它引用的方法,示例如下:
public void ShutDown()
{
	this.stopMachinery();
	...
}
委托调用语法与方法完全相同。如果引用的方法要获取参数,应在圆括号内指定。
注意 调用没有初始化而且没有引用任何方法的委托会抛出 NullReferenceException异常。
委托主要优势在于它能引用多个方法,使用操作符+=将这些方法添加到委托中即可,就像下面这样；
public  Controller()
{
	this.stopMachinery += folder.StopFolding;
	this.stopMachinery += welder.FinishWelding;
	this.stopMachinery += painter.Paintoff;
}
在Controller类的Shutdown方法中调用this.stopMachinery(),将自动依次调用上述每一个方法。Shutdown方法不需要知道具体有多少台机器,也不需要知道方法名。
使用用复合赋值操作符-=,则可从委托中移除一个方法:
this.stoprachineryMachinery -= folder. StopFolding;
当前的方案是在Controller类的构造器中将机器的停机方法添加到委托中。为了使Controller类完全独立于各种机器,需要使stopMachineryDelegate成为公共,并提供一种方式允许Controller外部的类向委托添加方法。有以下几个选项。
将委托变量 stopMachinery 声明为公共:
public stopMachineryDelegate stopMachinery;
保持 stopMachinery委托变量私有,但提供可读/可写属性来访问它:
private stopMachineryDelegate stoprMachinery;
...
public stopMachinery StopMachinery
{
	get => this.stopachinery;
	set => this.stopMachinery = value;
}
实现单独的 Add和Remove方法来提供完全的封装性。Add方法获取一个方法作为参数,并把它添加到委托中;Remove 则从委托中移除指定的方法(注意,添加或移除的方法要作为参数传递,参数类型就是委托类型):
public void Add(stopachineryDelegate stoprethod)>ths.stopMachinery+= stopethod;
public void Remove(stopkachineryDelegate stopMethod)=>this. stopMachinery-= stopMethod;
如果坚持面向对象的编程原则,或许会倾向于Add/Remove方案。但其他方案同样可行,也同样被广泛运用,所以这里列出了全部方案。
Controller control = new controller();
FoldingMachine folder = new FoldinghMachine();
Meldingtachine welder = new weldinghMachine();
PaintingtMachine painter= new PaintingMachine();
...
control.Add(folder.StopFolding);
control.Add(welder.Finishilelding);
control.dd(painter.PaintOff);
...
control.ShutDown();
...
声明和使用委托
以下练习将完成Wide WorldImporters公司的一个应用程序。该公司进口并销售建筑材料和工具,应用程序允许客户浏览库存商品并下单。应用程序在窗体上显示当前有货商品,并用一个窗格列出客户选中的商品,单击Checkout按钮即可下单。随后将处理订单并清除结账窗格。
目前,客户下单会采取以下几个行动。
请求客户付款。
检查订购商品，任何商品要限制年龄（如电动工具）,就审计并跟踪订单细节。
生成发货单,其中包含订单的汇总信息。
审计和发货逻辑独立于结账逻辑。将来可能对这些逻辑进行修改,例如可能需要修改结账过程。所以,付款结账逻辑最好与审计/发货逻辑分开,以简化应用程序的维护和升级。
首先检查应用程序,判断它目前在哪些方面还满足不了这些要求。然后修改应用程序,删除结账逻辑和审计/发货逻辑之间的依赖性。
检查 Wide Worid lmporters 应用程序的逻辑
1.如Microsoft Visual Studio2017尚未启动,请启动。
2.打开 Delegates 解决方案,它位于"文档"文件夹下的Microsoft Press\VCSBS\Chapter 20\Delegates 子文件夹。
3.选择"调试"|"开始调试"。
项目开始生成并运行。随后出现一个窗体,其中显示了可用商品。其中有一个窗格显示了订单细节(刚开始空白）。该应用在水平滚动的GridView控件上显示商品。
4.选中一个或多个商品,单击Add把它们添加到购物车。确定至少选择一件要限制年龄的商品(Age Restricted显示为Yes）。商品添加后会出现在右侧的Order Details窗格。同样的商品添加两次,数量会自动递增。(应用程序的这个版本尚未实现从购物车删除商品的功能。)
5.单击Order Details 窗格中的Checkout 按钮。随即显示一条消息指出已下单。订单具有唯一ID,还会显示订单金额。
6.单击"关闭",再关闭应用程序,从而关闭调试并返回Visual Studio 2017。
7.在解决方案资源管理器中展开 Delegates项目节点,双击Package.appxmanifest 文件。随后会打开包的清单设计器。
8.在清单设计器中单击"打包"标生
注意"包名"字段显示的值,这是一个"全局统一标识符"(Globally Unique lIdentifir,GUID)。记录下来
9.用文件资源管理器打开SERPROFLE%\pDataLocalPackages\文件夹,再打开以刚才的GUID值开头的文件夹",最后打开LocalSte文件夹。这是WideWorld Importers 应用的本地文件夹。应看到两个文件,一个是 audit-mmnmn.xml(nnnnnn
是订单ID),另一个是dispatch-nnnnnn.txt。第一个文件由审计组件生成,第二个是发货组件生成的发货单。
注意 如果没有audit-nnnnnn.xml文件,表明下单时没有选择有年龄限制的商品。在这种情况下,请切换回应用程序,新建包含一个或多个这种商品的订单．
10.用Visual Studio 打开audit-nnnnnn.xml文件。该文件包含有年龄限制的商品列表,还有订单编号和日期。检视完内容后,在VisualStudio 中关闭该文件。
11.使用记事本打开dispatch-nnnnnn.txt文件。文件包含订单ID以及总金额。关闭记事本程序,返回Visual Studio 2017。
12.在Visual Studio 中,注意,解决方案由以下几个项目构成。
Delegates 该项目包含应用程序本身。MainPage.xaml 文件定义用户界面,MainPage.xaml.cs 文件定义应用程序。
AuditService 该项目包含用于实现审计过程的组件。作为类库打包,包含名为Auditor的类。该类公开了名为AuditOrder的公共方法。方法检查订单,如果包含有年龄限制的商品就生成audit-nnnnnn.xml文件。
DelilveryService 该项目包含用于执行发货逻辑的组件,作为类库打包。发货功能包含在 Shipper类中。该类提供了名为 ShipOrder的公共方法,负责处理发货过程并生成发货单。
注意 欢迎研究Auditor和Shipper类的代码,但就本应用程序来说,暂无必要完全理解组件的内部工作原理。
DataTypes 该项目包含其他项目要用到的数据类型。Product类定义应用程序显示的产品细节,产品数据保存在 ProductDatasource类中。(应用程序目前使用硬编码的商品集合。在生产系统中,这些信息应该从数据库或Web
服务获取。)Order和OrderItem类实现订单结构,每个订单都由一件或多件商品构成。
13.显示Delegates 项目的MainPage.xaml.cs 文件,检查私有字段和MainPage构造器。
重要元素如下所示:
...
private Auditor auditor = null;
private Shipper shipper = null;
public MainPage()
{
	...
	this.auditor= new Auditor();
	this.shipper= new Shipper();
}
auditor和 shipper字段包含对Auditor和 Shipper类的实例的引用,构造器实
例化这些对象。
14.找到CheckoutButtonClicked 方法。单击 Checkout 下单将运行该方法。方法的前几行如下所示:
private void CheckoutButtonClicked(object sender,RoutedEventArgs e)
{
	try
	{
		//执行结账过程
		if（this.requestPayment())
		{
			this.auditor.AuditOrder(this.order);
 			this.shipper.Shiporder(this.order);
		}
		...
	}
	...
}
方法实现结账过程。它请求客户付款,然后调用auditor对象的AuditOrder方法，再调用shipper对象的ShipOrder方法。未来需要的任何业务逻辑都在这里添加。if语句后的代码涉及UI管理,包括向用户显示消息框以及清除右侧Order Details 窗格。
注意 为简化讨论,requestPayment方法目前只是返回true来指出已收到付款。真的应用程序必须执行完整的付款处理。虽然应用程序能正常工作,但Auditor和Shipper组件与结账过程紧密集成。这些组件如发生变化,整个应用程序都需要更新。类似地,要在结账过程中集成额外的逻辑(例如用其他组件执行),就必须对应用程序的这一部分进行修订。
下个练习将结账的业务逻辑从应用程序解耦。结账仍需调用Auditor和Shipper组件,但必须具有很强的扩展性,以方便集成额外的组件。将为此创建名为CheckoutController的新组件。它实现结账逻辑,并公开一个委托,允许应用程序指定在此过程中要使用的组件和方法。CheckoutController组件用委托调用这些方法。
创建 Checkoutcontroller 组件
1.在解决方案资源管理器中右击Delegates 解决方案,从弹出菜单中选择"添加"│"新建项目"。
2.在"添加新项目"对话框的左侧窗格单击"VisualC#"下的"Windows通用"。在中间窗格选择"类库(通用Windows)"模板。在"名称"文本框中输入CheckoutService,单击"确定"。
3. 询问目标版本和最低版本时接受默认值。单击"确定"。
4.在解决方案资源管理器中展开 CheckoutService项目,右击Classl.cs并选择"重命名"。将文件名更改为CheckoutController.cs。看见提示后,允许Visual Sudio将所有Class1引用更改为CheckoutController。
5.右击CheckouService项目的"引用"节点,选择"添加引用"。
6.在"引用管理器"对话框左侧窗格展开"项目",单击"解决方案"。在中间窗格勾选 DataTypes 项目,单击"确定"CheckoutController类要使用 DatarTypes 项目中定义的Order类
7.打开 CheckoutController.cs 文件,在顶部添加以下using指令:
using DatarTypes;
8.为 CheckoutController类添加公共委托类型 CheckoutDelegate,如加粗的语句所示:
public class Checkoutcontroller
{
	publicdelegate void Checkoutbelegate(Order order);
}
可用该委托类型引用获取一个Order参数而不返回结果的方法,正好匹配Auditor和 Shipper类的AuditOrder和 ShipOrder方法。
9.添加基于该委托类型的公共委托CheckoutProcessing,如加粗的代码所示:
public class CheckoutController
{
	public delegate void CheckoutDelegate(Order order);
	public Checkoutbelegate CheckoutProcessing = null;
}
10.打开Delegates项目的MainPage.xaml.cs 文件,找到文件末尾的 requestPayment方法。从 MainPage类中剪切掉该方法。返回 CheckoutController.cs文件,将方法粘贴到heckoutController类中,如加粗的代码所示:
public class CheckoutController
{
	public delegate void CheckoutDelegate(Order order);
	public CheckoutDelegate CheckoutProcessing = null;

	private bool requestPayment()
	{
		// Payment processing goes here
		// Payment logic is not implemented in this example
		//-simply return true to indicate payment has been received return true;
	}
}
11.将加粗的StartCheckoutProcessing方法添加到CheckoutController类中:
public class CheckoutController
{
	public delegate void CheckoutDelegate(Order order);
	public CheckoutDelegate CheckoutProcessing = null;

	private bool requestPayment()
	{
		...
	}
	public void StartCheckoutProcessing(Order order)
	{
		//Perform the checkout processing
		if(this.requestPayment())
		{
			if(this.CheckoutProcessing I= null)
			{
				this.CheckoutProcessing(order);
			}
		}
	}
}
该方法提供之前由MainPage类的CheckoutButtonClicked方法实现的结账功能。
它请求付款并检查 CheckoutProcessing 委托。如委托非空(引用一个或多个方 法),就调用委托。此时,委托引用的所有方法都将运行。
12.在解决方案资源管理器中右击Delegates项目的"引用"节点并从弹出菜单中选择 "添加引用"命令。
13.在"引用管理器"对话框左侧窗格展开"项目",单击"解决方案",在中间窗格勾选CheckoutService 项目,单击"确定"。
14.返回Delegates项目的MainPage.xaml.cs 文件,在顶部添加以下using指令:
using CheckoutService;
15.在 MainPage 类 中 添 加 CheckoutController 类型的私有变量ckoutController并初始化为 null；
public...class MainPage:...
{
	...
	private Auditor auditor= null; 
	private Shipper shipper=null; 
	private CheckoutController checkoutcontroller= null;
	...
}
16.找到 MainPage 构造器。在创建 Auditor 和 Shipper 组件的语句之后实例化CheckoutController 组件:
public MainPage()
{
	...
	this.auditor new Auditor();
	this.shipper = new Shipper();
	this.checkoutController = new CheckoutController();
}
17.在构造器刚才输入的语句后添加以下加粗的语句:
public MainPage()
{
	...
	this.checkoutController = new CheckoutController();
	this.checkoutController.CheckoutProcessing += this. auditor.Auditorder; this.checkoutController.CheckoutProcessing += this.shipper.ShipOrder
}
这些代码为 checkoutController 对象的CheckoutProcessing 委托添加对Auditor和 Shipper对象的AuditOrder和 ShipOrder方法的引用。
18.找到 CheckoutButtonClicked方法。在try块中,将现有的结账代码(if 语句块替换成以下加粗的语句:
private vold CheckoutButtonClicked(object sender,RoutedEventArgs e）
{
	try
	{
		//执行结账过程
		this.checkoutController.StartCheckoutProcessing(this.order);

		//显示订单汇总
		...
	}
	...
}
现已成功将结账逻辑与结账所用的组件分开。MainPage 类的业务逻辑指定CheckoutController 应使用什么组件。
测试应用程序
1.选择"调试"|"开始调试"来生成并运行应用程序。
2.出现WideWorld lmporters窗体后,选择一些商品(至少选择一个有年龄限制的),单击Checkout。
3. 出现Order Placed 消息后,记录订单号并单击"关闭"。
4.用文件资源管理器打开SERPROFILE?pDataLocal\Packages\文件夹,再打开以之前记录的GUID值开头的文件夹,最后打开LocalState文件夹。验证已生成新的audit-nnnnnn.xml和dispatch-nnnnnn期nn.xt文件。nnnnnn是订单号。检查文件,验证它们包含订单细节。
5.返回VisualStudio 2017并停止调试。

Lambda表达式和委托
迄今为止在向委托添加方法的所有例子中,都只是使用方法名。例如前面的自动化工厂例子,为了将 folder对象的StopFolding方法添加到 stopMachinery委托中,我们是这样写的:
this.stoprtachinery += folder.Stopfolding
对于委托签名匹配的简单方法,这样写合适。但如果情况有变呢?假定StopFolding方法实际的签名如下所示:
void StopFolding(int shutDoanTIme);//在指定秒数后停机
它的签名现在有别于Finishwelding及 PaintOff 方法,所以,不能再拿同一个委托处理全部三个方法。

创建方法适配器
一个解决方案是创建另一个方法,在内部调用StopFolding,自身不获取任何参数:
void FinishFolding()
{
	folder.StopFolding(0);//立即停机
}
然后,就可以将FinishFolding方法(而不是StopFolding方法)添加到stopMachinery
委托中。语法和以前一样：
this.stoprtachinery += folder. FinishFoldin;
调用stopNachinery委托实际会调用FinishFolding,后者又会调用StopFolding方法并传递参数值0。
注意 FinishFolding方法是适配器的典型例子。适配器是指一个特殊方法,它能转拟 (或者说"适配"）一个方法,为它提供不同的签名,作为十分常见的设计模式,已在《设计模式:可复用面向对象软件的基础》(Erich Gamma,Richard Helm,Ralph Johnson和JohnVIisides,Addison-Wesley Professional,1994)一书中进行了规范。
很多时候,像这样的适配器方法非常小,很难在方法的"汪洋大海"中找到它们(尤其是在一个很大的类中)此外,除了适配StopFolding方法供委托使用,其他地方一般用不上。C#针对这种情况提供了Lambda表达式。在工厂的例子中,可以使用以下Lambda表达式:
this.stopachinery （() =>folder.StopFolding(0));
调用stopNachinery委托时会运行Lambda表达式定义的代码,后者调用StopFolding 方法并传递恰当的参数。

启用事件通知
前面展示了如何声明委托类型、调用委托以及创建委托实例。但工作只完成了一半。虽然委托允许间接调用任意数量的方法,但仍然必须显式调用委托。许多时候需要在发生某事时自动运行委托。例如,在自动化工厂的例子中,一台机器过热应自动调用stopMachinery委托来关闭设备。.NET Framework提供了事件。可定义并捕捉特定的事件,并在事件发生时调用委托来进行处理。.NETFramework 的许多类都公开了事件。能放到UWP应用的窗体上的大多数
控件以及 window 类本身,都允许在发生特定事件(例如单击按钮或输入文字)时运行代码。

还可声明自己的事件。
声明事件
事件在准备作为事件来源的类中声明。事件来源类监视其环境,在发生某件事情时引发事件。在自动化工厂的例子中,事件来源是监视每台机器温度的一个类。检测到机器超出热辐射上限(过热),温度监视器类就引发"机器过热"事件。事件自己维护一个方法列表,被引发就调用这些方法。有时将这些方法称为订阅者(它们登记对事件的关注)。这些方法应准备好处理"机器过热"事件并能采取必要的纠正行动:停机!
声明事件和声明字段相似。但由于事件随委托使用,所以事件的类型必须是委托,而必须在声明前附加 event 前缀。用以下语法声明事件:
event delegateTypeame eventMome  //delegaterypeNme是委托类型名称,
								//eventhame是事件名称	

例如,以下是自动化工厂的 StopMachineryDelegate 委托。它现在被转移到新类TemperatureMonitor(温度监视器)中。该类为监视设备温度的各种电子探头提供了接口(相较于Controller类,这是放置事件的一个更合理的地方）。
class Temperatureonitor
{
	public delegate void StopMachineryoelegate();
	...
}
可以定义 MachineOverheating 事件,该事件将调用stopMachineryDelegate,就像下面这样:
class Temperatureonitor
{
	public delegate void StopNachineryoelegate();
	public event StopMachineryoelegate MachineOverheating;
	...
}
Temperatureonitor类的内部逻辑(未显示)会在必要时引发 MachineOverheating事件。至于具体如何引发事件,另外,要把方法添加到事件中——这个过程称为订阅事件或者向事件登记(subscribe to a event)——而不是添加到事件基于的委托中。

订阅事件
类似于委托,事件也用+=操作符进入就绪状态。我们使用+=操作符订阅事件。在自动工厂的例子中,一旦引发MachineOverheating 事件就调用各种停机方法,如下所示:
class Temperatureonitor
{
	public delegate void StopMachineryDelegate(); 
	public event StopMachineryoelegate MachineOverheating;
	...
}
...
Temperatureonitor temp*onitor a new Temperatureonitor();
...
tempMonitor.MachineOverheating （()=>{ folder.StopFolding(0);}); tempMonitor.NachineOverheating += welder.FinishWelding; 
tempMonitor.NachineOverheating += painter.PaintOff;
注意,语法和将方法添加到委托中的语法相同。甚至可以使用Lambda表达式来订阅。
tempMonitor.MachineOverheating 事件发生时,会调用所有订阅了该事件的方法,从而关停所有机器。

取消订阅事件
+=操作符用于订阅事件;对应地,-=操作符用于取消订阅。-=操作符将一个方法从事件的内部方法集合中移除。该行动通常称为取消订阅事件或者从事件注销(unsubscribing from a event)
引发事件
事件可以像方法一样通过调用来引发。引发事件后,所有和事件关联的委托会被依次调用。例如,Temperatureonitor类声明私有方法Notify 来引发MachineOverheating事件:
class Temperatureonitor
{
	public delegate void StopMachineryoelegate;
	public event StopMachineryDelegate MachineOverheating;
	...
	private void Notify()
	{
		if(this.NachineOverheating !=null)
		{
			this.Machineoverheating();
		}
	}
	...
}
这是一种常见的写法。null检查是必要的,因为事件字段隐式为null,只有在一个方法使用＋=操作符来订阅它之后,才会变成非nul1。引发null事件将抛出MulReferenceException异常。如果定义事件的委托要求任何参数,引发事件时也必须提供。稍后会展示这样的一些例子。
重要提示 事件有一个非常有用的内置安全功能。公共事件(例如MachineOverheating)只能由定义它的那个类(Temperatureonitor类)中的方法引发,在类外部引发事件会造成编译时错误。
理解用户界面事件
如前所述,用于构造 GUI的.NETFramework类和控件广泛运用了事件。例如,从ButtonBase 类派生的 Button 类继承了RoutedEventHandler类型的公共事件 Click。
RoutedEventHandler 委托要求两个参数:一个是对引发事件的对象的引用,另一个是EventArgs 对象,它包含关于事件的额外信息：
public delegate void RoutedEventhandler(object sender,RoutedEventArgs e);
Button类的定义如下
public class ButtonBase: ...
{
	public event RoutedEventHandler Click;
	...
}
public class Button:ButtonBase
{
	...
}
单机按钮,Button类将引发Click 事件。这样就可以非常简单地为选择的方法创建委托,并将委托和想要的事件关联。下例展示了一个UWP窗体,其中包含名为 okay的按钮。
按钮的 Click 事件与okayClick方法关联：
partial class MainPage:
	global::Windows.UI.Xaml.Controls.Page,
	global::kindows.UI.Xaml.Markup.IComponentConnector,
	global:Mindows.UI.Xaml.Markup.IComponentConnector2
	{
		...
		public vold Connect(int connectionId, object target)
		{
			switch(connectionId)
			{
				case 1:
				{
					this.okay (global:Mindows.UI.Xaml.Controls.Button)(target);
					...
					((global:Windows.UI.Xaml.Controls.Button)this.okay).Click+= this.okayClick;
					...
				}
				break;
				default;
				break;
				}
			this._contentLoaded = true;
		}
		...
	}
这些代码通常是隐藏起来的.在VisualStudio 2017中使用设计视图,并在窗体的XAML描述中将 okay按钮的Click属性设为 okayClick时,Visual Studio 2017会自动生成上述代码。开发人员唯一要做的就是在事件处理方法 okayClick中写自己的应用程序逻辑。本
例的 okayClick方法位于MainPage.xaml.cs 文件内部:
public sealed partial class MainPage:Page
{
	...
	prvate vwold okayClick(object sender,RoutedEventArgs args)
	{
		//在这里写处理Click事件的代码
	}
}
各种GUI控件生成的事件总是遵循相同的模式。事件是委托类型,签名包含void 返回类型和两个参数。第一个参数始终是事件的sender(来源),第二个参数始终是 EventArgs参数(或者EventArgs的派生类)。
可利用 sender参数为多个事件重用一个方法。被委托的方法可检查sender 参数值,并相应采取行动。例如,可指示同一个方法订阅两个按钮的Click事件(为两个事件添加同一个方法)。事件引发时,方法中的代码可检查sender参数,判断单击的到底是哪个按钮。

使用事件
上个练习修订了Wide World Importers应用程序,将审计发货逻辑从结账过程解耦。eckoutController类用委托调用审计发货组件,它并不了解这些组件或者它运行的方法;这些是创建CheckoutController对象和添加委托引用的应用程序的职责。但组件还
是有必要在完成处理后通知应用程序,使应用程序有机会执行必要的整理工作。有人会产生疑惑,应用程序调用CheckoutController 对象中的委托时,委托所引用的方法会运行,难道只有当这些方法结束后,应用程序才能继续?实情并非如此!方法可以异步运行。调用方法后可立即从下一个语句继续,而此时方法并未结束。UWP应用更是如此,长时间运行的操作可以在后台线程中执行,使UI一直保持灵敏响应的状态。在Wide World Importers应用程序的CheckoutButtonClicked方法中,调用委托后是立即显示对话框,告诉用户已下单。
private void CheckoutButtonClicked(object sender,RoutedEventArgs e)
{
	try
	{
		//执行结账过程
		this.checkoutController.StartCheckoutProcessing(this.order);

		//显示订单汇总
		MessageDialog dlg= new MessageDialog(...);
		dlg.ShowAsync();
		...
	}
	...
}
事实上,对话框显示时并不保证委托的方法已执行完毕。所以消息多少有一些误导人。
这正是事件可以发挥作用的时候。Auditor和Shipper组件都可发布由应用程序订阅的事件。只有在组件完成处理时才引发该事件。应用程序只有在接收到事件时才显示消息,从而确保了消息的准确性。为Checkoutcontroller类添加事件
1.返回Visual Studio2017并显示 Delegates解决方案。
2．在AuditService项目中打开Auditor.cs文件。
3.在 Auditor类中添加名为AuditingCompleteDelegate的公共委托。该委托指定的方法要获取名为message的字符串参数,返回 void.委托定义如加粗代码所示:
class Auditor
{
	public delegate vold Aud生tingCompleteDelegate(string message);
	...
}
4.在 Auditor 类中,在 AuditingCompleteDelegate 委托之后添加公共事件AuditProcessingComplete。该事件基于 AuditingCompleteDelegate委托,如加粗代码所示:
{
	public delegate void AuditingCompleteDelegate(string message);
	public event AuditingCorpleteDelegate AuditProcessingComplete;
}
5.找到 AuditOrder 方法。该方法由CheckoutController对象中的委托运行。它调用另一个名为doAuditing 的私有方法来执行审计操作。如下所示:
{
	public void AuditOrder(Order order)
	{
		this.doAuditing(order);
	}
}
6.向下滚动到 doAuditing方法。方法的代码封闭在try/catch块中;它使用.NET Framework类库的XMLAPI来生成被审计订单的XML形式,并保存到文件中。
在catch块之后添加finally块来引发AuditProcessingComplete事件,如加粗的代码所示:
private async void doAuditing(Order order)
{
	List<OrderItem) ageRestrictedItems= findAgeRestricteditems(order);
	if(ageRestrictedItems.Count >0)
	{
		try
		{
			...
		}
		catch(Exception ex)
		{
			...
		}
		finally
		{
			if(this.AuditProcessingComplete != null)
			{
				this.uditProcessingComplete(
					$"Audit record written for Order{order.OrderID)");
			}
		}
	}
}
7.打开 DeliveryService项目中的 Shipper.cs 文件。
8.为Shipper类添加公共委托 ShippingCompleteDelegate。该委托指定的方法获取名为message的字符串参数,返回 void。委托定义如加粗代码所示:
class Shipper
{
	public delegate void ShippingCompleteDelegate(string message);
	...
}
9.在 Shipper 类中添加名为 ShipProcessingComplete 的公共事件。该事件基于ShippingCompleteDelegate 委托,如加粗代码所示:
class Shippe
{
	public delegate void ShippingCompleteDelegate(string message);
	public event ShippingCompleteDelegate ShipProcessingComplete;
	...
}
10.找到 doShipping方法。该方法执行发货逻辑。在 catch块后添加finally块引发 ShipProcessingComplete 事件,如加粗代码所示:
private async void doShipping(Order order)
{
	try
	{
		...
	}
	catch(Exception ex)
	{
		...
	}
	finally
	{
		if this.ShipProcessingComple !=null)
		{
			this.ShipProcessComplete(
			$"Dispatch note generate for Order {order.OrderID}");

		}
	}

}
11.在Delegates 项目中用设计视图显示MainPage.xaml文件。在XAML窗格中向下滚动到第一组RowDefinition 项。XAML代码如下所示:
<Grid Background="(StaticResource ApplicationPageBackgroundThemeBrush)">
	<Grid Margin="12,e,12,e"Loadedm"MainPageLoaded">
		<Grid.RowDefinitions>
		<RoMOefinition Heighta"*"/》
			<RoMDefinition Height="2*/
			<RowDefinition Height="*"/>
			<RomOefinition Heighta"10"/>
			<RoMDefinition Height="*"/>
		</Grid.RoOefinitions>
		...
12.最后一个RoMDefinition 项的 Height属性更改为2*,如加粗的代码所示:
	<Grid.RoMDefinitions>
		...
		<RoDefinition Height="10*/>
		<RoMDefinition Heighta"2*"/>
	</Grid.RomDefinitions>
	这个布局修改是为了在窗体底部腾出一点空间,以便在Auditor 和 Shipper 组件引发事件时接收消息。
13.滚动到XAML窗格底部。在倒数第二个</Grid标记前添加以下加粗的ScrollViewer和TextBlock 元素:
		...
		</Grid>
			<ScrollViewer.Grid.Row="4" VerticalScrollBarVisiblity="Visible">
				<TextBlock x:Name="messageBar"FontSize="18"/>
			</ScrollVeer>
		</Grid>
	</Grid>
</Page>
该标记在屏幕底部添加名为messageBar的TextBlock 控件。将用它显示来自Auditor和 Shipper对象的消具。
14. 打开MainPage.xaml.cs 文件。找到 CheckoutButtonClicked 方法,删除显示订身汇总的代码。完成后的 try块如下所示:
private void CheckoutButtonClicked(object sender,RoutedEventArgs e)
{
	try
	{
		//执行结账过程
 		this.checkoutcontroller.StartCheckoutProcessing(this.order);

 		//清除订单细节,使用户能用新订单重新开始
 		this.order = new Order{Date = DateTime.Now,Items= new List<OrderItem>(),
 									  OrderID Guld.NewGuid(),Totalvalue =0};
 		this.orderDetails.DataContext = null;
		this,ordervalue.Text = $"{order. Totalvalue:C}"); 
		this.listViewHeader.Visibility = Visibility.Collapsed; 
		this.checkout.IsEnabled = false;
	}
	catch(Exception ex)
	{
		...
	}
}
15.在MainPage类中添加名为displayessage的私有方法。该方法获取名为message的符串参数,返回void.在方法主体中添加语句将message参数值附加到TextBlock 控件 messageBar的Text属性上,后跟换行符:
private vold displayessage(string message)
{
	this.messageBar.Text a $"(message}{Enviroment.NeMine)"j
}
上述代码在窗体底部的消息区域显示消息。

16.找到 MainPage类的构造器,添加以下加粗的代码:
public MainPage()
{
	...
	this.auditor = new Auditor();
	this.shipper= new Shipper();
	this.checkoutController = new Checkoutcontroller();
	this.checkoutCcontroller.CheckoutProcessing += this.auditor.Auditorder; this.checkoutController.CheckoutProcessing += this.shipper.ShipOrder;
	this.auditor.AuditProcessingComplete += this.displayessage; this.shiper. this.ShipProcessingComplete += this.displayMessage;
}
这些语句订阅由 Auditor和 Shipper 对象公开的事件。事件发生时将运行dsplayessage方法。注意,两个事件共用一个方法来处理。
17.在"调试"菜单中选择"开始调试",生成并运行应用程序。
18.Wide World Importers 窗体出现后,选择一些商品(至少选择一件限制年龄的),单击Checkout。
19.验证窗体底部的TextBlock中显示了"Audit record written"消息,后跟一条"Dispatch note generated"消息,
20.多下几单,注意,每次单击Checkout都显示新消息(消息区域满了之后,可能要向下滚动才能看到新消息)。
21.结束后返回Visual Studio2017并停止调试。

使用查询表达式来查询内存中的数据
定义LINQ查询来检查可枚举集合的内客
使用LINQ扩展方法和查询操作符
理解LINQ如何推迟查询的求值,以及如何强迫立即执行LINQ查询并缓存结果

目前为止,你已学习了C#语言的大多数功能。但语言有一个重要功能是许多应用程序都要使用的,即对数据进行查询的功能。以前说过,可定义结构和类对数据进行建模,可用集合和数组将数据临时存储到内存中。但是,如何执行一些通用的任务,例如在集合中搜索与特定条件匹配的数据项?例如,假定有一个容纳Customer(客户)对象的集合,如何找出位于伦敦的所有客户,或者如何找出客户数量最多的城市?当然,可以自己写代码来遍历集合,检查每个Customer对象中的字段。但是,由于这种形式的任务经常都要执行,所以C#的设计者决定包含一些功能来减少编码量。即如何使用这些高级C#语言功能来查询和处理数据。
什么是LINQ
除了最简单的应用程序,几乎所有应用程序都需要处理数据!历史上,大多数应用程序都是提供自己的逻辑来执行这些操作。但这个设计会造成应用程序中的代码与它要处理的数据紧密"耦合",因为一旦数据结构发生变化,就可能需要大幅修改代码才能适应变化。Microsoft.NETFramework的设计者对程序员的苦恼感同身受。经过长时间的慎重考虑,他们最终提供了一个功能,对从应用程序代码中查询数据的机制进行了"抽象"。该功能称为"语言集成查询"(Language IntegratedQuery,LINQ)。
LINQ的设计者大量借鉴了关系数据库管理系统（(例如 Microsoft SQL.Server)的处理方式,将"数据库查询语言"和"数据在数据库中的内部格式"分开。为了访间SQLServer数据库,程序员需向数据库管理系统发送SOL语句。SQL提供了对想要获取的数据的一个高级描述,但并没有明确指出数据库管理系统应如何获取这些数据。这些细节由数据库管理系统自身控制。所以,调用SOL语句的应用程序不必关心数据库管理系统如何物理性地存储或检索数据,如数据库管理系统使用的格式发生变化(例如,当新版本发布的时候),应用程序的开发者不需要修改应用程序使用的SQL语句。

LINQ的语法和语义和SQL很像,具有许多相同的优势。要查询的数据的内部结构发生改变后,不必修改查询代码。注意,虽然LINQ和SQL看起来很像,但LINQ更灵活,而且能处理范围更大的逻辑数据结构。例如,LINQ能处理以层次化的方式组织的数据(如 XML文档中的数据）。然而,这里将重点放在如何以"关系式"的方式使用LINQ。
在C#应用程序中使用LINQ
为了解释如何利用C#对LINQ的支持,最简单的办法就是拿一系列简单的例子来"说事儿"。下面这些例子基于以下客户和地址信息。
								客户信息
			CustmerlD 	 	FirstName 		LastName 		CompanyName
			1				Kim 			Abercromble 	Alpine Ski House
			2				Jeff 			Hay  			Coho Winery
			3				Charlie 		Herb Alpine 	Ski House
			4				Chris 			Preston 		Trey Research
			5				Dave 			Barnett 		Wingtip Toys
			6				Ann 			Beebe 			Coho Winery
			7				John 			Kane			Wingtip Toys		
			8				David			Simpson			Trey Research
			9				Greg    		Chapman			Wingtip Toys
			10				Tim   			Litton   		Wide World Importers
							地址信息
			CompanyName 			City 				Country
		Alpine Ski House 			Berne 				Switzerland
 		Coho Winery 				San Francisco 		United States
		Trey Research 				New York 			United States
		Wingtip Toys 				London 				United Kingdon
		Wide World Importers        Tetbury 			United Kingdom
LINQ要求数据用实现了IEnumerable 或 IEnumerable<T>接口的数据结构进行存储。具体什么数据结构不重要。可选择数组、HashSet<T>、 Queue<T>或其他任何集合类型(甚至可自己定义)。唯一要求就是这种类型"可枚举"。但 为了方便讨论,假定客户和地址信息存储在如下例所示的customers和addresses数组中。
注意 真正的应用程序应使用从文件或数据库获取的数据填充数组。
var customers = new[]{
new { CustomerID = 1, FirsWaae = Kim", LastName = "Abercrombie",
	  CompanyName = "Alpine Ski House" },
new { CustomerID = 2, FirstNane = "Jeff", LastName = "Hay",
	  CoapanyNaae = "Coho Winery" },
new { CustomerID = 3, FirstNam = "Charlie", LastName = "Herb",
	  CompanyMane = "Alpine Ski House" },
new { CustcnerID = 4, FirstName = "Chris", LastName = "Preston",
	  CompanyName = "Trey Research" },
new { CustoerID = 5, FirstName = "Dave", LastName = "Barnett",
	  ConpanyName = "Wingtip Toys" },
new { CustcnerID = 6, FirstName = "Arm", LastName = "Beebe",
	  CoapanyName = "Coho Winery" },
new { CustomerID = 7, FirstName = "John", LastName = "Kane",
	  CompanyName = "Wingtip Toys" },
new ( CustoaerID = 8, FirstHaae = "David", LastNaae = "Siapson",
	  CompanyName = "Trey Research" },
new { CustcmerID = 9, FirstName - "Greg", LastName = "Chapman",
	  CompanyName = "Wingtip Toys" ),
mm { CustomerID = 10, FirstNaw = LastNam , "Litton",
	  Companyttame = "Wide World laporters" }
}；
var addresses = new[] {
new ( CompanyName = "Alpine Ski House", City = "Berne",
	  Country = "Switzerland"},
new { CoMpanyNaw = "Coho Winery", City = "San Francisco",
	  Country = "United States"},
new { CompanyName = "Trey Research", City = "New York",
	  Country = "United States"},
new { CompanyName = "Wingtip Toys", City = "London",
	  Country = "Urdted Kingdom"),
new { CompanyName = "Wide World importers", City = "Tetbury",
	  Country = "United Kingdom"}
}；
选择数据
以下代码显示由customers数组中每个客户的名字(FirstName)组成的列表:
IEnumerable<string> custonerFirstames= custoner.Slect(cust => cust.FirstName);
foreach (string name in customerFirstNames)
{
	Console.WriteLine(name);
}
代码虽然很短,但实际做了大量事情,需要详细解释一番。先看看为customers 数组 调用 Select方法时发生的事情。
Select方法允许从数组获取特定信息,本例就是获取每个数组元素的FirstName字段值。它具体如何工作?传给Select方法的参数实际是另一个方法,后者从customers数组获取一行,并返回从那一行选择的数据。可用自定义的方法执行该任务,但最简单的 机制还是用Lambda表达式定义匿名方法,就像上例展示的那样。目前注意三个重点。
cust变量是传给方法的参数。可认为cust是customers数组每一行的别名。由 于是为customers数组调用 Select方法(customers.Select(...)),所以编译器 能推断出这一点。可用任何有效的C#标识符代替cust。
Select方法目前还没有开始获取数据;相反,它只是返回一个"可枚举"对象。 稍后遍历(枚举）它时,才会真正获取由 Select方法指定的数据。
Select其实不是Array类型的方法。它是Enumerable类的扩展方法,Enumerable类位于 System.Linq 命名空间,它提供了大量静态方法来查询实现了泛型IEnumerable<T>接口的对象。
上例为customers 数组使用Select 方法来生成名为 customerFirstNames的IEnumerable<string>对象。(类型之所以是IEnumerable<string>,是因为 Select方法 返回客户名字的可枚举集合,这些名字是字符串。)foreach语句遍历字符串集合,按以下顺序打印每个客户的名字。
Kim
Jeff
Chris Dave Anon
John
David
Greg 
Tim
现在能显示客户名字。但如何同时获取每个客户的名字(FirstName)和姓氏(LastName)
呢?这要稍微麻烦一些。在文档中检查 System.Linq 命名空间中的Enumerable.Select
方法定义:
public static IEnumerable<TResult> Select<TSource,TResult>(
				this IEnumerable<TSource> source,
				Func<TSource,TResult>selector
)
这表明Select是泛型方法,要获取TSource和TResult 这两个类型参数。还要获取两个普通参数source和selector。其中,TSource是要为其生成可枚举结果集的集合(本例是customer对象)的类型,TResult是可枚举结果集中的数据(本例是string对象)的
类型。记住,Select是扩展方法,所以source参数是对要扩展的类型的一个引用(在本例中,要扩展的是由customer对象构成的泛型集合,该集合实现了IEnumerable 接口)。
selector参数指定一个泛型方法来标识要获取的字段(Func是.NETFramework采用的泛型委托类型名称,用于封装要返回结果的泛型方法,即函数)。selector 参数所引用的方法要获取一个TSource(本例是 customer)参数,并生成一个TResult(本例是 string)对象。
Select方法返回由TResult(同样是string)对象构成的可枚举集合。说了这么多,重点仅一个:Select方法返回基于某具体类型的叫枚举集合。如希望枚举器返回多个数据项,例如返回每个客户的名字和姓氏,至少有以下两个方案可供采纳。
在Select方法中将名字和姓氏连接成单个字符串。例如:
IEnumerable<string>customerNames =
Customers. Select(cust s>$"(Cust.Firstame} {cust.Lastame)");
定义新类型来封装名字和姓氏,并用Select方法构造该类型的实例。例如:
class FullName
{
	public string FirstName{get;set;}
	public string LastName{get;set;}
}
...	
IEnumerable<FullName> customerFulNames =customers. Select(cust => new FullName
	{
		FirstName= cust.FirstName,
		LastName = Cust.LastName
	});
第二个选项本该首选。但如果 FullName 类型的作用仅限于此,就可考虑使用匿名类型,而不是专门为一个操作定义新类型。下面是使用匿名类型的例子:
var customerfullNames =
	customers. Select(cust =>new
	{
		FirstName = cust.FirstName,
		LastName = cust.LastName
	});
注意,这里用var关键字定义可枚举集合的类型。集合中的对象类型是匿名的,所以不知道集合中的对象的具体类型。筛选数据Select方法允许"指定"(更专业的术语是"投射"或project)想包含到可枚举集合中的字段。但有时希望对可枚举集合中包含的行进行限制。例如,为了列出address数组中地址在美国的所有公司的名称,可以像下面这样使用where方法:
IEnumerable<string>usCompanies = addresse.Where(addr => String.Equals(addr.Country,"United States")).Select(usComp=> usComp.Company);
foreach(string name in usCompanies)
{
	Console.ariteLine(name);
}
Where方法的语法类似于Select方法。它的参数定义了一个方法,该方法可根据指定条件对数据进行筛选。这里又用到了一个Lambda表达式。addr变量是addresses 数组中行的别名,Lambda表达式返回Country字段同字符串"United States"匹配的所有行。where方法返回符合条件的行的一个可枚举集合,这些行包含原始集合的所有字段。然后,Select方法应用于这些行,只从可枚举集合中投射出CompanyName字段,返回由字符串对象构成的另一个可枚举集合。(usComp 变量是 where方法返回的可枚举集合的每一行的别名。)因此,整个表达式的最终结果的类型应该是IEnumerable<string>。必须正确理解方法的应用顺序——先应用where方法,筛选出符合条件的行;再应用Select方法,从而指
定(或者说投射)其中特定的字段。遍历这个集合的foreach语句,显示以下公司名称:
Coho Winery
They Research

排序、分组和聚合数据
如熟悉SQL,就知道 SQL除了简单的投射和筛选,还允许执行大量关系式操作。例如,可指定数据以特定顺序返回,可根据一个或多个键字段对返回的行分组,还可根据每个组中的行来计算汇总值。LINQ提供了相同的功能。
按特定顺序获取数据要使用OrderBy方法。与 Select和where 方法相似,OrderBy也要求以一个方法作为实参。该方法标识了对数据进行排序的表达式。例如,以下代码以升序显示 addresses数组中每家公司的名称:
IEnumerable<string>corpanyames = addresses.Orderby(addr a>addr.CompanyName).Select(comp =>comp.CompanyName);
foreach（string name in companylames)
{
	ConConsole.writeLine(name);
}
以上代码按字母顺序显示地址表中的公司名称:
Alpine Sk House 
Coho winery 
Trey Research
Mide world Importers
wingtip Toys
降序枚举数据可换用OrderByDescending方法。要按多个键来排序,可以在OrderBy或OrderByDescending之后使用ThenBy 或 ThenByDescending方法。
要按一个或多个字段中共同的值对数据进行分组,可以使用GroupBy方法。下例展示了如何按国家对addresses数组中的公司进行分组:
var companiesGroupedByCountry = addresses.GroupBy(addrs => addrs.Country);
foreach（var companiesPerCountry in companiesroupedByCountry)
{
	Console.MriteLine($"Country:{companiesPerCountry.Key}t(companiesPerCountry.Count())companies");

	foreach (var companies in companiesPerCountry)
	{
		Console. WiriteLine($"\t(companies.Companyane}");
	}
}
现在应该能看出一些端倪了。GroupBy方法要求其参数是一个方法,该方法指定了作为分组依据的字段。但GroupBy 方法和前面讲过的其他方法有一些细微区别。
最主要的就是不需要用 Select方法将字段投射到结果。GroupBy返回的可枚举集合包含来源集合中的所有字段,只是所有行都依据"GroupBy 指定的方法所标识的字段"进行分组,每个"组"本身也是可枚举集合。换言之,GroupBy 方法的结果是由一系列"组"构成的可枚举集合,而每个"组"都是由一系列行构成的可枚举集合。在上例中,可枚举集合companiesGroupedByCountry是国家的集合。集合中的每个数据项本身也是可枚举集合,其中包含每个国家的公司。为了显示每个国家的公司,代码用 foreach 循环遍历companiesGroupedByCountry 集合,从而生成(yield)并显示每个国家,再用一个嵌套foreach循环遍历每个国家的公司集合。注意在外层foreach循环中,可以使用每个数据项的Key字段访问作为分组依据的值,还可使用一些方法(例如Count、Max和Min等)计算每个"组"的汇总数据。上例的输出如下:
Country:SMitzerland 1 companies
	Alpine Ski House
Country:United States 2 companies
	Coho winery
CounTry:United Kingdom 2 companies 
	Wingtip Toys
	Wide world Importers
可直接为 Select方法的结果使用许多汇总方法,例如Count,Max和Min等。例如,为了知道 addresses 数组中有多少家公司,可以使用如下所示的代码:
int numberOfCompanies = addresses.Select(addr =>addr.CompanyName).Count();
Console.MriteLine($"Mmber of companies:(numberOfCompanies)");
注意这些方法返回一个标量值而非可枚举集合。上述代码的输出如下:
number of companies:5
注意,对于要投射的字段,如多个行的该字段包含相同的值,这些汇总方法是不会进行区分的。这意味着严格意义上讲,上例显示的只是addresses数组中有多少行的CompanyName字段包含了一个值。为查询表中出现了多少个不同的国家,很容易写出下面这样的代码:
int numberOfCountries addresses.Select(addr =>addr.Country).Count();
Console.MriteLine($"Mumber of countries:{numberOfCountries)");
输出如下:
Number of countries:5
但事实上 addresses 数组中总共只出现了三个不同的国家。之所以结果是5,是由于United States和United Kingdom 都出现了两次。可用Distinct方法删除重复,如下所示:
int numberOfDistinctCountries = addresses.Select(addr=>addr.Country).Distinct().Count();
Console.writeLine($"Nmber of distinct countries:{numberOfDistinctCountries)");
现在 Console.MriteLine 语句能输出符合要求的结果了:
Number of distinct countrles:3

联接数据
和SQL一样,LINQ也允许根据一个或多个匹配键(common key)字段来联接join)多个数据集。下例展示了如何显示每个客户的名字和姓氏,同时显示其所在国家名称:
var companiesAndCustoners = customers.Select(C=> new{C.FirstName,C.LastName,C.CompanyName}).Join( addresses,
custs => custs.CompanyName,
 addrs >addrs.Companyame,
(custs,addrs)s=> new(custs.FirstName,custs.LastName,addrs.Country });
foreach(var row in companiesAndCustomer)
{
	Console.Mriteline(row);
}
客户名字和姓氏存储在 customers 数组中,但其公司所在国家存储在addresses 数组中。customers 和 addresses 这两个数组的匹配键是公司名(CompanyName)。上述 Select方法指定customers 数组中你感兴趣的字段(FIrstName和LastName),还指定了作为匹配键使用的字段（Companyame)。然后,使用Join方法将Select方法标识的数据同另一个可枚举集合联接起来。Join方法的参数如下所示。
要联接的目标可枚举集合。
一个对 Select方法标识的数据中的匹配键字段进行了标识的方法。
一个对目标集合中的匹配键字段进行了标识的方法。
一个对Join方法返回的结果集中的列进行了标识的方法。
本例的 Join 方法将一个可枚举集合(其中包含来自customers 数组的FirstName,LastName 和CompanyName 字段)同addresses数组中的行联接起来。联接依据就是customers数组的Companyame字段值与address数组中的CompanyName 字段值匹配.结果集合包含 customers 数组的FirstName和LastName字段,以及 addresses 数组的
Country字段。用foreach遍历companiesAndCustomers 集合将显示以下信息:
{FirstNlame= Kia,Lastlame = Abercroabile,Country = SMdtzerland}
{FirstName = Jeff,LastName = Hay,Country United States}
{FirstNme = Charle,Lastame = Herb,Country= SMitzerland}
{FirstNhame - Chris,LastName = Preston,country = United States }
{FirstName = Dave,LastName = Barnett,Country uhited Kingdom }
{Firstame = Ann,LastNlame = Beebe,Country = United States}
{FirstName = John,LastName = Kane,Country = United Kingiom}
(Firstame = David,LastName = Simpson,Country = Uhited States }
{FirstName = Greg,LastName = Chapman,Country = United Kingdom}
{FirstNMame Tim,LastName = Litton,Country = United Kingdom}
注意 内存中的集合和关系式数据库的"表"不同,它们包含的数据也不具有相同据完整性约来.在关系式数据库中,可假定每个客户都有一家对应的公司,而且每家公司都有独一无二的地址,但集合并不强制同级的数据完整性,所以可以轻
易地让一个客户引用addresses数组中不存在的公司,甚至可以让同一家公司在address数组中多次出现。在这些情况下,获得的结果虽然是准确的,但可能并不是你希望的.只有充分理解了要联接的数据之间的关系之后,Join操作才能发挥出最大作用。

使用查询操作符
前面展示了如何使用 System.Linq命名空间中的Enumerable类的扩展方法查询内存中的数据。语法利用了好几个高级的C#语言功能,这样产生的代码显得难以理解和维护。
为减轻开发人员的负担,C#的设计者为语言添加了一系列查询操作符,允许开发人员使用与SQL更相似的语法使用LINQ功能。
之前的例子是像下面这样获取每个客户的名字(FirstName):
IEumerable<string> customerfirstNaes = customers
.Select(cust a>cust.FirstName;
可用查询操作符 from和select 改写上述语句使之更容易理解:
Var customerFirstNames = from cust in customers
						select cust.FLrstName;
编译时,C#编译器将上述表达式解析成对应的Select方法。from操作符为来源集合定义别名,select操作符利用该别名指定要获取的字段。结果是一个可枚举集合,其中包含客户的名字。如果你熟悉SQL,注意这里的from操作符出现在select 操作符之前。
类似地,为同时获取每个客户的名字和姓氏,可以使用以下语句。(请和前面用Select扩展方法实现的版本比较。）
var customerNames = from c in customers select new {cC.FirstName,C.LastName };
筛选数据用where操作符,下例从 address 数组返回在美国的公司:
var usCompaniesfrom =  in addresses
						where String.Equals(a.Country,"hnited States")
						select a.CompanyName;
数据排序用 orderby操作符,如下所示:
var companyNames = from a in addresses
 				   orderby a. Companytame
				   select a.CompanyName;
数据分组用group 操作符:
var companiesGroupedByCountry=from a in addresses
							  group a by a.Country;
注意,和前面用GroupBy 方法对数据进行分组的例子一样,这里不需要提供 select
操作符,而且可以使用和以前一样的代码遍历结果；
foreach (var companiesPerCountry in companiesGroupedByCountry)
{
	Console.hriteLine($"Country:{companiesPerCountry.Key}\t{companiesPerCountry.Count()}compandes"};
	foreach(var companies in companiesPerCountry)
	{
		Console.writeLine($""\t(companies.CompanyName}");
	}
}
可为返回的可枚举集合调用各种汇总函数,例如 Count方法:
int numberOfCompanies = (from a in addresses select a.CompanyName).Count();
提示 许多时候只是想统计集合中的行数,而不是字段值在集合的所有行中的数量,i时可直接为原始集合调用
Count:int numberOFCompanies = addresses.Count();
join操作符根据一个匹配键来联接两个集合。下例根据每个集合都有的CompanyName列来联接两个集合,并返回客户姓名和地址。注意要用on子句和 equals操作符指定两个集合如何关联。
注意  LINQ目前只支持同等联接,即equi-joins,或者说基于相等性的联接。熟悉SQL的数据库开发人员可能熟悉基于其他操作符(比如>和<)的联接,但LINQ不支持。
var citiesAndCustomers = from a in addresses
						 join customers
						 on a.Companyame equals c.CompanyName
					     select new(c.FirstName,C.LastName};
注意 和SQL相反,在LINQ表达式的 on子句中,表达式的顺序是重要的,equals操作符左边必须是来源集合中的匹配键（引用由from子句指定的集合中的数据),右边必须是目标集合中的匹配键(引用由join子句指定的集合中的数据)。
LINQ还提供了其他许多方法对数据进行汇总、联接、分组和搜索。例如,利用LINQ提供的Intersect和 Union方法可以执行集合(set)运算。另外还提供了像Any和All这样的方法,可用它们判断集合中是否至少有一项或所有项与指
定条件(谓词)匹配。可用Take和Skip方法对可枚举集合中的值进行分区。

查询Tree<TItem>对象中的数据
目前的例子都只是演示如何查询数组中的数据。同样的技术适合任何实现了泛型IEnumerable<T>接口的集合类。以下练习将定义一个新类对某公司的员工进行建模。将创建一个BinaryTree对象,其中包含Employee对象的一个集合。然后使用LINQ查询信息。最开始直接调用LINQ扩展方法,然后修改代码,使用更简便的查询操作符。
使用扩展方法从 BinaryTree获取数据
1.如果 VisualStudio 2017尚未启动,请启动。
2. 打开QueryBinaryTree 解决方案,它位于"文档"文件夹下的MicrosoftPress\VCSBS\Chapter21\QueryBinaryTree子文件夹。项目包含 Program.cs文件,其中定义了Program类以及Main和 dOhork方法,和以前的练习一样。
3.在解决方案资源管理器中右击QueryBinaryTee项目并选择"添加"| "类"。在"添加新项"对话框的"名称"框中输入Employee.cs,单击"添加"。
4.在 Employee类中添加以下加粗的自动属性:
class Employee
{
	public string FirstName{get;set;}
	public string LastName{get; set;} 
	public string Department{get;set;} 
	public int Id{get;set;）
}
5.将以下加粗的ToString方法添加到Employee类。.NET Framework的类将对象转换成字符串时会用到该方法,例如,在使用Console.writeLine方法显示的时候:
class Employe
{
	...
	public override string ToString()=>
	$Id:{this.Id},Name:{this.Firstame}{this. Lastame},Dept:{this.Department}";
}
6.修改Employee类定义来实现IComparable<Employee>接口,如加粗部分所示:
class Employee:IComparable<Employee>
{
	...
}
这个步骤是必要的,因为BinaryTree类规定它的元素必须"可比较"。
7.鼠标移至类定义的IComparable<Employee>接口上方,单击灯泡图标并选择"显式实现接口"。这个操作会生成CompareTo方法的默认实现。记住,BinaryTree类将元素插入树时需调用该方法比较元素。
8.将 CompareTo方法的主体替换成以下加粗的代码。在CompareTo方法的这个实现中,将根据 Id字段的值比较 Employee对象。
int IComparable<Employee>.compareTo(Employee other)
{
	if(other == null)
	{
		return 1;
	}
	if(this.Id>other.Id)
	{
		return 1;
	}
	if(this.Id< other.Id)
	{
		return -1;
	}
	return 0;
}
注意 如果忘记了IComparable<T>接口的知识。
9.在解决方案资源管理器中右击QueryBinaryTree 解决方案并选择"添加"I"现有项目"。在"添加现有项目"对话框中切换到"文档"文件夹下的 MicrosoftPressVCSBS\Chapter 21\BinaryTree子文件夹,选定 BinaryTree 项目,单击"打开"。BinaryTree 项目包含在前面实现的可枚举 BinaryTree类的一个副本。
10.在解决方案资源管理器中右击QueryBinaryTree 项目并选择"添加"|"引用"。在"引用管理器"对话框左侧窗格展开"项目",单击"解决方案",在中间窗格勾选BinaryTree 项目,单击"确定"。
11.在"代码和文本编辑器"中打开QueryBinaryTree项目的Program.cs 文件,验证文件顶部包含以下 using指令:
using System.Linq
12．在Program.cs 文件顶部添加以下 using 指令:
using BinaryTree;
13.在Program类的doWork方法中删除//TOD0:注释并添加以下加粗的语句,构造并填充 BinaryTree类的实例:
static vold doWork()
{
	Tree<Employee> empTree = new Tree<Employee>(new Employee{
	Id = 1,FirstName="Kim,Lastlame="Abercromble",Department ="IT"});
	empTree.Insert(new Employee{
	Id = 2,FirstName = "Jeff",LastName = "Hay",Department ="Narketing"});
	empTree.Insert(new Employee {
	Id = 4,FirstName = "Charlie",LastName a "Herb",Department ="IT"});
	empTree.Insert(new Employee { 
	Id =6, FirstName "Chris",LastName = "Preston",Department="Sales"});
	empTree.Insert(new Erployee{
	Id 3,FirstName ="Dave",LastName "Bamnett",Department= "Sales"});
	empTree.Insert(new Employee{
	Id=5,FirstName ="Tim",LastName="Litton",Department="Marketing});
}
14.将以下加粗的语句添加到 doMork方法木尾。这些代码用 Select方法列出二叉树中发现的部门:
static void doWork()
{
	...
	Console.hriteLine("List of departments");
	var depts = empTree.Select(d =>d.Department);

	foreach(var dept in depts)
	{
		Console.swriteLine($"Department:(dept)");
	}
}
15.选择"调试"|"开始执行(不调试)"。
应用程序应输出以下部门列表:
List of departments
Department: IT
Department:Marketing
Department:Sales
Department:IT
Department:Market
Department:Sales
每个部门名称都出现两次,因为每个部门都有两名员工。部门顺序由Employee类CompareTo方法决定。该方法用每个员工的Id属性对数据进行排序。第一个部门是Id值为1的那个员工的部门,第二个部门是Id值为2的那个员工的部门,
以此类推。
16.按Enter键返回Visual Studio2017.。
17.在 Program 类的doWork 方法中修改创建可枚举部门集合的语句,如加粗的部分
所示:
var depts a empTree.Select(d =>d.Department).Distinct();
Distinct方法消除可枚举集合中重复的行。
18.选择"调试"|"开始执行(不调试)"。
验证重复部门名称已被消除,应用程序现在只显示每个部门一次:
List of departments
Department: IT
Department: Marketing
Department: Sales
19.按 Enter 键返回Visual Studio2017
20.在doWork方法末尾添加以下语句。这个代码块使用where方法筛选员工,只返回在IT部门的。Select方法返回整行,而非只投射特定的列。
static void dohaork()
{
	...
	Console.WriteLine();
	Console.WriteLine("Employees in the IT department");
	var ITEmployees =
				empTree. Mhere(e r> String.Equals(e.Department,"IT"))
				.Select(emp =>emp);
	foreach (var emp in ITEployees)
	{
		Console.WriteLine(emp);
	}
}
21.在domork方法末尾,在刚才添加的代码之后维续添加以下加粗的代码。这些代码使用GroupBy方法,按部门对二叉树中发现的员工进行分组。外层foreach语句遍历每个组,显示部门名称。内层foreach语句显示每个部门中的员工姓名。
static void doWork()
{
	...
	Console.MriteLine();
	Console.writeLine("All employees grouped by department");
	var employeesBlyoept a empTree.GroupBy(e =>e.Department);

	foreach(var dept in employeesBypept)
	{
		Console.writeLine($"Department:{dept.Key)");
		foreach(var emp in dept)
		{
			Console.writeline(s"\t(emp.FirstName)(emp.Lastlame)");
		}

	}
}
22.选择"调试" |"开始执行(不调试)"。验证应用程序的输出和下面一样:
List of departments
Department:IT
Department:Marketing
Department: Sales

Employees in the IT department
Id:1,Name:Kim Abercronbie,Dept:IT
Id:4,Name:Charlfe Herb,Dept:IT

All employees grouped by department 
Department:IT
	Kim Abercrombie
	Charlie Herb
Department:Marketing
	Jeff Hay
	Tim Litton
Department:Sales
	Dave Barnett
	Chris Preston
23.按 Enter键返回Visual Studio 2017.
使用查询操作符从 BinaryTree 获取数据
1.在doWork方法中,将生成部门可枚举集合的语句注释掉,替换成以下加粗的语句,
它是基于from和select查询操作符来写的:
//var depts = empTree.Select(d =>d.Department).Distinct();
var depts =(from d in empTree
			select d.Department).Distinct();
2 将生成IT员工可枚举集合的语句注释掉,替换成以下加粗的代码:
//	var ITEmployees=
//	empTree.Where(e => String.Equals(e.Department,"IT")
//	.Select(emp =>emp);
var TEmployees = from e in empTree
				where String,Equals(e.Department,"IT")
				select e;
3. 将按部门对员工进行分组的语句注释掉,替换成以下加粗的代码:
//	var employeesByDept empTree.GroupBy(e =>e.Department);
var employeesBypept = from e in empTree
					  groupe by e.Department;
4.选择"调试"|"开始执行(不调试)"。验证应用程序的输出和以前一样:
5.按 Enter键返回Visual Studio 2017。

LINQ和推迟求值
通过LINQ定义可枚举集合时,无论使用LINQ扩展方法还是查询操作符,都应记住当LINQ扩展方法执行时,应用程序并不真正构建集合:只有在遍历集合时才会对集合进行枚举。也就是说,从执行一个LINQ查询之后,到取回这个查询所标识的数据之前,原始集合中的数据可能发生改变,但最终获取的始终是最新数据。例如,以下查询(前面已演示过)定义了由美国公司构成的可枚举集合:
var usCompanies = from a in addresses
				  Where String.Equals(a.Country,"United States")
				  select a.CompanyName;
除非使用以下代码遍历 usCompanies 集合,否则addresses 数据中的数据不会获耶where筛选器指定的条件也不会求值:
foreach(string name in usCompanies)
{
	Console.wiriteLine(name);
}
从定义 usCompanies 集合到遍历该集合,在此期间如果修改了addresses 数组中的数据（例如添加了一家新的美国公司),就会看到新的数据。这个策略就是所谓的推迟求值。
可在定义LINQ查询时强制求值,从而生成一个静态的、缓存的集合。该集合是原始数据的拷贝。原始集合中的数据发生改变,该拷贝中的数据不会相应改变。LINQ提供了ToList方法来构建静态List对象以包含数据的缓存拷贝。如下所示:
var usCompandies=from = in addresses.ToList()
where String.Equals(a.Country,"United States" select a.CompanyName;
这次在定义查询时,公司列表就会固定下来。如果在 addresses 数组中添加了更多的美国公司,那么遍历 usCompanies 集合时不会获得这些新数据。LINQ还提供了ToArray方法将集合缓存到数组。

推迟和立即对LINQ查询进行求值,并比较结果
1.返回Visual Studio 2017,编辑QueryBinaryTree项目的Program.cs 文件。
2.doWork方法只保留构造 empTree二叉树的代码,其他代码都注释掉,如下所示:
static vold doWork()
{
	Tree<Employee> empTree = new Tree<Employee>(new Employee{
	Id = 1,FirstName="Kim,Lastlame="Abercromble",Department ="IT"});
	empTree.Insert(new Employee{
	Id = 2,FirstName = "Jeff",LastName = "Hay",Department ="Narketing"});
	empTree.Insert(new Employee {
	Id = 4,FirstName = "Charlie",LastName a "Herb",Department ="IT"});
	empTree.Insert(new Employee { 
	Id =6, FirstName "Chris",LastName = "Preston",Department="Sales"});
	empTree.Insert(new Erployee{
	Id 3,FirstName ="Dave",LastName "Bamnett",Department= "Sales"});
	empTree.Insert(new Employee{
	Id=5,FirstName ="Tim",LastName="Litton",Department="Marketing});

//方法其余部分都注释掉
...
}
提示 有一个简便的办法可以注释掉大段代码。只需在"代码和文本编辑器"中选定代码块,然后单击工具栏上的"注释选中行"按钮,或者按组合健Ctrl+E,C。
3. 将以下语句添加到doWork方法,在构造了empTree二叉树之后执行:
static void doWork()
{
	...
	Console.MriteLine("All employees");
	var allEmployees = from e in empTree select e;
	foreach(var emp in allEmployees)
	{
		Console.writeLine(emp);
	}
}
代码生成名为allEmployees 的可枚举员工集合,并遍历这个集合,显示每个员工的细节
4 在刚才输入的代码后添加以下代码:
static void doWork()
{
	...
	empTree.Insert(new Employee
	{
		Id = 7, 
		FirstName = "Davd",
		LastName ="Simpson",
		Department = "IT"
	});

	Console.MriteLine();
	Console.MriteLine("Employee added");

	Console. writeLine("All employees");
 	foreach(var emp in allEmployees)
 	{
 		Console.MriteLine(emp);
 	}
 	...
}
这些代码在empTree树中添加一名新员工并再次遍历allEmployees集合。
5、选择"调试"|"开始执行(不调试)"。验证程序输出和下面一致:
All employees
Id:1,Name:Kim Abercrombie,Dept:IT
Id:2,Name: Jeff Hay,Dept:Marketing
Id:3,Name:Dave Barnett,Dept:Sales
Id:4,Name:Charlie Herb,Dept:IT
Id:5,Name: Tim Litton,Dept:Marketing
Id:6,Name:Chris Preston, Dept:Sales
Employee added
All employees
Id:1,Namne:Kim Abercrombie,Dept:IT
Id:2,Name:JeffHay,Dept:Narketing
Id:3,Name:Dave Barnett,Dept: Sales
Id:4,NMame:Charlle Herb,Dept:IT
Id:5,Name: Tim Litton,Dept:NMarketing
Id:6,Name:Chris Preston,Dept: Sales
Id:7,Name:David Simpson, Dept:IT
注意，在第二次遍历allEmployees 集合时,列表中会包含新员工David Simpson——虽然该员工是在allEmployees 集合定义好之后才添加的。
6.按 Enter键返回Visual Studio 2017
7.在 doWork方法中修改生成 allEmployees 集合的语句,立即获取并缓存数据,如
加粗的代码所示:
var allEmployees = from e in empTree.ToList<Eamployee>()
				   select e;
LINQ提供了ToList 和ToArray方法的泛型和非泛型版本。应尽量使用泛型版本 以确保结果的类型安全性。select 操作符返回一个Employee对象,上述代码将
allEmployees作为一个泛型List<Employee>集合来生成。
8.选择"调试"|"开始执行(不调试)"。验证程序输出和下面一致:
All employees 
Id:1, Name:Kin Abercrombie,Dept:IT
Id:2,Name:Jeff Hay,Dept:Narketing 
Id:3,Name:Dave Barnett,Dept:Sales 
Id:4,Mame:Charlie Herb,Dept:IT 
Id:5,Name:TimLitton,Dept:Marketing 
Id:6,NMame:hris Preston,Dept:Sales

Employee adde All employees 、
Id:1,Name:Kim Abercrombie,Dept:IT
Id:2,Name: Jeff Hay,Dept:Narketing 
Id:3,Name:Dave Barnett,Dept:Sales 
Id:4,Name:Charlie Herb,Dept:IT 
Id:5,Name:Tim Litton,Dept:Marketing 
Id:6,NMame:Chris Preston,Dept: Sales
注意,应用程序第_次遍历 allEmployees 集合时,显示的列表中不包含 DavidSimpson.这是由于在David Simpson 添加到empTree树之前,查询就被求值完成,而且结果被缓存起来。
9.按 Enter键返回 Visual Studio2017.

操作符重载
为自己的类型实现二元操作符
为自己的类型实现一元操作符
为自己的类型编写递增和递减操作符
理解为什么需要成对实现某些操作符
为自己的类型实现隐式转换操作符
为自己的类型实现显式转换操作符

我们之前大量运用标准操作符符号(例如+和-)对类型(例如int 和double)执行标准操作(例如加和减)。许多内建类型都针对这些操作符提供了它们自己的、预先定义好的行为。
还可自己定义操作符之于结构和类的行为方式。
理解操作符
深入了解操作符的工作方式以及如何对它们进行重载之前,有必要复习一下操作符的一些基础知识。总结如下。
操作符将操作数合并成表达式。每个操作符都有自己的语义,具体取决于所操作的类型。例如,操作符+在操作数值类型时是"加",操作字符串时是"连接"。
每个操作符都有优先级。例如,操作符*具有比+更高的优先级。这意味着表达式a＋b*c等同于a ＋(b*c)
每个操作符还有结合性,定义了操作符是从左向右求值,还是从右向左求值。例如,操作符=具有右结合性(从右向左求值),所以a = b= c等同于a=（b=c)。
一元操作符只有一个操作数,例如递增操作符(++)。
二元操作符要求两个操作数,例如乘法操作符(")。
三元操作符…

操作符的限制
c#允许在定义自己的类型时重载方法。还可为自己的类型重载许多现有的操作符,虽然语法稍有区别。重载操作符时,你实现的操作符将自动归入一个良好定义的框架。但这个框架存在以下几点限制。
不能更改操作符的优先级和结合性。优先级和结合性以操作符的符号(例如+)为基础而不是以操作符应用的类型(例如int)为基础。所以,表达式a ＋b*c总是等同于a +(b*c),无论 a,b和c的类型是什么。
不能更改操作符的元数(操作数的数量）。例如,乘法操作符*是二元操作符。为自己的类型声明操作符*,它必然还是二元操作符。
不能发明新的操作符符号。例如,不能创建新的操作符符号**求乘方。这样的计算必须定义方法。
操作符应用于内建类型时,不能更改操作符的含义。例如,表达式1＋2有预定义的含义,该含义不允许被重写,否则会造成极大的混乱。
有的操作符不能重载。例如,不能重载点(.)操作符,它表示访问类成员,否则同样会造成极大的混乱。
提示 可用索引器将[]模拟成操作符。类似地,可用属性将=(赋值)模拟成操作符,还可使用委托将函数调用模拟成操作符。

重载的操作符
要自定义操作符的行为,必须重载该操作符。语法和方法相似,同样有返回类型和参
数。但方法名必须更换为关键字 operator和希望声明的操作符。例如,以下是一个名为
Hour的用户自定义结构,它定义了二元操作符+,用于将Hour的两个实例加到一起：
struct Hour
{
	public Hour(int initialValue) =>this.value initialValue;

	public static Hour operator +(Hour lhs,Hour mhs)=>new Hour(lhs.value ＋rhs.value);
	...
	private int value;
}
注意以下几点。
操作符是公共的。所有操作符都必须公共。
操作符是静态的。所有操作符都必须静态。操作符永远不具有多态性,不能使用virtual、abstract、override或sealed修饰符。
操作符(例如上述的+)有两个显式的参数;一元操作符有一个显式的参数(C++程序员注意,操作符永远没有一个隐藏的 this 参数)。
提示 声明为了方便写程序而开发的一个功能(例如操作符)时,有必要统一参数的命名规范.例如,开发者常为二元操作符使用lhs和phs参数(分别代表左右操作数,即left-handside和right-handsid对Hour类型的两个表达式使用+操作符,C#编译器自动将代码转换成对operator+方法的调用。例如,C#编译器将以下代码:
Hour Example(Hour a,Hour b)=>a＋ b;
转换成以下形式:
Hour Example(Hour a,Hour b) => Hour.operator +(a, b);//伪代码
但是注意,这个语法是伪代码,不能直接这样写。使用二元操作符时,只能采取标准的中缀记号法(符号放在两个操作数中间)。
声明操作符时,还有最后一个规则需遵守,否则代码无法成功编译。这个规则就是:至少有一个参数的类型必须是包容类型。换言之,在前面的operator+的例子中,至少有一个参数(a或b)必须是Hour类型。虽然本例两个参数都是Hour类型的对象,但有的时候可能想定义 operator+的其他实现。例如,你可能想允许一个整数(代表多少小时)加到一个Hour对象上。在这种情况下,第一个参数可以是Hour,第二个参数可以是整数。有了这个规则之后,编译器在解析操作符调用时,就能更轻松地找到重载版本。同时,还有效阻止了开发者更改内建操作符的含义。

创建对称操作符
前面讲述了如何声明二元操作符+,将两个Hour类型的实例"加"到一起。Hour结构还有一个构造器,能根据一个int来创建Hour。这意味着一个 Hour和一个int可以相加——只是必须先用Hour构造器将int转换成Hour。例如:
Hour a=...;
int b...;
Hour later = a + new Hour(b);
虽然代码本身有效,但相较于让一个Hour和一个int直接相加(如下所示),前面的写法既不明确,也不简洁：
Hour a =...;
int b=...;
Hour later= a ＋ b;
为了使表达式(a＋b)变得有效,必须指定当一个 Hour(左侧的a)和一个 int(右侧的b)相加时有什么含义。也就是说,必须声明一个二元操作符+,它的第一个参数是 Hour,
第二个参数是int。以下代码展示了推荐的做法:
struct Hour
{
	public Hour(int initialvalue)=> this.value = initialvalue;
	...
	public static Hour operator+(Hour lhs,Hour rhs) => new Hour(lhs.value + rhs.value);
	public static Hour operator +(Hour lhs,int rhs)=> lhs + new Hour(rhs);
	...
	private int value;
}
操作符的第二个版本唯一做的事情就是根据它的int参数来构造一个Hour,然后调用第一个版本。这样,操作符的真正逻辑就可以保持在单独一个位置。重点在于,额外的operator+只是让现有功能更易使用。还要注意,不应提供操作符的多个版本,让每个版本都支持不同的第二参数类型。也就是说,只需支持常见和有意义的情况,让类的用户自己采取额外的步骤来支持不寻常的情况。
该operator+只是声明了左操作数 Hour和右操作数int 如何相加,没有声明左int和右 Hour 如何相加:
int a =...; 
Hour b=...;
Hour later = a ＋b;//编译时错误
这里有悖直觉。用户会认为自己既然能写出像 a＋b这样的表达式,自然也能写b＋a。所以,还应对称地提供 operator +的另一个重载版本:
struct Hour
{
	public Hour(int initialValue) => this.Value = initialValue;
	...
	public static Hour operator +(Hour hs,int rhs)=>lhs +new Hour(rhs);
	public static Hour operator +(int lhs,Hour rhs)=>new Hour(lhs)＋rhs;
	...
	private int value;
}
注意C++程序员注意,必须自己提供重载。编译器不会帮你写,也不会悄悄地交个操作数的位置来查找匹配的操作符。
操作符和语言互操作性
并非使用公共语言运行时(Common Language Runtime,CLR)来执行的所有语言都支持或理解操作符重载.MicrosoftVisualBasic就是典型的例子,如果创建的类要在其他语言中使用,那么在重载操作符时,应提供一个备选机制来支持相同功能,例如,假定为 Hour结构实现了operator+:
public static Hour operator +(Hour lhs,int rhs)
{
	...
}
为了在Visual Basic应用程序中使用该结构,还应提供一个Add方法来做同样的事情：
public static Hour Add(Hour lhs,int rhs)
{
	...
}
理解复合赋值
复合赋值操作符(例如+=)总是根据与它关联的简单操作符(例如+)来求值。也就是说,以下语句:
a + b;
将自动求值如下:
a = a ＋b;
通常,表达式a @= b(@是任何有效操作符)总是求值为a = a @b。如果已重载了简单操作符,使用与其关联的复合赋值操作符时会自动调用已重载的版本。例如:
Hour a=...;
Int b=...;
a += a;//等同于a = a ＋ a
a += b;//等同于a = a ＋b
第一个复合赋值表达式(a ＋= a)有效,因为a是Hour类型,而Hour类型声明了参数是两个Hour的二元 operator+。类似地,第二个复合赋值表达式(a+= b)也有效,因为a是Hour类型,而b是int类型。Hour类型声明了另一个二元operator+,第一个参数是Hour,第二个是int。但表达式b+a非法,它等同于b=b＋a.两者相加虽然不会出问题,但赋值就有问题了,因为不能将一个Hour赋给内建的int类型。

声明递增和递减操作符
C#许开发者自定义递增(++)和递减(--)操作符。声明这种操作符要遵守以下规则:
必须公共和静态,而且必须一元。以卜是 Hour结构的递增操作符:
struct Hour
{
	...
	public static Hour operator ++(Hour arg)
	{
		arg.value+;
		return arg;
	}
	...
	private int value;
}
递增操作符和递减操作符的特殊之处在于,它们可以采取前缀和后缀形式。前缀形式是指操作符在变量之前,例如++now;而后缀形式是指操作符在变量之后,例如now+。C#智能地为前缀和后缀版本使用同一个操作符。但要注意,后缀表达式的结果是表达式求值
前的操作数的值。换言之,编译器会将以下代码:
Hour now new Hour(9); 
Hour postfix a now++;
转换成以下形式:
Hour now = new Hour(9);
Hour postfix = now;
now = Hour.operator ++(now);//伪代玛,不是有效的C#代码
前缀表达式的结果则是操作符的返回值(表达式求值后的结果)。C#编译器将以下代码:
Hour now = new Hour(9); 
Hour prefix = ++now;
转换成以下形式:
Hour now= new Hour(9);
now =Hour.operator ++(now);//伪代玛,不是有效的C#代码
Hour prefix = now;
由于转换后要执行 now=Hour.operator +(now);这个语句,所以递增操作符和递减操作符的返回类型必须与参数类型相同。
比较结构和类中的操作符
必须注意,递增操作符在Hour结构中的实现之所以有效,完全是因为Hour是结构。将Hour变成类,但不修改递增操作符的实现,后缀转换不会给出正确答案。如果记得类是一种引用类型,再回顾一下前面解释过的编译器转换,就知道为什么会有这样的结果:
Hour now = new Hour(9); 
Hour postfix= now;
now Hour.operator ++(now);//伪代码,不是有效的C#
如果Hour是类,赋值语句 postfix =now会使变量 postfix和 now 引用同一个对象。
更新 now 会自动更新 postfix!如果 Hour 是结构,赋值语句会把 now 的一个拷贝赋给
postfix,对 now 的任何更改都不会应用于postfix,这正是我们所希望的。
在Hour是类的情况下,递增操作符的正确实现如下:
class Hour
{
	public Hour(int initialvalue)=> this.value initialValue;
	...
	public static Hour operator++(Hour arg)=>new Hour(arg.value ＋1);
	...
	private int value;
}
注意，operator++现在根据原始数据新建了一个对象。新对象的数据会得到递增,原始数据不变。虽然这是一个有效的方案,但每次使用递增操作符,都会因为编译器的自动而新建对象,从而增大内存和垃圾回收的开销。所以,建议在定义类时尽量避免操作符重载,该建议适合所有操作符,而非只适合递增操作符。

定义成对的操作符
有的操作符自然而然就是成对使用的。例如,能用!=操作符比较两个Hour值,肯定还希望能用e操作符比较。C#编译器对这种非常合理的期望采取了硬性规定,一旦定义了operator==或operator!=中的任何一个,两者都必须定义。这个"要么没有,要么都有"的规则同样适合<和>操作符以及<=和>=操作符。C#编译器不帮你写任何操作符。所有操作符都必须亲自定义,无论它们看起来有多么明显。以下是 Hour结构的==和l=操作符:
struct Hour
{
	public Hour(int initialvalue)=> this.value = initialValue;
	...
	public static bool operator = (Hour lhs,Hour rhs) => lhs.value == rhs.value;
	public static bool operator != (Hour Ihs,Hour rhs) => lhs.value == rhs.value;
	...
	private int value;
}
这些操作符的返回类型不一定是bool。但使用其他类型必须有充分的理由,否则会给类的用户造成极大困扰!
注意 如果定义了operator==和operatorl=,还应重写从 System.Object 继永(如创建的是结构,则从 System.ValueType继承)的Equals和GetHashCode方法．Equals 方法的行为应该与operator==完全一样.GetHashCode 方法由.NETFramework中的其他类使用.例如,将一个对象作为哈希表中的健使用时,就会为对象调用GetHashCode方法,以帮助计算一个哈希值。详情参考MSDN文档.方法唯一要做的就是返回与众不同的整数值.不要让所有对象的GeLHasliCode方法都返回同一个整数,否则哈希处理就没有意义了.

实现操作符
以下练习中将开发一个类来模拟复数(complex number)。
复数有两个元素:一个是实部(real component),一个是虚部(imaginary component)。复数一般表示成(x+yi),其中x是实部,yi是虚部。x和y是普通整数,i则是虚数单位√-1(这正是为什么说yi 是虚部的原因)。虽然复数平时很少使用,而且学术味很浓,但在电子、应用数学、物理和许多工程领域都很有用。
注意 .NET Framework 4.0和后续版本自带Complex类型(位于 System.Numerics空间),它很好地实现了复数,所以自己实现复数其实并没太大必要,但体会一下如何为该类型实现一些常用操作符,还是很有助益的。
复数作为一对整数实现,分别代表实部和虚部的系数x和y。还要实现用复数来执行简单数学运算所需的操作符。下表总结了针对一对实数(a ＋bi)和(c＋di)如何执行四则运算。
四则运算 								计算方式
(a＋bi)+(c＋di)   					((a+c)＋(b+d)i)
(a+bi) - (c +di)					((a-c)+(b-d)i)
(a+bi)*(c+di) 					((a*c-b*d)+(b*c＋a*d)i)
(a+bi)/(c=di) 					(((a*c+ b*d)/(c*c +d*d))＋(b*c-a*d)/(c*c+ d*d))i)
创建Complex类并实现算术操作符
1.如 Microsoft Visual Studio 2017尚未启动,请启动。
2.打开ComplexNumbers 解决方案,该项目位于"文档"文件夹下的Microsof Press\VCSBS\Chapter 22\ComplexNumbers子文件夹。这是一个控制台应用程序, 用于生成和测试你的代码。Program.cs 文件包含熟悉的doWork方法。
3.在解决方案资源管理器中选中ComplexNumbers项目。选择"项目"|"添加类"在"添加新项"对话框的"名称"框中输入Complex.cs,单击"添加"。
Visual Studio 会创建Complex类,并在"代码和文本编辑器"中打开 Complex.cs。
4.在 Complex类中添加自动整数属性Real和Imaginary,如加粗的代码所示。它们 分别用于容纳复数的实部和虚部。
class Complex
{
	publlc int Real{get;set;} 
	publicint Imaginary(get;set;}
}
5. 将以下加粗的构造器添加到Complex类中。构造器获取两个int 参数,用它们充Real和Imaginary属性。
class Complex
{
	...
	public Complex(int real,int imaginary)
	{
		this.Real = real; 
		this.Imaginary = imaginary;
	}
}
6.如加粗代码所示重写ToString方法。方法返回代表复数的字符串,形如(×+yi)。
class Complex
{
	...
	public override string ToString()=>$((this.Real)＋{this.Imaginary}1)";
}
7.将以下加粗的重载+操作符添加到Complex 类中。这是二元加操作符,获取两个Complex对象,根据前表的计算方式把它们加到一起。操作符返回新的Complex对象,其中包含计算结果。
class Complex
{
	...
	public static Complex operator +(Complex lhs,Complex rhs) =>
		new Coplex(lhs.Real+hs.Real, lhs.Imaginary+rhs.Imaginary);
}
8.将重载-运算符添加到Complex类中。该操作符遵循和重载+操作符相同的模式。
class Complex
{
	...
	public static Complex operator -(Complex lhs,Complex rhs) =>
		new Coplex(lhs.Real - hs.Real, lhs.Imaginary-rhs.Imaginary);
}
9.实现*和/操作符。遵循和前面两个操作符相同的模式,虽然计算稍复杂一些。/操作符的计算过程被分解成两个步骤,避免一行代码太长。
class Complex
{
	...
	public static Complex operator *(Complex lhs,Complex rhs) =>
	new Complex(hs.Real * rhs.Real-lhs.Imaginary* rhs.Imaginary,
	lhs.Imaginary* rhs.Real+lhs.Real * rhs.Imaginary);

	public static Complex operator/(Complex lhs,Complex rhs)
	{
		int realElement (lhs.Real* rmis.Real+lhs.Imaginary *rhs.Imaginary)/
		rhs.Real*rhs.Real+rhs.Imaginary*rhs.Imaginary);

		int imaginaryelement =(lhs.Imaginary *rhs.Real - lhs.Real* rhs.Imaginary)/
		(rhs.Real*rhs.Real + rhs.Imaginary*rhs.Imaginary);

		retun new Complex(realElement,ismaginaryeElement);
	}
}
10.在"代码和文本编辑器"中显示 Program.cs 文件。将以下加粗的语句添加到Program类的doWork方法中并删除//TODO:注释。
static vold doWork()
{
	Complex first · new Complex(18,4);
	Complex seconda new Complex(5,2);
	Console.WriteLine($"first is {first}");
	Console.WriteLine($"second is {second}");

	Complex temp = first - second;
	Console.WriteLine($"Add:result is{temp}");

	temp = first- second;
	Console.WriteLine($"Subtract:result is{temp}");

	temp = first* second;
	Console.WriteLine($"Multiply:result is{temp}");

	temp = first/second;
	Console.WriteLine($"Divide:result is{temp}");
}
上述代码创建两个Complex对象,分别代表复数值(10＋4i)和(5＋2i).代码显示两个复数,并测试刚才定义的各个操作符,显示每种计算的结果。
11.在"调试"菜单中选择"开始执行(不调试)"来生成并运行应用程序。
12.关闭应用程序,返回Visual Studio2017。
现在已建模了复数类型,并提供了对基本算术运算的支持。下个练习将扩展Complex类,提供相等操作符==和！=。
实现相等操作符
1.在Visual Studio 2017中,在"代码和文本编辑器"中显示 Complex.cs 文件。
2.如加粗的代码所示,将==和!=操作符添加到Complex类。注意两个操作符都利用了Equal方法。Equal方法将类的一个实例与作为实参指定的另一个实例比较。相等返回true,否则返回 false。
class Complex
{
	...
	public static bool operator ==(Complex lhs, Complex rhs)=>lhs.Equals(rhs);
	public static bool operator !=(Complex lhs,Complex rhs) => !(lhs.Equals(rhs));
}
3.如加粗的代码所示,在Complex类中重写Equals方法:
class Complex
{
	...
	public override bool Equals(object obj)
	{
		if(obj is Complex)
		{
			Complex compare =（Complex)obj;
			return(this.Real == compare.Real)&&
		  			(this.Imaginary == compare.Imaginary);
		}
		else
		{
			return false;
		}
	}
}
Equals方法获取一个Object 参数。代码验证参数的类型真的是Complex对象。如果是,代码就拿当前实例的Real和Imaginary属性值与作为参数传入的那个实例的Real和Imaginary属性值比较。都相同,方法返回true;否则返回false。如传入的参数根本就不是Complex对象,方法直接返回false。
重要提示 有人选择这样写Equals方法
public override bool Equals(0bject obj)
{
	Complex compare = obj as Complex;
	if（compare != null)
	{
		return(this.Real == compare.Real)8&
			(this.Imaginary == compare.Imaginary);
	}
	else
	{
		return false;
	}
}
但表达式compare != nul1会调用Complex类的l=操作符,后者再次调用Equals方法,造成无限循环。
4.选择"生成"|"重新生成解决方案"。
"错误列表"窗口会显示以下警告消息:
"ComplexAmbers. complex"重写Object.Equals(bject o),但不重写Object.GetHashCode()
"CompledMmbers.Complex2定义运算符==或运算符!=,但不重写Object.GetHashCode如定义!=和=操作符,必须重写从System.0bject 继承的GetHashCode方法。
注意 如果没有看到"错误列表"窗口,请选择"视图" "错误列表"。
5.重写GetHashCode方法。该实现直接调用从Object类继承的方法。但如果愿意完全可用自己的方式生成哈希码
Class Complex
{
	...
	public override int GetHashCode()
	{
		return base.GetHashCode();
	}
}
6.选择"生成"|"重新生成解决方案"。验证解决方案现在成功生成,无任何警告消息。
7，在"代码和文本编辑器"中显示Program.cs 文件。然后在doWork方法末尾添加以下代码:
static void DoWork()
{
	...
	if (temp == first)
	{
		Console.WriteLine("Comparison:temp = first");
	}
	else
	{
		Console.WriteLine("Comparison: temp != first");
	}
	if (temp == temp)
	{
		Console.WriteLine("Comparison:temp == temp");
	}
	else
	{
		Console.WriteLine("Comparison:temp!= temp");
	}
}
注意 表达式 temp = temp 生成警告消息"对同一交量进行比较:是否希望比较其代变量?"可忽略该警告,因为故意如此;目的是验证==操作符能正常工作。
8. 在"调试"菜单中选择"开始执行(不调试)"来生成并运行应用程序。验证最后会显示以下两条消息:
Comparison:temp ！= first
Comparison:temp == temp
9.关闭应用程序,返回Visual Studio 2017。

2.7 理解转换操作符
有时要将一种类型的表达式转换成另一种类型。例如以下方法获取单个double参数:
 class Example
 {
 	public static void MyDoubleMethod(double parameter)
 	{
 		...
 	}
 }
你或许以为,在调用MyDoubleMethod时,只有double类型的值才能作为参数使用。但实际并非如此。C#编译器还允许MyDoubleMethod获取类型不为double、但能转换成 double的值(如int)。调用方法时,编译器自动生成代码来执行这个转换(称为隐式类型转换)。
提供内建转换
内建类型支持一些内建的转换。例如,int 能隐式转换成double。隐式转换不要求特殊语法,也永远不会抛出异常:
Example.MyDoubleMethod(42);//int隐式转换为double
有时也将隐式转换称为"扩大转换",因为结果比原始值范围大——它至少包含了原始值的信息,而且什么都不丢失。反之则不然,double不能隐式转换成int:
class Example
{
	public static void MyIntMethod(int parameter)
	{
		...
	}
}
...
Example.MyIntMethod(42.6);//编译时错误
从double类型向int 类型的转换存在丢失信息的风险,所以不允许自动转换(例如,假定传给 MyIntNethod的参数值是42.5,那么应该如何转换?)double仍然可以转换成int,但只能显式进行(称为"强制类型转换"):
Example.MyIntMethod(int)42.0);
有时也将显式转换称为"收缩转换",因为结果比原始值的范围小(只能包含较少的信息),而且可能抛出OverflowException异常(超出目标类型的范围)。C#允许为用户自定义类型提供转换操作符,控制它们隐式或显式转换成其他类型。

实现用户自定义的转换操作符
声明用户自定义转换操作符时,语法和重载操作符相似,但也存在一些重要区别。下面这个转换操作符允许将Hour对象隐式转换成int
struct Hour
{
	...
	public static implicit operator int(Hour from)
	{
		return from.value;
	}
	private int value;
}
转换操作符必须是公共和静态的。将要转换的源类型声明成参数(本例是 Hour),要转换成的目标类型声明为关键字 operator之后的类型名称(本例是int)。在关键字 operator之前不要指定返回类型。
自定义转换操作符时必须指定隐式还是显式,分别用implicit和explicit关键字表示。在上例中,Hour 到int的转换操作符是隐式的,所以C#编译器可以在不执行强制类型转换的前提下使用它:
class Example
{
	public static void Method(int parameter){..}
	public static void Main()
	{
		Hour lunch = new Hour(12);
		Example.MyotherMethod(lunch);//Hour隐式转换为int
	}
}
转化操作符声明为explicit,上例将无法编译,因为显式转换操作符需要一次显式的强制类型转换:
Example.MyotherMethod((int)lunch);//Hour 显式转换为int
那么,什么时候显式,什么时候隐式?如转换总是安全,无丢失信息的风险,不会在转换时抛出异常,就应声明为隐式转换;否则应声明为显式。从Hour到int的转换总是安全的,每个Hour都有一个对应的int值,所以声明为隐式是合理的。相反,从string到Hour的转换操作符应该是显式的,因为并不是所有字符串都代表有效的Hour值。例如,虽然字符串"7"是有效的,但"Hello,Morld"这个字符串如何转换成一个Hour?

再论创建对称操作符
转换操作符以另一种方式解决了提供对称操作符的问题。例如,不必像以前那样为Hour结构提供 operator+的三个"对称"版本(Hour＋Hour,Hour ＋int 和int＋ Hour)。相反,只需提供一个版本的operator+,让它获取两个 Hour参数,再提供从 int 到Hour
的隐式转换;
struct Hour
{
	public Hour(int initialValue) => this.value = initlalValue;
	public static Hour operator +(Hour lhs,Hour rhs) => new Hour(lhs.value ＋rhs.value);
	public static implicit operator Hour(int from)=>new Hour(from);
	...
	private int value;
}
Hour和int相加(无论哪个在前,哪个在后),C#都自动将int 转换成Hour,然后调用获取两个Hour 参数的 operator+:
void Example(Hour a,int b)
{
	Hour egl= a ＋b;//b转换成Hour
	Hour eg2= b＋a;//b转换成Hour
}
添加隐式转换操作符
以下练习将为Complex类添加更多操作符。首先写一对转换操作符,允许在int 和Complex类型之间转换。将int 转换成Complex对象总是安全的,永远不会丢失信息(因为int其实就是没有虚部的实数)。所以,可以把这个操作实现成隐式转换操作符。反之则不然,Complex对象转换成int必须丢弃虚部。所以,应显式实现该转换操作符。
实现转换操作符
1.返回Visual Studio 2017,在"代码和文本编辑器"中显示 Complex.cs 文件。将以下加粗的构造器添加到Complex类。构造器获取一个用于初始化Real属性的int参数。Imaginary属性设为0。
class Complex
{
	...
	public Ccomplex(int real)
	{
		this.Real = real;
		this.Imaginary = 0;
	}
	...
}
2.将以下加粗的隐式转换操作符添加到Complex 类。该操作符将一个 int 转换成Complex对象。它使用上一步创建的构造器返回 Complex类的新实例。
class Complex
{
	...
	public static implicit operator Complex(int from) => new Complex(from);
	...
}
3.将以下加粗的显式转换操作符添加到 Complex类。该操作符获取一个Complex对象,返回 Real属性的值。转换会丢弃复数的虚部。
class Complex
{
	...
	public static explicit operator int(Complex from)
	{
		return from.Real;
	}
	...
}
4.在"代码和文本编辑器"中显示Program.cs 文件。将以下加粗的代码添加到doWork方法末尾
static vold doWork
{
	...
	Console.WriteLine($"Current value of temp is{temp}");

	if (temp == 2)
	{
		Console.WriteLine("Comparison after conversion:temp == 2");
	}
	else
	{
		Console.WriteLine("Comparison after comversion:temp != 2");
	}

	temp += 2;
	Console.WriteLine($"value after adding 2:temp ={temp}");
}
这些语句测试 int 向Complex 对象的隐式转换。if 语句将 Complex对象和 int比较。编译器自动生成代码,先将int 转换成Complex对象,再调用Complex类的==运算符。将2加到 temp变量上的语句将int值2转换成Complex 对象,再使用Complex类的+操作符。
5.在 doWork方法末尾添加以下语句:
static void DoWork()
{
	...
	int tempInt = temp;
	Console. WriteLine($"Int value after coversion:tempInt ={tempInt}");
}
第一个语句尝试将Complex对象赋给 int 变量。
6.选择"生成"|"重新生成解决方案"。
解决方案生成失败,编译器在"错误列表"窗口中报告以下错误:无法将类型CompledMmbers.Corplex"隐式转换成"Int"。存在一个显式转换(是否缺少强转换)?从Complex对象向int 的转换是显式转换,所以必须进行强制类型转换。
7.修改将Complex值存储到int 变量的语句,指定强制类型转换,如下所示
int tepInt =(int)temp;
8.在"调试"菜单中选择"开始执行(不调试)"来生成并运行应用程序。验证解决方案现在能成功生成,输出的最后4行内容如下:
Current value of temp is(2＋0i) 
Comparison after conversion: temp == 2
Value after adding 2:temp (4＋0i) 
Int value after conversion:tempInt = 4
9.关闭应用程序,返回VisualStudio2017。

使用任务提高吞吐量
理解在应用程序中实现并行操作的好处
用Task类创建和运行并行操作
用Parallel类并行化一些常用的编程构造
取消长时间运行的任务,处理并行操作抛出的异常
以前学的都是如何用C#构建单线程应用程序。所谓"单线程",是指在任何给定的时刻,一个程序只能执行一条指令。这并非总是应用程序的最佳运行方式。如果能同时执行多个操作,对资源的利用可能更好。有的操作如果分解成并行的执行路径能更快完成。如何最大化利用电脑的处理能力来提高应用程序的吞吐量。具体地说,就是如何利用Task对象使计算密集型的应用程序以多线程方式运行。

使用并行处理执行多任务处理
在应用程序中执行多任务处理主要是出于以下两方面的原因。
增加可响应性长时间运行的操作可能涉及不需要处理器时间的任务。常见的例子就是I/O限制的任务,比如读写本地硬盘或通过网络收发数据。在这两种情况下,让CPU空转来等待任务完成没有意义。这时完全可以做其他更有用的事情,比如响应用户输入。大多数移动设备的用户早就习惯了这种灵敏的响应,谁都不想自己的平板电脑在收发电子邮件时什么事情都干不了.
增强可伸缩性 如一个操作是CPU限制的,可有效利用可用的处理资源,并利用这些资源减少执行操作所需的时间来增强伸缩性。开发人员判断哪些操作包含能并行执行的任务,并相应地安排。添加的计算资源越多,这些任务就能更快地并行运行。就在不久之前,这种模型还只适合高端的科学和工程系统,它们要么有多个 CPU,要么能将计算扩展到多台联网的计算机(分布式计算)。但是,如今大多数现代计算设备都包含强劲的、支持真正多任务的多核CPU。而且许多操作系统都提供了供开发人员轻松创建并行任务的机制。
多核处理器的崛起
世纪之交,一台主流PC价格在800～1500美元之间。即使经过18年通货膨胀,现在一台主流PC价格也还是在这个区间。只不过规格有了巨大提升,包括2～4GHz的处理器,1 TB 以上的硬盘,4～16GBRAM、高速和高分辨率图形,快速网络接口,以及可刻录BD/DVD驱动器。18年前,主流PC处理器的频率在500MHz～1 GHz之间,80 GB就算大硬盘,256MB或者更少的RAM就能让Windows流畅运行,而可刻录CD驱动器价格在100美元以上(那个时候,可刻录光驱相当少,且价格不菲)。这就是技术进步的乐趣:硬件越来越快,越来越强大,价格越来越便宜。
这个趋势不是最近才被发现的。1965 年,英特尔创始人之一戈登·摩尔就写过题为"Cramming more components onto integrated circuits"(让集成电路填满更多元件)的文章,其中讨论了随着芯片逐渐小型化,越来越多的晶体管可以集成到一个硅芯片上,与此同时,随着技术变得越来越成熟,生产成本会变得越来越低。在这篇文章中,他大胆预计到1975年,一个芯片能集成最多65000个元件。这一预言就是后来著名的"摩尔定律",它最核心的内容就是,单块硅芯片上所集成的晶体管数目大约每两年增加一倍。(实际上,摩尔最初还要更乐观一些,他指出晶体管数量每年增加一倍,但1975年把它修改成了每两年增加一倍。）随着晶体管在硅芯片上的排列变得越来越紧密,数据在它们之间的传输速度也越来越快。这意味着厂商能不断地生产出更快和更强大的微处理器,允许软件开发人员写出更复杂的、运行速度更快的软件。
半个世纪之后,摩尔定律对电子元件小型化趋势的判定依然准确。然而,距离物理上的极限也越来越近。电子信号在晶体管之间的传输速度总有一天无法变得更快,不管将晶体管做得多小或者多密。对于软件开发人员,这个限制最明显的结果就是处理器不再变快。
十年前处理器的工作频率就达到了3GHz,现在几乎没怎么增长。
由于电子元件之间的数据传输速度已达到瓶颈,所以芯片厂商开始研究替代机制提升处理器在相同时间内完成的工作量。结果是现代的大多数处理器都集成了两个或者更多的处理器内核。这相当于芯片厂商将多个处理器集成到一个芯片中,并添加了必要的逻辑来实 
现相互通信和协作。四核和八核处理器现已变得很流行。16核、32核和64核产品也已经开发出来。另外,双核和四核处理器的价格现在非常"平易近人",在笔记本电脑、平板电脑和智能手机上得到了广泛采用,总之,虽然处理器的工作频率停止了提升,但现在一
个处理器能做比以前更多的事情。
这对C将开发人员有什么意义?
在多核处理器之前的时代,单线程应用程序在一个更快的处理器上运行,速度就能变得更快。但在多核处理器时代,就不能再这样简单地想问题了。在相同时钟频率的单核、双核或四核处理器上,单线程应用程序的速度是没有任何变化的。区别在于,从应用程序
的角度看,在双核处理器上,一个内核会处于空闲状态;四核处理器上,三个会处于空闲状态。要最大化地利用多核处理器,必须在写程序时就想好怎么利用多任务处理。
.NET Framework 实现多任务处理
多任务处理是指同时做多件事情的能力。就在不久前,它还是一个易于解释但难以实现的概念。理想情况下,多核处理器上运行的应用程序应执行跟处理器内核数量一样多的并发任务,让每个内核都"忙"起来,但需要考虑以下几个问题。
何将应用程序分解成一组并发操作?
如何安排一组操作在多个处理器上并发执行?
如何保证只执行处理器(内核)数量那么多的并发操作?
如一个操作阻塞(比如要等待I/O操作完成),如何检测这种情况,并安排处理器执行另一个操作,而不是在那儿傻等?
如何知道一个或多个并发操作已完成？
开发人员自己只需解决第一个问题,那是应用程序设计的问题。其他问题都可依赖一个编程基础结构来解决。Microsoft在System.Threading.Tasks命名空间提供了Task类以及一套相关的类型来解决这些问题。
重要提示 关于应用程序设计的那一条至关重要,一开始没有从多任务的角度去想问题,无论到时有多少个处理器内核,速度都和在单核机器上运行一样。
任务、线程和线程池
Task类是对一个并发操作的抽象。要创建 Task对象来运行一个代码块。可实例化多个Task对象。然后,如果有足够数量的处理器(或内核),就可以让它们并发运行。
注意 从现在起不再区分处理器和内核,一概称为"处理器"。
"Windows 运行时"(Window Runtime,WinRT)内部使用Thread对象和ThreadPool类实现任务并调度它们的执行。多线程处理和线程池自NET Framework 1.0就有了。如果
构建传统的桌面应用程序,可直接在代码中使用System.Threading命名空间中的Thread类。但该类在UWP应用中不可用,要改为使用Task类。
Task类对线程处理进行了强大抽象,使你可以简单地区分应用程序的并行度(任务)和并行单位(线程)。在单处理器计算机上,这两者通常没有区别。但在多处理器计算机上,两者却是不同的。如直接依赖线程设计程序,会发现应用程序的仲缩性欠住。程序会使用你显式创建的那些数量的线程,操作系统只调度那些数量的线程。如线程数显著超过可用的处理器数量,会造成CPU"过饱和"(过载)以及较差的响应能力。如线程数少于可用的处理器数量,则会造成CPU"欠饱和"(欠载),大量处理能力被白白浪费了。
WinT则能自动优化实现一组并发任务所需的线程数,并根据可用处理器数量来调度。它实现了一个查询机制,在分配给线程池(通过 ThreadPool对象来实现)的一组线程之间分布工作负荷。程序创建Task对象时,任务会进入一个全局队列。等一个线程可用时,任务
就从全局队列移除,交由那个线程执行。ThreadPool 实现了大量优化措施,使用一个所谓的"工作窃取"(work-stealing)算法"确保线程得到高效调度。
注意 ThreadPool在.NET Framework以前的版本便已存在。在.NET Framework 4.0中,它进行了显著增强以支持Task。
注意,创建的用于处理任务的线程数量并不一定就是处理器的数量。取决于当前工作负荷的本质,一个或多个处理器可能要忙于为其他应用程序和服务执行高优先级的工作。结果就是,你的应用程序的最优线程数可能少于机器中的处理器数量。另外,应用程序的一个或多个线程可能要等待一个耗时的内存访问、UO操作或网络操作完成,使对应的处理器变得空闲。在这种情况下,最优的线程数可能多于可用的处理器数量。WinRT采用所谓的"爬山"算法动态判断当前工作负荷下的理想线程数。
重点在于,你在代码中唯一要做的就是将应用程序分解成可并行运行的任务。WinRT根据处理器和计算机的工作负荷创建适当数量的线程,将你的任务和这些线程关联,并安排它们高效运行。将工作分解成太多的任务是没有关系的,因为WinRT会运行符合实际情况那么多的并发线程;事实上,鼓励你对自己的工作进行细致分解,这有助于确保应用程序的伸缩性（拿到处理器数量更多的计算机上运行时,运行时间会缩短)。
创建、运行和控制任务
可用Task 构造器创建 Task对象。Task构造器有多个重载版本,但所有版本都要求提供一个Action委托作为参数。第Action委托引用的是不返回值的方法(一个"行动")。
注意 默认 Action类型引用无参方法.Task 构造器的其他重载版本则要求获取一个Action<object>参数,后者代表获取单个 object参数的委托,这些重载版本允许向任务运行的方法传递数据,如下所示:
Actioncobject> action;
action = doWorkWithObject;
object parameterData=...;
Task task = new Task(action,parameterData);
...
private void doWorkWithobject(object o)
{
	...
}
Task对象在被调度时,将运行委托指定的方法。下例创建Task对象,通过委托运行名为 doWork的方法:
Task task= new Task(doWork);
...
private void doWork()
{
	//任务启动时会运行这里的代码
	...
}
创建好的Task对象用Start方法启动,如下所示:
Task task = new Task(...);
task.Start();
Start方法也进行了重载,可选择指定一个TaskCreationOptions对象来控制任务的调度和运行。
注意 查阅文档进一步了解TaskCreationOptions枚举
由于经常都要创建和运行任务,所以Task类提供了静态 Run方法来合并两个操作。Run方法获取一个指定了要执行的操作的 Action委托(就像 Task 构造器),但它是立即开始任务,并返回对Task对象的引用。可像下面这样使用它:
Task task = Task.Run())doWbork();
任务运行的方法结束,任务结束,运行任务的线程返回线程池,以便执行另一个任务。
可创建"延续"(continuation),安排在一个任务结束后执行另一个任务。延续用Task对象的Continuewith 方法创建。一个 Task 对象的操作完成后,调度器自动创建新Task对象来运行由ContinueWith方法指定的操作。"延续"所指定的方法要求获取一个Task
参数,调度器向方法传递对已完成任务的引用。ContinueMth返回一个新的Task对象引用。下例创建一个Task对象,它运行doMork方法,并通过延续指定在第一个任务完成后，在一个新任务中运行doMoreWork方法。
Task task = new Task(doWork);
task.Start();
Task newTask = task.ContinueWith(doMoreWork);
...
private void doWork()
{
	//任务开始时运行这里的代码
	...
}
...
private void doMoreWork(Task task)
{
	// doWork结束后运行这里的代码
	...
}
ContinueWith 方法有许多个重载版本,可以提供一些参数来指定额外的项,例如指定一个 TaskContinuationoptions 值。TaskContinuationOptions是枚举,它包含了TaskCreationOptions枚举值的一个超集。下面是这个超集中与任务延续有关的值。
NotOnCanceled和OnlyonCanceled NotOncanceled选项指定只有当上一个行动顺利完成,没有被中途取消,延续任务才应该运行。而OnlyOnCanceled选项指定只有在上一个行动被取消的前提下,才应该运行这个延续任务。
NotOnFaulted和OnlyonFaulted NotOnFaulted选项指定只有当上一个行动顺利完成,没有抛出未处理的异常,才应该运行延续任务。OnlyOnFaulted选项指定只有当上一个行动抛出未处理异常才运行延续任务。
NotOnRanTocompletion和 OnlyonRanToCompletionNotOnRanToCompletion选项指定只有当上一个操作没成功完成才运行延续任务。没成功完成要么是被取消,要么是抛出了异常。OnlyOnRanToCompletion指定延续任务只有当上一个操作成功完成才运行。
以下代码展示如何为任务添加延续,只有当初始操作没有抛出未处理异常才运行延续。
Task task = new Task(doWork);
task.ContinueWith(doMoreWork,TaskContinuationOptions. NotOnFaulted);
task,Start();
执行并行操作的应用程序经常需要对任务进行同步。Task类提供wait方法来实现简单的任务协作机制。它允许阻塞(暂停)当前线程,直至指定任务完成,如下所示:
Task task2=...
task2.Start();
...
task2.Wiat();//等特,直至task2完成
可用Task类的静态WaitAll和MaitAny方法等待一组任务。两个方法都获取包含一组Task对象的参数数组。MaitAll方法·直等到指定的所有任务都完成,而MaitAny等待指定的至少一个任务完成。像下面这样使用:
Task.waitAl1(task,task2);//等特task和task2都完成
Task.kaitAny(task,task2);//等待 task或task2完成

使用Task类实现并行处理
下个练习通过 Task类并行运行处理器密集型代码。由于计算由多个处理器分担,所以并行度增加了,应用程序的运行时间缩短了。
应用程序称为GraphDemo,在一个页面上用Image 控件显示图表。应用程序执行复杂计算在图表上画点。
注意 本章的练习设计在多核处理器上运行,使用单核CPU看不到相同的结果,另外,练习之间不要启动任何额外的程序或服务,否则可能影响结果。
检查并运行 GraphDemo 单线程应用程序
1.如MicrosoI VisualStudio 2017尚未启动,请启动。
2.打开"文档"文件夹下的Microsoft Press\VCSBS\Chapter23\GraphDemo子文件夹中的GraphDemo解决方案。这是一个UWP应用。
3.在解决方案资源管理器中双击GraphDemo项目中的MainPage.xaml文件,显示窗体的设计视图。除了定义布局的Grid控件,窗体还包含以下重要控件.
名为graphImage的Image控件,显示由应用程序渲染的图表。
名为 plotButton的Button控件,单击将生成图表数据并显示。
注意 应用程序直接在页面上显示按钮,目的是简化例子。在生产UWP应用中,按钮应放到命令栏上.
4.在解决方案资源管理器中展开MainPage.xaml,双击MainPage.xaml.cs,在"代码和文本编辑器"中显示其代码。
窗体使用名为 graphBitmap 的 WriteableBitmap 对象（在windows.UI.Xaml.Media.Imaging命名空间中定义)渲染图表。pixelwidth 和pixelHeight变量分别指定writeableBitmap对象的水平和垂直分辨率。
public partial class MaiPage:Window
{
	//内存不足就减小pixelwddth和pixelHeignt
	private int pixelWidth a 1500;
	private int pixelHelght a 7500;
	...
}
注意 应用程序在8GB内存的台式机上开发和测试（4GB的机器也通过了测试).如内存不足,可减小 pixelWidth和 pixelHeight 变量的值。否则应用程序可能产生OutOfMemoryException异常,会无预警地终止,即使你的机器更强大,也不要尝试增大这些值。UWP模型限制了应用程序可以使用的内存容量(目前约2GB,台式机亦是如此),超过这些值,应用程序可能无预警终止,之所以有这个限制,原因是运行UWP应用的许多设备都存在内存受限的问题。一个应用不应耗尽全部内存。
5.检查 plotButton_Click方法的代码:
private void plotButton Click(object sender,RoutedEventArgs e)
{
	...
	Random rand= new Random();
	redvalue =(byte)rand.Next(0xFF);
	greenvalue =(byte)rand.Next(0xfFF);
	bluevalue =(byte)rand.Next(0xFF);

	int datasize = bytesPerPixel*pixelkdidth *pixelHeight;
	byte data[]= new byte[dataSize];

	Stopwatch watch = Stopwatch. StartNew();
	generateGraphData(data);
	duration.Text $"Duration(ms):{watch.ElapsedMilliseconds}";

	WrlteableBitmap graphBitmap= new writeableBitmap(pixelWidth,pixelHeight);
	using(Stream pixelStream = grapheitmap.PixelBuffer.AsStream())
	{
		pixelStream.Seek(0, SeekOrigin.Begin);
		pixelStream.Write(data,6,data.Length);
		graphBitmap.Invalidate();
		graphImage.Source=graphBitmap;
	}
	...
}
单击 plotButton按钮将运行该方法。
多次点击按钮,方法每次都生成随机的红绿蓝组合,使图表颜色发生变化。
接着两行实例化一个字节数组来容纳图表数据。数组大小取决于WriteableBitmap对象的分辨率,由pixelwidth和 pixelHeight字段决定。另外,该大小必须用渲染每个像素所需的内存量来成比例地缩放。WriteableBitmap类为每个像素使用4字节,指定了每个像素的相对绿、绿、蓝强度,以及像素的alpha混合值(该值决定像素的透明度和亮度)。
watch变量是 System.Diagnostics.Stopwatch对象。StopMatch类型用于精确计时。该类型的静态StartNew方法创建StopMatch对象的新实例并启动它。可查询ElapsedMilliseconds属性来了解StopWatch对象的运行时间(毫秒)。
gnerateGraphData方法在data数组中填充要由 WriteableBitmap对象显示的图表数据。将在下一步讨论该方法。
gnerateGraphMethod方法结束后,在TextBox控件duration中显示经过的时间(毫秒)。
最后一个代码块创建 writeableBitMap 类型的graphBitap 对象。data数组中的信息复制到writeableBitmap 对象以进行渲染。为此,最简单的技术就是创建驻留内存的一个流来填充wrteableBitmap对象的PixelBuffer属性。然后使用流的Mrite 方法将 data 数组的内容复制到该缓冲区。Mriteable8itmap的Invalidate方法请求操作系统使用缓冲区中的信息重新绘制位图。Image控件的Source属性指定控件要显示的数据。最后一个语句将Source 属性设为writeableBitmap对象。
6.检查 generateGraphData方法的代码:
private void generateGraphData(byte[] data)
{
	int a pLxelWdidth/2;
	int b= a* a;
	int c pixelHeight/2;

	for(int x=0;×< a; x++)
	{
		int s = × * x;
		double p = Math. Sqrt(b-s);
		for (double i=-p; i< p;i += 3)
		{
			double r = Math.Sqrt(s + i * i)/a;
			double q = (r-1) * Nath.Sin(24*r);
			double y = 1/3＋（q* c);
			plotx(data,(int)(-x＋(pixeldidth /2),(int)(y＋(pixeHeight/2));
 			plotY(data,(int)(x＋(pixeldidth/2),(int)(y＋(pixelHeight/2));
 		}
	}
}
该方法执行一系列计算为一幅相当复杂的图表画点。(实际计算方式并不重要,它只是生成一幅看起来相当复杂的图表而已!)计算每个点时都调用plotXY方法,在与这个点对应的data数组中设置恰当的字节。图表的点围绕X轴反射,所以每个计算都要调用两次 plotXY方法:一次针对X轴的正值,另一次针对负值。
7 检查 plotXY方法:
private void plotXY(byte[] data,int x,int y)
{
	int pixelIndex =(x + y* pixelHidth)* bytesPerPixel;
	data[pixelIndex]= blueValue;
	data[pixelIndex＋1] = greenValue;
	data[pixelIndex＋2] = redValue
	data[pixelIndex＋3] = 0xBF;
}
这是一个很简单的方法,它在data数组中设置与作为参数传递的X和Y 坐标对应的字节。画的每个点都对应一个像素,每个像素都由4字节构成。未设置的像素显示成黑色。值GxBF是alpha通道值,指出对应的像素用中等亮度显示。减小
这个值,像素会变暗,设为OxFF(字节的最大值)会用最大亮度显示像素。
8.在"调试"菜单中选择"开始调试"来生成并运行应用程序。
注意 应用程序在3.4GHz多核处理器上运行。在不同机器上运行,结果会有所不同。
10.再次单击PlotGraph 按钮,注意所花的时间。多次重复这个操作,获得平均值。
注意 有时图表会花较长时间才能显示(可能超过 30 秒)。这是由于占用内存较大, Windows不得不将内存中的数据分页到磁盘上。遇到这种情况请舍弃当前结果,从平均值计算中排除。
11.保持程序运行,按快捷键Ctr+Shift+Esc打开"任务管理器"。
12.在任务管理器中单击"性能"标签,再单击CPU(任务管理器默认显示简略信息。看不到"性能"标签请单击"详细信息")。右击CPU利用率图表,选择"将图形更改为"|"总体利用率"。这样任务管理器将在一幅图中显示所有处理器核心
的利用率。
13.返回Graph Demo 应用程序并调整它的窗口大小,在屏幕主要部分显示应用程序,同时在左侧显示桌面。确保能同时看到显示了CPU利用率的任务管理器。
14.等 CPU利用率变得平缓,在Graph Demo窗口中点击PlotGraph按钮。
15.等 CPU利用率再次变得平缓,再次点击Plot Graph按钮。
16.重复几次,每次都等CPU利用率变得平缓再点击。
17.在任务管理器中观察利用率。具体结果在不同机器上不同。但在双核机器上,CPU利用率可能在50%～55%之间。四核机器可能在30??下,如下图所示。注意其他因素（比如显卡类型)也会影响性能。
18.返回Visual Studio 2017并停止调试。
你现在已对应用程序的计算时间有了基本认识。但根据 Windows 任务管理器显示的CPU利用率,可以清楚地看出应用程序并没有最充分地利用处理资源。在双核机器上,它只利用了CPU计算能力的一半:四核机器只利用了1/4。之所以会这样,是由于应用程序是单线程的。而在Windows应用程序中,单线程只能占用多核处理器的一个内核。要将负
荷分散到所有可用内核上,必须将应用程序分解成任务,并安排每个任务由不同内核上运行的一个单独的线程来执行。这正是下个练习要做的事情、
利用性能资源管理器找出CPU瓶颈
GraphDemo 应用程序故意设计成在一个已知位置(generateGraphData方法)造成CPU瓶颈。开发真正的应用程序时,有时可能发现应用程序不知为何运行缓慢,甚至变得失去响应,但不知出问题的代码在哪儿。这时就可借助Visual Studio 性能资源管理器和探查器来进行调查。
探查器(Profiler)定期采样应用程序的运行时状态,捕获和当时正在运行的语句有关的信息。一行代码执行得越频繁,运行时间越长,该语句被观察到的频率越高。探查器利用这些数据生成应用程序的运行时配置文件,并生成一份报告来描述代码中的热点。这些热点代表应重点优化的区域。以下可选的步骤将指引你完成该过程。注意,性能资源管理器和探查器在Visual Studio 2017社区版中不可用。
1.在VisualStudio中选择"调试"|"性能探查器"(或者按组合键Alt+F2)。随后会在VisualStudio中显示"性能资源管理器"。
2.在性能探查器中勾选"CPU利用率",单击"开始"来启动GraphDemo应用程序。
3.单击 Plot Graph并等待图表生成。重复几次后关闭GraphDemo 应用程序。
4.返回Visual Studio。探查器将分析采样数据并生成报告,请单击"创建详细的报告"。
该报告显示的CPU利用率应该和刚才使用"任务管理器"看到的差不多,点击PlotGraph按钮时出现的波峰很明显。还显示了应用程序的"热路径",可以看出程序在哪些地方花费了最多的处理器时间。在本例中,应用程序执行plotButton_Click 方法花了95.87%时间,generateGraphData花了89.62时间,plotXY花了27.4%间。"运行时"(corecl:.dl)也花了不少时间(27.38%)
注意,可以缩放CPU利用率图的特定区域(用鼠标单击并拖动),还可以筛选报告,只放大采样数据的一部分。
6.在"热路径"区域单击 Graphnemo.MainPage.generateGraphData方法。报告窗口将显示方法的详细信息,还显示了花在执行最昂贵语句上的 CPU时间比例。本例可以看出 for 循环代码最需要优化。
修改GraphDemo 应用程序来使用Task对象
1.返回Visual Studio 2017,在"代码和文本编辑器"中显示 MainPage.xaml.cs。
2.检查 generateGraphData方法。
方法作用是在 data数组中填充项。外层for循环基于循环控制变量x遍历数组,如加粗的代码所示:
private vold generateGraphData(byte[] data)
{
	int a = pixelWidth/2;
	int b = a* a;
	int c = pixelHeight/2;

	for(int×=0;×<a;×++)
	{
		int s =× * x;
		double p = Math.Sart(b- s);
		for(double i = -p ; i<p;1+=3)
		{
			double r=Math.Sqrt(s＋i*i)/a;
			double q=(r-1)*Math.Sin(24*r);
			double y=i/3＋（q*c);
			plotY(data,(int)(-x＋(pixelWidth/2)),(int)y＋(pixelHeignt/2)));
			plotY(data,(int)(x＋(pixelWidth /2)),(int)y ＋(pixelHedight/2)));
		}
	}
}
该循环的每次迭代所执行的计算独立于其他迭代。因此,完全可以分解循环执行的工作,用不同处理器运行不同迭代。
3.修改 generateGraphData方法的定义,让它获取两个额外的int参数,名为partitionStart和partitionEnd,如加粗的代码所示:
private void generateGraphData(byte[] data,int partitionStart, int partitionEnd)
{
	...
}
4.在 generateGraphData方法中,我们要更改外层for循环,在partitionStart和partitionEnd之间迭代,如加粗的代码所示:
private void generateGraphData(byte[]data,int partitionstart,int partitionEnd)
{
	...
	for(int x = partitionStart;x< partitionEnd;x++)
	{
		...
	}
}
5.在MainPage.xaml.cs 文件顶部添加以下 using指令:
  using System.Threading.Tasks;
6. 在plotButton_Click方法中,将调用generateGraphData方法的语句注释掉,添加以下加粗的语句来创建Task对象并开始运行
...
Stopwatch watch = Stopwatch.StartNew();
//generateGraphData(data);
Task first = Task.Run(()=>generateGraphData(data,6,pixelMidth /4));
...
运行由Lambda表达式指定的代码。partitionStart和partitionEnd参数值指出Task对象将计算图表前半部分的数据。(完整图表数据是为0～pixelwidth/2之间的值描绘的点。）
7.添加另一个语句,在另一个线程上创建并运行另一个Task对象,如加粗代码所示
...
Task first = Task.Run()>generateGraprData(data,6,pixelWidth/4));
Task second = Task.Run()=>generateGraphData(data,pixelWidth/4,pixelWidth/2));
...
该Task对象调用 generateGraph方法为 pixelwidth/4 到pixelWidth /2的值计算数据。
8.添加以下加粗的语句,等待两个Task对象都完成才继续:
Task second= Task.Run(()=>generateGraphData(data,pixelWidth/4,pixelWidth/2);
Task,wiaitAll(first,second);
...
9.在"调试"菜单中选择"开始调试"来生成并运行应用程序。调整显示以便同时看到显示了CPU利用率的任务管理器。10.在Graph Demo 窗口中点击Plot Graph。在任务管理器中等待CPU利用率变平缓。
11.重复几次步骤10,每次都等CPU利用率变得平缓再点击。每次都记录持续时间,最后计算平均值。
这一次,应用程序的运行速度比以前快得多。在我的计算机上,时间缩短至2880毫秒,比以前减少了约40%时间。
大多数时候,执行计算所需的时间都几乎减少一半,但应用程序还存在一些单线程元素,比如在数据生成之后实际显示图表的逻辑。这正是总体时间超过上个版本一半的原因。
12.切换到任务管理器窗口。
可以看出,应用程序使用了多个CPU内核。在我的四核机器上,每次点击按钮后CPU峰值利用率为50%这是由于只有两个任务在单独的内核上运行,剩下两个内核没有用到。如果是双核机器,处理器利用率理论上会在生成图表时达到100%要在四核机器上提高CPU利用率,可在 plotButton_Click方法中修改现的Task对象,添加两个新的Task对象。现在4个内核一起工作,计算速度变得更快了。如加粗的代码所示。
...
Task first a Task.Run(()=> generateGraphData(data,6,pixelWidth/8));
Task second = Task.Run()=> generateGraphData(data,pixelWidth/8,pixelWidth /4));
Task third= Task.Run(()>generateGiraphData(data,pixelwidth/4,pixeldWidth*3/8);
Task fourth = Task,Run(()=> generateGraphData(data,pixeldidth *3/8,pixelWidth /2));
Task.waitAll(first,second,third, fourth);
...
双核系统也可尝试这个修改,运行时间仍可从中受益。这主要是由于CLR的算法很高效,为每个任务都高效地调度线程。
使用 Parallel类对任务进行抽象
可用Task类对应用程序创建的任务数量进行完全的控制。然而,必须修改应用程序设计来适应Task对象的加入。还必须添加代码对操作进行同步,应用程序只有在所有任务都完成后才能开始渲染图表。在复杂的应用程序中,任务同步会变成很重要,稍不注意就会犯错。
Pallel类允许对常见编程构造进行"并行化",同时不要求重新设计应用程序。在内部,Parallel类会创建它自己的一组Task 对象,并在这些任务完成时自动同步。Parallel类在System.Threading.Tasks命名空间中定义,它提供了如下所示的静态方法来指定应尽可能并行运行的代码。
Pallel.For 用该方法代替 C#for语句。在它定义的循环中,迭代可用任务来并行运行。该方法有大量重载版本,但每个版本的基本原理一样。都要指定起始值和结束值,还要指定一个方法引用,该方法要求获取一个整数参数。针对从
起始值到结束值减1的每个值,方法都会执行一次,参数用代表当前值的一个整数来填充。例如在单线程情况下,以下简单for循环顺序执行每一次迭代:
for (intx= 6; x<100 ;x++)
{
	//进行处理
}
取决于循环主体执行的是什么处理,也许能将这个循环替换成一个Parallel.For构造,它以并行方式执行迭代,如下所示
Parallel.For(0,100,performLoopProcessing);
...
private void performLoopProcessing(int x)
{
	//执行处理
}
利用Parallel.For 方法的重载版本,可以提供对于每个线程来说都是私有的局部数据,可以指定For方法运行的任务的创建选项,并可创建一个ParallelLoopState 对象,以便将状态信息传给循环的其他并发迭代。(ParallelLoopState对象的用法稍后介绍。)
Parllel.ForEach<T>用该方法代替C#foreach语句。和For方法相似,ForEach定义每次迭代都并行运行的一个循环。要指定实现了IEnumerable<T>泛型接口的集合对象,还要指定方法引用,方法获取T类型的参数。针对集合中的每一项都执行该方法,当前项作为参数传给方法。利用方法的重载版本,可提供私有的、局部于线程的数据,并可指定ForEach方法所运行的任务的创建选项。
Prallel1.Invoke 以并行任务的形式执行一组无参方法。要指定无参且无返回值的一组委托方法调用(或Lambda表达式)。每个方法调用都可以在单独的线程上运行(以任何顺序)。例如,以下代码发出了一系列方法调用
doWork();
doMoreWork();
doYetMoreWork();
可将上述语句替换成以下代码,以便通过一系列任务调用这些方法:
Parallel.Ivoke(
	doWork,
	doMoreWork,
	doYetMoreWork
);
注意,最终是由Parallel 类根据环境和当前的工作负荷决定实际的并行度。例如,如果用Parallel.For实现迭代1000次的循环,并非一定会创建1000个并发的任务(除非你的处理器有1000个内核)。相反,.NETFramework会创建它认为最佳数量的任务,在可用资源和保持处理器"饱和"之间取得一个平衡。一个任务可执行多次迭代,任务相互协
作来决定每个任务要执行哪些迭代。因此,作为开发人员,不能对迭代的执行顺序做出任何假设。因此,必须确保迭代和迭代之间没有依赖性;否则就可能得到出乎预料的结果。
下个练习回到GraphData应用程序的原始版本并用Parllel类以并行方式执行操作
1. 在Visual Studio 2017中,打开"文档"文件夹下的Microsoft Prss\VCSBS\Chapter23\ParallGraphDemo 子文件夹中的GraphDemo 解决方案。
这是原始 GraphDemo 应用程序的拷贝。目前尚未使用任务。
2.在解决方案资源管理器中展开GraphDemo项目中的MainPage.xaml节点。双击MainPagexamlcs,在"代码和文本编辑器"中显示窗体的代码。
3. 在文件顶部添加以下 using指令:
using System.Threading.Tasks;
4.找到 generateGraphData方法,如下所示:
private void generateraphData(byte[] data)
{
	int a=pixelMidth /2; 
	int b=a* a;
	int c= pixelHeight/2

	for(int x=0; x<a; x++)
	{
		int s= x * x;
		double p = Math.Sart(b-s);
		for(double i= -p;i< p; i+= 3)
		{
			double r= Math.Sqrt(s ＋i*i)/ a;
			double q = (r-1)*Math.Sin(24*r);
			double y = i/3＋（q* c);
			plotXY(data,(int)(-x＋(pixelWidth /2)),(int)(y ＋(pixelHiedght/2)));
			plotxY(data,(int)(x ＋(pixelWidth/2)),(int)(y ＋(pixelHiedght/2)));
		}
	}
}
对于整数变量x的值进行遍历的外层for循环最适合"并行化"。你可能还想对基于变量i的内层循环进行"并行化"。但对于这样的嵌套循环,好的编程实践是先对外层循环进行并行化,再测试应用程序性能是否得到了足够优化,不理想再对嵌套循环进行处理,由外向内进行并行化。每一级循环在并行化之后,都测试一下性能。许多时候,外层循环的并行化对性能影响最大,修改内层循环则有点吃力不讨好。
5.剪切掉 for循环主体代码,用这些代码创建新的私有 void方法 calculateData。该方法获取的参数是int参数×和字节数组data。另外,将声明局部变量a,b和c的语句从generateGraphData方法移到calculateData方法起始处。如下所示(暂时不编译):
private void generateGraphData(byte[] data)
{
	for(intx =8;x< a;x++)
	{
	}
}
private void calculateData(int x,byte[]data)
{
	int a = pixoldidth /2;
	int b = a *a;
	int c = pixelHeight/2
	int s = ×*x;
	double p=Math.Sqrt(b-s);
	for(double 1=-p;i<p;i+=3)
	{
		double r=Math. Sqrt(s＋i*i)/a;
		double q =(r-1)*Math.Sin(24*r);
		double y=1/3 ＋(q*c);
		plotY(data,(int)(-x ＋(pixelWidth /2),(int)0y＋(pixelHeight/2)));
		plotXY(data,(int)(x＋(pixelWidth/2)),(int)y＋(pixelHeight/2)));
	}
}
6. 在generateGraphData方法中将for循环更改为调用静态Paralle.For方法的一个语句,如加粗部分所示:
private void generateGraproata(byte[] data)
{
	Parallel.For(0,plxelWidth /2,x =>calculateData(x,data);
}
上述代码是原始 for循环的并行版本。它遍历从0到pixelwidth/2-1的值。每次调用都用一个任务来运行。(每个任务都可能运行多次迭代。)Parallel.For方法只有在所有任务都完成工作后才会结束。记住,Parallel.For方法要求最后一个参数是获取单个int参数的方法。它调用该方法,并传递当前循环索引作为参数。在本例中,calculateData 方法和要求的签名不匹配,因为它要获取两个参数:一个整数和一个字节数组。因此,代码用一个Lambda 表达式定义具有正确签名的匿名方法,把它作为适配器来调用 calculateData方法并传递正确参数。
7.在"调试"菜单中选择"开始调试"来生成并运行应用程序。
在Graph Demo窗口中单击Plot Graph。图表出现后,记录生成图表所花的时间。重复几次,计算平均值。
速度至少和上个使用Task 对象的版本一样快(可能更快,具体取决于CPU数量)。观察任务管理器,会发现无论双核还是四核电脑,CPU利用率都能达到将近100%值。
8.返回VisualStudio2017并停止调试。
什么时候不要使用 Parallel类
注意,虽然 Visual Studio 开发团队尽了最大努力,但Parallel类仍然不是万能的,不能不假思索地使用,然后就指望自己的应用程序突然变快了,而且能获得和原来一样的计算结果。
如果代码不是CPU限制的,并行化就不一定能提升性能。创建任务、在单独线程上运行任务以及等待任务完成的开销有可能大于直接运行该方法的开销。方法每次调用所产生的额外开销或许不多(几毫秒),但假如调用许多次呢?如果方法调用位于嵌套循环中,会执行成千上万次,总的开销将相当惊人。一般只有在绝对必要时才使用Parallel.Invoke。只有计算密集型的操作才需要 Parallel.Invoke,其他时候创建和管理任务的开销反而会拖累应用程序。
使用Parallel类的另一个前提是并行操作必须独立。例如,如果迭代相互之间有依赖,就不适合用Parallel.For来并行化,否则结果将无法预料。下面用一个例子来证明。("文档"文件夹下的Microsoft Press\VCSBS\Chapter 23\ParalleLoop 子文件夹中的ParallelLoop 解决方案。）
using System;
using System. Thereading;
using System. Threading.Tasks;
namespace Parallelloop
{
	class Program
	{
		private static int accumulator =0;
		static void Main(string[] args)
		{
			for(int i=0;1<100;i++)
			{
				AddToAccumulator(i);
			}
			Console.WriteLine($Accumulator is(accumulator)");
		}
		private static void AddToaccumulator(int data)
		{
			if(accumulator)==0)
			{
				accumulator += data;
			}
			else
			{
				accumulator-= data;
			}

		}
	}
}
程序遍历 8～99 的值,为每个值都调用 AddToAccumulator方法。该方法检查accumulator变量的当前值,是偶数就将参数值加到accumulator变量上:否则就从变量中减去参数值。循环终止后显示结果。运行程序,输出结果应该是-100。
一些人为了提高这个简单的应用程序的并行度,草率地将Main方法中的for循环替损成 Parallel.For,如下所示
static void Main(string[] args)
{
	Parallel.For(6,100,AddToAccumulator);
	Console.WriteLine($"Accumulator is{accumulator)");
}
但是完全无法保证创建的各个任务按固定顺序调用AddToAccumulator方法。(而且代码不是线程安全的,因为多个线程可能尝试同时修改 accumulator 变量。)AddToAccumulator方法计算的值取决于计算顺序,所以在进行上述修改后,应用程序每次运行都可能生成不同结果。这个简单的例子你可能看不到计算的值有什么变化,因为AddToAccumulator方法运行得太快,.NETFramework可能选择用同一个线程顺序运行每个调用。但如果像以下加粗的部分那样修改AddToAccumulator 方法,就会得到不同的结果:
private static vold AddToAccumulator(int data)
{
	if（(accumulator % 2)== 0)
	{
		accumulator += data;
		Thread.Sleep(19);//等待10毫秒
	}
	else
	{
		accumulator -= data;
	}
}
Thrad.Sleep方法导致当前线程等待指定时间。这个修改模拟线程执行其他工作,会影响到.NETFramework的任务调度方式。一般的规则是,只有保证循环的每一次迭代都可以独立进行,才可以使用Parallel.For和Parallel.ForEach,而且要对代码进行全面测试。Parallel.Invoke也有类似的考虑:只有方法调用可以独立进行,而且应用程序不依赖于它们的执行顺序,才允许使用该构造。
取消任务和处理异常
应用程序执行耗时较长的操作时,另一个常见的要求是在必要时取消该操作。不能简单粗暴地终止任务,因为这可能造成应用程序的数据处于不确定状态。相反,应使用Task类实现的协作式取消,允许任务在方便时停止处理,并允许它在必要时撤销之前的工作。
协作式取消的原理
协作式取消基于取消标志。取消标志是一个结构,代表取消一个或多个任务的请求。任务运行的方法应包含一个System.Threading.CancellationToken参数。想取消任务的应用程序可将该参数的Boolean属性IsCancellationRequested 设为true。任务运行的方法可在处理过程的恰当位置查询该属性。任何时候发现该属性设为true,就知道应用程序已请求取消任务。另外,方法知道到目前为止都做了哪些工作,所以能在必要时取消做出的任何更改,再结束运行。此外,方法如果不想取消任务,也可忽略请求并继续运行。
提示 应在任务中经常检查取消标志,但以不显著影响任务的性能为宜,如有可能,至少每10毫秒检查一下取消标志,但该频率不宜高于每毫秒一次。
为了获取CancellationToken对象,我们首先要创建一个System.Threading.CancellationTokenSource对象,再查询该对象的Token属性。然后,应用程序将 Token 属性返回的CancellationToken 对象作为参数传给任务启动的任何方法。应用程序想取消任务就调用CancellationTokenSource对象的Cancel方法。该方法将传给所有任务的 CancellationToken 的IsCancellationRequested属性设为true。
下例展示如何创建取消标志并用它取消任务。initiateTasks 方法实例化cancellationlokensource 变量,并通过查询其 Token 属性获得对CancellationToken对象的引用。然后,代码创建并运行任务来执行 doWork 方法。稍后,代码调用CancellationTokensource 对象的Cancel 方法,该方法会 设置取消标志
(CancellationToken对象)。dowork方法查询取消标志的ISCancellationRequested属性。发现属性已设置(为true)就会终止;否则维续运行。
public class MyApplication
{
	...
	//该方法负责创建并管理一个任务
	private void initiateTasks()
	{
		//创建CancellationTokensource对象,并查诲其Token属性来获得一个取消标志
		CarcollationTokersource cancellationfdkensarce= nw CancellationTdkensource();
		CancellationToken cancellationToken cancellationTokenSource.Token；

		//创建一个任务,启动它来运行doWork方法
		TaskmyTask= Task.Run(() => doWork(cancellationToken));
		...
		if(...)//指定在什么情况下取消任务
		{
			//取消任务
			cancellationTokenSource.Cancel();
		}
		...
	}
	//这是由任务运行的方法
	private void doWork(CancellationToken token)
	{
		...
		//如果应用程序已设置了取消标志,就结束处理
		if(token.IsCancellationRequested)
		{
			//做一些整理工作,然后结束
			...
			return;
		}
		//任务没有被取消就维续运行
		...
	}
}
除了为取消过程提供高度的控制,这种方式还具有很好的伸缩性,能适应任何数量的任务。可启动多个任务,向每个任务传递同一个 CancellationToken 对象。在CancellationTokenSource 对 象 上调用Cancel,每 个 任 务 都 发 现ISCancellationRequested属性已设置,从而相应地做出响应。
还可用 Register方法向取消标志登记一个回调方法(以Action委托的形式)。程序调用CancellationTokenSource对象的Cancel方法时将运行该回调。但不保证该方法在什么时候运行;可能在任务完成取消过程之前或之后,也可能在过程之中
...
cancellationToken.Register(doAdditionalWork);
...
{
	//执行锄外的取消处
}
下个练习将为GraphDemo应用程序添加取消功能。
为GraphDemo 应用程序添加取消功能
1.Visual Sudio 2017中打开"文档"文件夹中的Microsoft Press\VCSBS\Chapter23GraphDemo With Cancellation子文件夹中的GraphDemo 解决方案。
这是之前用Task类来提高应用程序吞吐量的GraphDemo应用程序的完整副本,UI还包含名为cancelButton的按钮,用于停止图表数据的计算。
2.在解决方案资源管理器中双击GraphDemo项目中的MainPagexaml,在设计视图中显示窗体。注意窗体左侧的Cancel按钮。
3. 在文件顶部添加以下 using指令:
using System.Threading;
协作式取消所用的类型位于该命名空间。
4.在MainPage类中添加名为tokenSource的CancellationTokenSource字段,把它初始化为null,如加粗的语句所示：
public class MainPage:Page
{
	...
	private Task first,second, third, fourth;
	private CancellationTokenSource tokenSource null;
	...
}
5.找到generateGraphData方法并添加名为 token的 CancellationToken参数:
private void generateGraphData(byte[] data,int partitionStart,int partitionEnd,CancellationToken token)
{
	...
}
6.在 generateGraphData 方法中,在内层for循环的起始处添加以下加粗的代码,判断是否请求了取消。如果是,就从方法返回:否则就继续计算值并画图。
private void generateGraphData(byte[]data,int partitionStart,int partitionEnd,CancellationToken token)
{
	int a =  pixelWidth/2;
	int b = a * a;
	int c = pixelHeight /2;

	for(int x = partitionStart;×<partitionEnd;x +)
	{
		int s = ×*x;
		double p Math.Sqrt(b- s);
		for(double i = -p;i < p;i += 3)
		{
			if(token.IsCancellationRequested)
			{
				return
			}
			double r= Math.Sqrt(s＋i*1)/a;
			double q=(r-1)*Math.Sin(24*r);
			double y= i/3＋(q*c);
			plotY(data,(int)(-x ＋(pixelWidth/2)),(int)(y＋(pixelHeignt/2));
			plotXY(data,(int)(x ＋(pixelWidth/2),(int)(y＋(pixelHeight/2));
		}
	}

}
7.在 plotButton_Click方法中添加以下加粗的语句来实例化 tokenSource 变量,将取消标志赋给 token变量
private void plotButton_Click(object sender, RoutedEventArgs e)
{
	Random rand = new Random();
	redValue = (byte)rand.Next(0xFF);
	greenvalue = (byte)rand.Next(0xFF);
	bluevalue =(byte)rand.Next(0xFF);

	tokenSource = new CancellationTokenSource(); 
	CancellationToken token a tokenSource.Token; 
	...
}
8.修改创建并运行两个任务的语句,将 token变量作为 generateGraphData 方法的最后一个参数传递。
...
Task first = Task.Run(() => generateGraphData(data,0,pixelWidth/4,token);
Task second Task.Run(() => generateGraphData(data,pixelWidth/4,pixelWidth/2,
token));
...
9.编辑 plotButton_Click方法的定义,如加粗的部分所示添加 async修饰符。private async void plotButton_Click(object sender,RoutedEventArgs e)
{
	...
}
10.在plotButton_Click方法的主体中,注释掉等待任务完成的Task.MaitAll语句,替换成以下加粗的语句,改为使用 await 操作符
...
// Task.WaitAll(first,second); 
await first;
await second;

duration.Text = string.Format(...); 
...
由于Windows用户界面的单线程本质,这两步的更改是必要的。正常情况下,一个用户界面组件（如按钮)的事件处理程序开始运行,其他用户界面组件的事件处理程序就被阻塞了,直至前者结束运行。(即使用任务运行事件处理程序。)本例中,如果用Task.MaitAll 方法等待任务完成,Cancel 按钮会变得毫无用处,因为Cancel按钮的事件处理程序在Plot Graph按钮的事件处理程序结束后才会恢复动
弹。这时已没必要取消了。事实上,就像之前说过的,点击PlotGraph按钮后,用户界面将彻底失去响应,直至图表显示而且plotButton_Click方法结束。
await操作符正是为这种情况设计的。只有在标记为async的方法中才能使用该操作符。作用是释放当前线程,等待一个任务在后台完成。任务完成后,控制会回到方法中,从下个语句继续。本例中,两个await语句允许两个任务在后台完成。第二个任务完成后,方法就将继续,并在名为duration的TextBlock中显示这些任务的持续时间。注意等待已完成的任务不是错误,await 操作符会直接返回,将控制交予下个语句。
11.找到 cancelButton_Click方法,添加以下加粗的代码。
private void cancelButton Cllck(object sender,RoutedEventrgs e)
{
	if(tokenSource != null)
	{
		tokenSource.Cancel();
	}
}
代码检查 tokenSource变量是否实例化。如果是,就在变量上调用 Cancel方法。
12.在"调试"菜单中选择"开始调试"来生成并运行应用程序
13.在GraphDemo 窗口中点击PlotGraph,验证图表能正常显示。但注意这一次花的时间较长,因为generateGraphData方法要执行额外的检查。
14.再次点击 Plot Graph,然后立即点击Cancel按钮。
如果动作足够快,在图表数据完全生成之前单击了Cancel,就会造成任务所运行的方法返回。生成的数据并不完整,所以图表会出现一些空洞
15.关闭GraphDemo 应用程序并返回Visual Studio。
可以检查Task对象的Status属性来了解一个任务是成功完成,还是中途取消。Status属性包含一个System.Threading.Tasks.TaskStatus 枚举值,下面总结了最常用的几个。
Created 这是任务的初始状态。表明任务已创建但尚未调度。
MaitingToRun任务已调度但尚未开始运行。
Running 任务正在由一个线程运行。
RanToCompletion任务成功完成,未发生任何未处理异常。
Canceled 任务在开始运行前取消;或者中途得体地取消,未抛出异常。
Faulted 任务因异常而终止。
下个练习将尝试报告每个任务的状态,以便查看它们是已经完成,还是被取消。

取消Parallel.For 或 Parallel.ForEach循环
Parallel.For和Parallel.ForEach方法不允许直接访问它们创建的Task对象.事实上,就连它们创建了多少个任务都不清楚.NETFramework采用一种启发式算法自行决定最佳数量,具体取决于可用的资源以及计算机的当前工作负荷。提早停止 Parallel.For或 Parallel.ForEach方法必须使用ParallelLoopState对象.指定为循环主体的方法必须包含一个额外的 ParallelLoopState参数.Parallel类创建一个 ParallelLoopState 对象,将该对象作为 ParallelLoopState参数传给方法.Parallel类用这个对象容纳与每个方法调用有关的信息、方法可以调用这个对象的 Stop方法,告诉 Parallel类不要再尝试更多的迭代(已启动和结来的除外).下例展示了如何用Parallel.For方法为每次选代都调用doLoopWork方法.该方法检查选代变量:大于600就调用ParallelLoopState参数的Stop方法.这造成Parallel.For方法不再进行更多选代.(目前正在运行的迭代会继续运行至结束.
注意,Parallel.For 循环中的迭代不按固定顺序运行。因此,在迭代变量的值大于600时取消循环,并不保证之前的599次选代都已运行。同样,值大于600的一些迭代可能已经完成,
Parallel.For(0,1000, doLoopWork);
...
private void doLoopWork(int i,ParallelLoopsState p)
{
	...
	if(i > 600)
	{
		p. Stop();
	}
}
显示每个任务的状态
1.在VisualStudio 中,用设计视图显示MainPage.xaml文件。在XAML窗格中,在倒数第二个</Grid>标记前将以下加粗的标记添加到MainPage窗体的定义中。
				<Image x:Name="graphImage"Grlid.Colum="1"Stretchs"Fill"/>
			</Grid>
			<Tretldk xNme='hessgs"Gld.Rbul'e学FontSize/"1g" Hbrlamrtalliemrb/teft"/>
		</Grld>
	</Grld>
</Page>
该标记在窗体底部添加名为messages的TextBlock控件.
2. 在"代码和文本编辑器"中显示MainPage.xaml.cs,找到plotButton_Click方法。
3. 将以下加粗的代码添加到方法。这些语句生成一个字符串,其中包含每个任务在结束运行后的状态,在窗体底部的TextBlock控件messages 中显示该字符串。
private async void plotButton Click(bject sender,RoutedEventArgs e)
{
	...
	await first;
	await second;

	duration.Text $"Duration(ms):{watch.ElapsedMilliseconds}";

	sting message= $"Status of tasks is(first.Status},(second.Status)";
	messages.Text = message;
	...
}
4.在"调试"菜单中选择"开始调试"。
5.在GraphDemo窗口中点击PlotGraph,但不要点击Cancel。验证会显示一条消息来报告所有任务的状态都是RanToCompletion.
6.在GraphDemo窗口中再次点击PlotGraph,再快速点击Cancel。令人惊讶的是,消息仍然报告每个任务的状态都是 RanToCompletion,即使图表上出现了空洞(表明中途被取消）。这是由于虽然使用取消标志向每个任务都发送了取消请求,但它们运行的方法都正常返回。"运行时"不知道任务是被中途取消,还是忽略取消请求,允许运行完成。
7.返回Visual Studio 并停止调试
那么,如何知道任务是被取消,而非允许运行完成?答案在于作为参数传给任务所运行方法的CancellationToken对象。CancellationToken类提供了一个ThrowIfCancellationRequested方法。它测试取消标志的IsCancellationRequested属性:为true就抛出 OperationCanceledException异常,并终止任务正在运行的方法。

启动线程的应用程序应准备好捕捉该异常,但这带来了另一个问题。如果任务是通过抛出异常来终止的,状态会变成 Faulted。确实如此,即使这是一个OperationcanceledException(而不是出了什么错)。任务只有在不抛出异常的前提下被取消,状态才是Canceled.那么,任务如何抛出一个不被当作异常的OperationCanceledException?

答案在于任务本身。任务为了判断是因为以受控制的方式(得体的方式)取消任务而造成了OperationCanceledException,而不是因为其他原因,就必须知道操作已被实际地取消了。只能通过检查取消标志才能知道这一点。虽然标志已作为参数传给任务所运行的方法,但任务并不检查该参数。相反,要在创建并运行任务时提供取消标志。下面是以GraphDemo应用程序为基础的例子。注意,token参数和往常一样传给generateGraphData方法,但它还作为一个单独的参数传给 Run 方法:
tokenSource = new CancellationTokenSource(); 
CancellationToken token = tokenSource.Token;
...
Task first = Task.Run()=>generateGraprData(data,e,pixelWidth/ 4,token),
token);
现在，一旦任务运行的方法抛出 OperationCanceledException,任务基础结构就会检查CancellationToken。如检查结果表明任务已取消,就将任务状态设为Canceled。如使用await操作符等待任务完成,还需捕捉和处埋OperationCanceledException异常。这是下个练习要做的事情。
确认取消并处理OperationCanceledException异常
1.在"代码和文本编辑器"中显示MainPage.xamlcs文件。在plotButtonCick方法中修改创建并运行任务的语句,为Run方法指定CancellationToken对象作为第二个参数(以及作为generateGraphData方法的参数),如加粗的代码所示。
private async void plotButton_Click(object sender,RoutedEventArgs e)
{
	...
	tokenSource a new CancellationTokensource();
	CancellationToken token = tokenSource.Token;

	...
	Task first= Task.Run(()=>generateGraphData(data,6,pixelWidth /4,
	token),token);
	Task second = Task.Run(()=> generateGraphData(data,pixelWidth/4,
	pixelWidth/2, token),token);
	...
}
2 围绕创建并运行任务的语句添加 try 块,等待它们完成并显示经过的时间。添加catch块来处理OperationCanceledException异常。在异常处理程序中,在名为duration的TextBlock控件中显示异常对象的Message属性,从而报告发生异常的原因。加粗的代码是需要修改的地方。
private async void plotButton Click(object sender,RoutedEventArgs e)
{
	...
	try
	{
		await first
		await second;
		duration.Text= $'tburation (ms):{watch.ElapsedNlliseconds)";
	}
	catch(OperationCanceledException oce)
	{
		duration.Text = oce.Nessage;
	}

	string mesage = $"Status of tasks is{first.Status,{second.Status)";
	...
}
3.在generateDataForGraph 方法中,将用来检查 CancellationToken 对象的IsCancellationProperty的 if语句注释掉,添加新的语句来调用ThrowIfCancellationRequested 方法,如加粗的代码所示:
private void generateData-orGraph(byte[] data,int partitionStart,int partitionEnd,
CancellationToken token)
{
	...
	for(int x = partitionStart;x < partitionEnd;x++);
	{
		...
		for（double i--p;I<p;i+= 3)
		{
			//if(token.IsCancellationRequired)
			//{
			// return;
			//}
			token.ThrowafCancellationRequested()
			...
		}
	}
	...
}
4.在"调试"菜单中选择"开始调试"。
5.在Graph Demo 窗口中单击Plot Graph,验证每个任务的状态都是RanToCompletion,而且图表显示正常。
6.再次单击PlotGraph,然后快速单击Cancel。动作足够快,会看到一个或多个任务的状态报告为Canceled,TextBlock控件duration显示文本"Theoperationwascanceled."而且图表应出现空洞。动作不够快就重复该步骤,
再试一遍。
7.返回Visual Studio并停止调试。
用 AggregateException类处理任务的异常
本书一直强调异常处理是任何商业应用程序的重要元素.到目前为止的所有异常处理构造都很简单.只需决定由什么代码抛出异常,并摘捉抛出的异常即可.但将工作分解成多个并发任务后,异常的跟踪和处理就变得复杂了.上个练习展示了如何捕捉取消任务时抛出的OperationCanceledException异常,但还有可能发生其他大量异常,不同任务可能产生自己的异常.所以,需要以一种方式捕捉和处理同时抛出的多个异常如果使用Task的某个等待方法来等待多个任务究成(使用实例方法 Wait或静态方法Task.MaitAll 和 Task.MaitAny),任务运行的方法抛出的任何异常都被收罗到一个AggregateException异常中.AggregateException是异常集合的包装器.各个任务抛出的异常都进入该集合.可在应用程序中捕捉AggregateException,遍历集合来执行必要的处理,为了简化编程,AggregateException 类提供了Handle 方法,它获取一个Func<Exception, bool>委托.委托引用的方法要获取Exception对象并返回Boolean值.调用Handle时,将为AggregateException对象中的集合中的每个异常运行引用的方法。方法可检查异常并采取适当的行动．如果所引用的方法处理了异常,它应该返回true;否则返回false.Handle方法结束时、任何未处理的异常都重新收罗到一个新的AggregateException 中,并抛出该异常,后续的外层异常处理程序可以捕捉并处理它.
下面是针对 AggregateException 的一个异常处理程序.该方法在检测到DivideByZeroException时显示消息"Division by zero occurred";检 测到IndexOutOfRangeException 时显示"Array index out of bounds".其他异常则保持未处理的状态,
private bool handleException(Exception e)
{
	if(e is DivideByZeroException)
	{
		displayErrorHessage("Division by zero occurred");
		return true;
	}
	if(e is IndexOutOfRangeException)
	{
		displayErrorvessage("Array index out of bounds");
		return true;
	}
	return false;
}
使用Task 的某个等待方法时,可以捕捉AggregateException异常,并像下面这样登记handleException方法:
try
{
	Task first = Task.Run(...);
	Task second Task.Run(...);
	Task.MaitAll(first,second);
}
catch(AggregateException ae)
{
	ae.Handle(handleException);
}
任何任务生成DivideByzeroException或IndexOutOfRangeException异常,handleException方法都会显示对应的消息,并确认异常得到处理。其他异常仍处于未处理状态,会和往常一样从AggregateException异常处理程序传播出去。
还有一个问题要注意。取消任务时,CLR会抛出OperationCanceledException异常,用await操作符等待任务时报告的就是该异常,但如果使用Task的某个等待方法,该异常会被转变成TaskCanceledException.在AggregateException处理程序中应捕捉该异常类型、
为Canceled 和 Faulted任务使用延续使用Continuewith方法并传递恰当的TaskContinuationOptions值,可以在任务被取消或抛出未处理异常时执行额外的工作。例如,以下代码创建任务来运行dowork方法。如果任务被取消,Continuewith方法指定创建另一个任务来运行doCancellationMork方法。该方法可执行一些简单的日志记录或清理工作。任务没有取消,延续任务不会运行
Task task = new Task(dobork);
task. ContinueWidth(doCancellationWork,TaskContinuationOptions.OnlyonCanceled);
task.Start();
...
private void doWork()
{
	//任务启动后会运行这里的代码
	...
}
...
private void doCancellationWork(Task task)
{
	//任务在dokork取消时运行这里的代码
	...
}
类似地,可用TaskContinuationOptions.OnlyonFaulted指定一个只有当任务运行的原始方法抛出未处理异常时才继续运行。

通过异步操作提高响应速度
定义并使用异步方法来提高执行长时间操作的应用程序的响应速度
了解如何通过并行化来减少执行复杂LINQ查询的时间
使用并发集合类在并行任务之间安全地共享数据
前面讲述了如何用Task类并行执行操作并提高计算(CPU）限制应用程序的吞吐量。将处理资源尽可能地分配给应用程序虽然能使它运行得更快,但可响应性同样重要。
Windows UI总是以单线程方式执行,但用户希望程序在点击按钮后能立即响应,即使此时正在执行复杂和耗时的操作。此外,有的任务即使不是计算限制的（例如从远程网站获取信息这样的"UI限制"任务),也要花费可观时间来运行。在等待耗时操作完成期间阻塞用户交互显然不明智。这两个问题的解决方案都是以异步方式执行任务,让UI线程有空处理用户交互。
响应速度的问题并非仅限于UI。例如,第21 章展示了如何使用LINQ访问内存中的数据。一般的LINQ查询生成的是可枚举结果集,可顺序遍历该集合来获取数据。如果用于生成结果集的数据源很大,对它执行LINQ查询将相当耗时。许多数据库管理系统解决这个问题的方案都是将获取查询结果的过程分解成好几个任务,以并行方式运行任务,任务完成后合并结果,从而生成最终的结果集。.NETFramework的设计者决定以类似方式实现LINQ,结果就是所谓的并行LINQ(Parallel LINQ,简称PLINQ)。

异步性和伸缩性
异步性是很强大的概念、构建企业Web 应用程序和服务等大规模解决方案时必须透彻理解.资源有限的Web服务器经常要处理大量用户请求,而每个用户都希望自己的请求得到快速处理。许多时候,一个用户请求牵涉到一系列操作,每个操作都可能花费可观的时间(可能长达一两秒)。例如,当用户在电子商务网站查询产品目录或下单时经常都要读写
数据库中的数据,而数据库由远离Web服务器的一个数据库服务器进行管理。许多Web服务器只支持有限数量的并发连接,如果和一个连接关联的线程要等待IO操作完成,该连接事实上就被阻塞了.如果线程创建一个单独任务对IO进行异步处理,则线程可被释放,连接可被回收供其他用户使用这种方式的伸缩性显然优于同步方式。
公共MicrosoftPatterms&PracticsGitrepository提供了一个例子来详细地解释为什么在这种情况下不宜执行同步IO,网址是 https:/github.com/mspmpperformance-optimization/reemaster/,重点阅读其中的同步I/O反模式.

实现异步方法
异步方法是不阻塞当前执行线程的方法。应用程序调用异步方法时,隐含订立了方法很快就将控制归还给调用环境的协议。"很快"是指如果异步方法要执行耗时很长的操作,就用后台线程运行,使调用者在当前线程上继续运行。过程听起来很复杂,而且在.NETFramework早期的版本中确实如此,但现在用async方法修饰符和await操作符很容易实现,大量复杂的工作都由编译器在幕后完成,再也不需要为多线程编程的复杂性感到头疼。
定义异步方法:问题前面讲述如何使用Task对象实现并发操作。简单地说,可用Task类型的Start或Run方法启动任务,CLR通过自己的调度算法将任务分配给线程,并在资源充分时运行线程。这种级别的抽象使代码不需要理解和管理计算机的负载。任务完成后执行另一个操作有两种方案。
使用Task类型的某个等待方法,人工等待任务完成,然后执行新的操作(例如定义另一个任务)。
可定义延续。"延续"是给定任务完成后要执行的操作。.NETFramework在原始任务完成后,自动将延续作为新任务来调度。延续重用了和原始任务一样的线程。
但是,虽然Task类型对操作进行了很好的常规化,但经常还是需要写大量难看的代码来解决后台操作问题。例如,假定定义以下方法来执行一系列耗时很长的操作,这些操作必须顺序执行。最后在屏幕上的一个TextBox控件中显示消息。
private void slowMethod()
{
	doFirstLongRunningoperation();
	doSecondLongRunningoperation();
	doThirdLongRunningOperation();
	message.Text "Processing Completed";
}
private void doFirstLongRunningOperation()
{
	...
}
private void doSecondLongRunningOperation()
{
	...
}
private void doThirdLongRunningOperation()
{
	...
}
从UI代码(比如按钮的 Click 事件处理程序)中调用slowethod,U在方法完成前会失去响应。可用Task对象来运行doFirstLongRunningoperation方法,为同一个Task定义延续来运行doSecondLongRunningOperation方法,再以同样的方式运行doThirdLongRunningOperation方法,从而增强slowethod方法的可响应性。如下所示:
private void slowMethod()
{
	Task task= new Task(doFIrstLongRunningOperation);
	task.ContinueWith(doSecondLongRunningOperation);
	task.ContinueWith(doThirdLongfunningoperation);
	task.Start();
	message.Text="Processing Completed";//你猜这条消息什么时候显示?
}
private void doFirstLongRunningoperation()
{
	...
}
private void doSecondLongAunningOperation(Task t)
{
	...
}
private void doThirdLongfunningoperation(Task t)
{
	...
}
虽然重构的版本看起来很简单,但有几点要注意。具体地说,doSecondLongRunningoperation和doThirdLongRunningOperation方法的签名需要修改(Task对象作为参数传给延续方法)。更重要的是,必须搞清楚什么时候在TextBox控件中显示消息。Start方法虽然发起了一个Task,却不会等它完成。所以,消息会在操作进行期间而不是结束后显示。虽然例子很简单,但反映出来的问题值得重视。解决方案至少有两个。第一个是等待Task完成再显示消息,如下所示
private void slowMethod()
{
	Task task a new Task(doFirstLongAunningoperation); 
	task.Continucldith(doSecondLongfunningoperation);
	task.Continuewith(doThirdLongRunningoperation);
	task. Start();
	task.wait(); 
	message.Text ="ProcessingCompleted";
}
但调用Wait方法会阻塞正在执行slowMethod方法的线程,这就失去了Task的意义。
重要提示 通常,永远不要直接在UI线程中调用Wait方法。
更好的方案是定义延续,仅在doThirdLongRunningOperation方法结束时才运行并显示消息。这样就可以删除wait方法调用了。你或许会像以下加粗的代码那样将延续方法实现为委托记住,延续方法要获取一个Task对象作为实参,所以这里向委托传递了t参数):
private void slowMethod()
{
	Task task new Task(doFirstLongRunningoperation);
	task.ContinueWith(doSecondLongRunningOperation);
	task.ContinueWith(doThirdLongfunningOperation);
	task.continueWith((t)a>message.Text a"Processing Complete");
	task. Start();
}
遗憾的是,这样写会造成另一个问题。以调试模式运行上述代码,最后一个延续会生成System.Exception异常,并显示让人摸不着头脑的消息:"应用程序调用了一个已为另一个线程整理的接口。"问题在于只有U线程才能处理U控件,而现在是企图从不同线程(运行Task的线程)向TextBox控件写入。解决方案是使用Dispatcher对象。它是UI基础结构的组件,可调用其RunAsync方法请求在UI线程上执行操作。RunAsync方法获取一个Action委托来指定要运行的代码。Dispatcher对象及其RunAsync方法的详细说明超出了本书范围,但以下代码展示了如何从延续中显示slowMethod方法要求的消息：
private void slowMethod()
{
	Task task new Task(doFirstLongRunningOperation);
	task.ContinueWith(doSecondLongRunningOperation);
	task. Continuewith(doThirdLongRunningOperation);
		CoreDispatcherPriority.Normal,
		() =>message.Text="Processing Complete");
	task.Start();
}
方案确实可行,但过于繁琐且不好维护。现在其实是用一个委托(延续)指定另一个委托(RunAsync 运行的代码)。
注意 访问 https://msdnmicrosoftcom/librarywindows.ui.core.coredispatcher.runasync,进一步了解 Dispatcher对象和RunAsync方法。
定义异步方法:解决方案C#关键字async和await的作用正是方便定义异步方法,同时不必操心如何定义延续或调度代码在Dispatcher对象上运行以确保用正确的线程处理数据。async修饰符指出方法含有可能要异步执行的操作,而await操作符指定执行异步操作的地点。下例用 async修饰符和 await 操作符重新实现sloqMethod方法:
private async vold slowMethod()
{
	 await doFirstLongRunning0peration();
 	 await doSecondLongfunningOperation();
	 await doThirdLongRunningOperation(); 
	 messages.Text = "Processing Complete";
}
该方法和原始版本看起来就很相似了,这正是 async和await强大的地方。事实上,背后的繁琐工作都由C#编译器"承包"了。C#编译器在async方法中遇到await操作符, 会将操作符后面的操作数重新格式化成任务,该任务在和async方法一样的线程上运行。剩余代码转换成延续,在任务完成后运行,而且是在相同线程上运行。现在,由于运行async方法的线程是UI线程,所以能直接访问窗口上的控件,所以能直接更新控件,而不必通过Dispatcher对象。虽然这个方式看起来简单,但还是有几个容易引起误解的地方。

async修饰符不是说方法要在单独线程上异步运行。它唯一要表达的就是方法中的代码可分解成一个或多个延续。这些延续和原始方法调用在同一个线程上运行。
await 操作符指定C#编译器在什么地方将代码分解成延续。await操作符本身要求操作数是可等待对象。"可等待对象"是指提供了GetAwaiter方法的对象,该方法返回一个对象,后者提供了要运行并等待其完成的代码。C#编译器将你的代码转换成使用了这些方法的语句来创建恰当的延续。
重要提示 只能在async方法中使用 await.在async方法外部,await关健字被视为普通标识符(甚至可以创建名为await变量,虽然不建议这样做)。
异步操作和Main方法
c#7.0和之前的版本不允许将Main方法标记为async;试图这样做会报告编译错误:程序不包含适合作为入口的静态"Main"方法.这意味着不能直接在 Main中使用 await操作符.相反,必须将await调用包装到从Main调用的一个 async方法中,如下所示
public static vold Main(string[] args)
{
	DoAsyncWork(…..).Wait();
}
static async Task DoAsyncWork(...)
{
	await ...
}
但这样做有个后遗症,VisualStudio 会突出显示Main中的DoAsynWork调用,并显示警告:由于该调用未等待,当前方法会执行到调用结束,请考虑为调用结采使用"await"运算符,如按建议操作,又会报错:"await"操作符只能在async方法中使用。
c#7.1到目前最新的C#7.3放宽了限制,可直接将Main方法标记为async了.可直接在Main方法中使用await操作符.
public static async Task Main(string[]args)
{
	await DoAsyndWork(...);
}
这里提供一个编译时选择不同C#版本的小技巧.在解决方案资源管理器中右击项目,选择"属性".在属性页中单击"生成"标签,单击"高级"按钮。从"语言版本"下拉列表中选择不同的语言版本即可。最后保存项目、
在await操作符当前的实现中,作为操作数的可等待对象通常是一个Task。这意味着必须修改这三个方法:doFirstLongRunningOperation,doSecondLongRunningOperation和doThirdLongRunningoperation。具体地说,每个方法都要创建并运行一个任务来执行工作并返回对该Task的引用。下面是doFirstLongRunningOperation方法的修改版本
private Task doFIrstLongRunningOperation()
{
	 Task t = Task.Run(()=>{/*将方法的原始玛放到这里"/});
	return t;
}
还要注意是否需要将 doFirstLongRunningOperation方法的工作分解成一系列并行操作。如果是,可以像前面描述的那样将工作分解成一组Task对象。但是,最后应该返回哪个Task对象?
private Task doFirstLongRunningOperation()
{
	Task first = Task.Run()=>{/*第一个操作的代码"/});
	Task second =Task.Run()=>{/*第二个操作的代码"/});
	return ...;//返回first还是second?
}
如返回first,slowMethod中的await操作符只等待那个任务完成,而不会等待第二个。返回second的问题一样。解决方案是将doFirstLongRunningoperation定义成 async方法并等待所有任务,如下所示:
private async TaskdoFirstLongRunningRperation()
{
	Task first = Task.Run(()=>{/*第一个操作的代码*/});
	Task second = Task.Run(())=>{/*第二个操作的代码+/});
	await first;
	await second;
}
记住,当编译器遇到await操作符时,会生成代码来等待实参指定的任务完成,并以延续的形式运行之后的语句。可认为 async 方法返回的就是对运行延续的那个Task 的引用(不完全准确,但有助于理解)。所以,doFirstLongRunningOperation方法创建并启动并行运行的finst和second任务。编译器重新格式化await语句,等待first完成,再用延续等待second完成。async修饰符造成编译器返回对该延续的引用。由于现在由编译器决定方法的返回值,所以不能手动指定返回值。（真的这样做的话,将无法编译)。
注意如async方法未包含任何await语句,方法就是一个Task引用,该任务执行方法主体中的代码。结果是调用方法时,它包含的代码实际并不异步运行。这种情况下,编译器会显示警告:"此异步方法缺少await操作符,将以同步方式运行".
提示 可为委托附加async前缓,创建用 await操作符集成异步操作的委托。
以下练习修改前面的GraphDemo 应用程序,使用异步方法生成图表数据。
修改 GraphDemo 应用程序来使用异步方法
1.打开"文档"文件夹下的Microsoft PressVCSBSIChapter24GraphDemo 子文件夹中的GraphDemo 解决方案。
2.在解决方案资源管理器中展开 MainPage.xaml节点,在"代码和文本编辑器"中打开 MainPage.xaml.cs 文件。
3. 在MainPage类中找到plotButton_Click方法,如下所示:
private void plotButton Click(object sender,RoutedEventArgs e)
{
	Random rand = new Random();
	redValue =(byte)rand.Next(0xfF);
	greenvalue =(byte)rand.Next(0xFF);
	bluevalue =(byte)rand.Next(0xFF);

	tokensource = new CancellationTokenSource(); 
	CancellationToken token = tokenSource.Token;

	Stopmatch watch =  Stopwatch.StartNew();

	try
	{
		generateGraphData(data,8,pixeldidth/2, token);
		duration.Text = $"Duration(ms):{watch.ElapsedMilliseconds}";
	}

	 catch(OperationCanceledException oce)
	 {
	 	duration.Text = oce.Message;
	 }

	 Stream pixelStream = graphBitmap.PixelBuffer.AsStream();
	 pixelStream.Seek(6,SeekOrigin.Begin);
	 pixelStream.Mrite(data,6,data.Length);
	 graphBitmap.Invalidate();
	 graphImage.Source = graphBitmap;
}
它直接在 UI 线程中调用 generateGraphData方法,不用Task对象并行生成图表数据。内存不足就减小 pixelWidth和pixelHeight。
4.在"调试"菜单中选择"开始调试"
5.在GraphDemo 窗口中点击Plot Grmph。生成数据期间试着点击Cancel。注意,在生成和显示图表期间,UI完全没了反应。这是由于plotButton_Click方法以同步方式执行其所有工作,包括生成图表数据。
6.返回Visual Studio并停止调试。
7.在"代码和文本编辑器"中显示MainPage类,在generateGraphData上方添加新的私有方法generateGraphDataAsync。该方法获取和generateGraphData一样的参数,但返回Task对象而非void.还要将方法标记为async,如下所示:
private async Task generateGiraphDatasync(byte[] data,
	int partitionstart,int partitionEnd,CancellationToken token)
	{
	}
注意 建议异步方法名都添加Async后缓。
8.在 generateGraphDataAsync方法中添加以下加粗的语句:
private async Task generateGiraphDatasync(byte[] data,
	int partitionstart,int partitionEnd,CancellationToken token)
	{
		Task= Task.Run()>generateGraphData(data, partitionStart,partitionEnd,
		token);
		await task;
	}
	上述代码创建 Task对象来运行generateGraphData方法,并用await操作符等待任务完成。方法的返回值就是编译器为await 操作符生成的任务
9.返回 plotButton_Click方法,更改方法定义来包含 async 修饰符,如加粗代码所示:
private async void plotButton_Click(object sender,RoutedEventArgs e)
{
	...
}
10.在 plotButton_Click方法的try块中修改生成图表数据的语句来异步调用generateGraphDataAsync方法,如加粗语句所示:
try
{
	await generateGraphDataAsync(data,6, pixelWidth/2,token);
	duration.Text= $"Duration(ms):{watch.ElapsedMilliseconds)");
}
...
11.选择"调试"|"窗口"|"异常设置"。在"异常设置"窗格中清除""Common Language Runtime Exceptions"复选框,右击"Common Language Runtime Exceptions"并启用"在用户代码中未经处理时继续"。这是为了防止调试器拦截System.OperationCanceledException异常.
12.在"调试"菜单中选择"开始调试"。
13.在Graph Demo 窗口中点击 Plot Graph,验证已正确生成图表。
14.点击PlotGraph,在数据生成期间点击Cancel。这次用户界面将快速响应,只生成部分图表。
15.返回Visual Studio并停止调试。

定义返回值的异步方法
之前的例子都是用Task对象执行不返回值的工作,但有时要求方法计算结果。为此可以使用泛型Task<TResult>类,类型参数TResult指定结果类型
Task TResult>对象和普通任务一样创建和开始。区别在于执行的代码要返回值。例如,下例的calculatevalue 方法生成一个整数结果。为了用任务调用该方法,要创建并运行一个Task<int>对象。获取返回值需查询Task<int>对象的Result属性。如任务启动的方法尚未运行完毕,而且结果不可用,Result属性将阻塞调用者。这意味着自己不必执行任何同步动作,即当Result属性返回一个值的时候,任务的工作就已经完成了。
Task<int> calculateValueTask Task.Run(() => calculateValue());
...
int calculatedData = calculateValueTask.Result;//阻塞至 calculatevalueTask完成
...
private int calculateValue(...)
{
	int someValue;
	//执行计算并填充someValue
	...
	return someValue;
}
返回值的异步方法也是基于泛型Task<TResult>类型来定义的。以前是通过返回一个Task来实现异步void方法。要生成结果的异步方法应返回一个Task<TResult>。下例创建 calculateValue方法的异步版本。
private async Task<int> calculateValueAsync(...)
{
	//用Task调用calculatevalue方法
	Task<int>generateResultTask= Task.Run(()=> calculatevalue(..
	await generateResultTask;
	return generateResultTask.Result;
}
这个方法让人有一点困惑,因为返回类型是Task<int>,而return语句返回int。记住,在定义async方法时,编译器会对代码进行重构,实际返回一个Task引用,该Task运行一个延续,延续的主体就是retumngenerateResultTask.Result;语句。延续返回的表达式类型是int,所以方法的返回类型是Task<int>。
为了调用返回一个值的异步方法,要使用await操作符,如下所示:
int result = await calculateValueAsync(...);
await操作符从 calculateValueAsync返回的Task中提取值并赋给 result变量。

异步方法注意事项
async和 await操作符常使程序员感到迷惑。以下是必须理解的几个重点。
用async修饰方法并不是说方法将异步运行,只是说方法可包含异步运行的语句。
await 操作符是说方法应该由一个单独的任务运行,调用代码暂停,直至调用完成。调用代码使用的线程被释放供重用。这对UI线程尤其重要,因为它使UI能保持灵敏响应。
使用 await操作符和使用任务的Mait方法不一样。wait方法总是阻塞当前线程,任务完成前不允许它被重用。
在await 操作符之后恢复执行的代码默认是获取当初调用异步方法的原始线程。如该线程繁忙,代码会被阻塞。可用ConfigureAwait(false)方法指定代码能在任何可用线程上恢复,减少被阻塞的机率。需处理成千上万个并发请求的Web应用程序和服务尤其需要这个功能。
如果await 操作符之后的代码必须在原始线程上执行,就不能使用ConfigureAwait(false)。在前面的例子中,如果为每个等待的操作添加ConfigureAwait(false),结果是可能在单独线程上运行编译器生成的延续,其中包括尝试设置message的Text属性的延续,再次造成异常:"应用程序调用一个已为另一线程整理"的接口。"
private async void slowMethod()
{
	await doFirstLongRunningoperation().ConfigureAwait(false);
	await doSsecondLongRunningoperation().ConfigureAait(false); await doThirdLongRunningoperation().ConfigureAwait(false); 
	message.Text ="ProcessingComplete";
}
草率使用返回结果的异步方法,而且在UI 线程上运行,那么可能造成死锁,使应用程序挂起。例如:
private async void myMethod()
{
	var data = generateResult();
	...
	message.Text = $"result:{data.Result}";
}
private async Task<string> generateResult()
{
	string result;
	...
	result = ...
	return result;
}
本例的 generateResult 方法返回字符串。但myMethod方法在访问data.Result属性时才会启动运行generateResult方法的任务。data是任务引用;如果由于任务尚未运行造成Result属性不可用,访问该属性将阻塞当前线程,直到generateResult方法完成。此外,用于运行 generateResult方法的任务会在方法完成时尝试恢复当初调用它的线程（UI线程),但该线程现已阳寒。结果就是myNethod方沬在generateResult完成前无法结束,而generateResult 方法在 myMethod 方法完成前无法结束。解决方案是等待运行generateResult方法的任务,如下所示
private async vold meMthod()
{
	var data = generateResult();
	...
	 message.Text = $"result:{await data}";
}

异步方法和 Windows Runtime API Windows 8 和后续版本的设计者想要尽量确保应用程序的可响应性,所以在实现WinRT时,决定任何50毫秒以上的操作都只能通过异步API进行。之前已见过这样的例子。例如,显示消息可以用MessageDialog对象。但显示时必须使用ShowAsync方法:
using Windows,UI.Popups;
...
MessageDialog dlg = new MessageDialog("Message to user");
await dlg.ShowAsync();

sageDialog对象显示消息并等待用户按 Close 按钮。任何形式的用户交互都会花费长短不一的时间(用户可能没有单击Close便跑开吃饭去了）,所以对话框显示期间切忌阻塞应用程序,或阻止它执行其他操作(如响应事件)。NessageDialog类没有提供ShowAsync方法的同步版本,但如果要同步显示对话框,可在不添加await操作符的前提下调用dlg.ShowAsync().
using Mndows.Storage;
using windows. Storage.Pickers;
...
FileOpenPicker fp = new FileOpenPicker();
fp.SuggestedstartLocation = PickerLocationId.DocumentsLibrary;
fp.Vieode = PLckerVieDde.List;
fp.FileTypeF1lter.Add("*");
StorageF1le flle = amait fp.PickSinglefFileAsync();
关键在于调用 PickSingleF1leAsync方法的那个语句。该方法显示文件列表,允许用户在文件系统中导航并选择文件(F1leOpenPicker类还提供了PickultipleFi1lesAsync方法来允许多选)。方法返回值是一个 Task<StorageF1le>,await操作符从结果中提取StorageF1le对象。StorageF1le类对磁盘文件进行抽象,可用它打开文件并进行读/写。
注意 PickSingleFileAsync方法严格说是返回 IAsyncOperation<StorageFi1le对象。WinRT有自己的异步操作抽象,并将.NETFramework的Task对象映射到该抽象;Task类实现了IAsyncOperation接口.用C#编程时,代码不受该转换的影响,可直接使用Task对象,不用关心它们幕后如何映射到WinRT的异步操作。
I/O也是耗时操作。StorageFile类实现了一大堆异步方法在不影响应用程序的可响应性的前提下执行这些操作。
SorageF1le file = await fp.PickSinglefleAsync();
...
var filesStream= await flle.0penAsync(FileAccessMode.Read);
你肯定注意到了,虽然报告的图表数据生成时间只有几秒,但图表实际显示前所经历的时间可能是报告的两倍。这是数据向位图的写入方式使然。位图渲染writeable8itmap对象的一个缓冲区中的数据,AsStream扩展方法为该缓冲区提供了Stream接口。数据通过该流由write方法写入缓冲区,如下所示:
...
Stream pixelStream = graphBitmap.PixelBuffer.AsStream(); 
pixelStream.Seek(e,SeekOrigin.Begin);
pixelStream.write(data,0,data.Length);
...
除非已减小了pixelWidth和pixelHeight字段的值来节省内存,否则写入缓冲区的数据量是570MB多一点(15000*10000*4字节),所以Write操作需要花几秒钟的时间。为了增强界面的可响应性,可用MriteAsync方法来异步执行该操作:
await pixelStream.WriteAsync(data,e,data.Length);
总之。构建Windows 应用程序时要尽量利用异步。

任务、内存分配和效率
方法作用是查找和一个string键关联的整数值。例如,可基于客户姓名检索客户ID,或基于包含加密键的字符串检索数据。FindValueAsync方法使用的是Cache-Aside模式,详情参见 https://docs.microsoft.com/en-us/azure/architecture/patterns/cache-aside.可能很耗时的计算或查找操作在本地缓存,以应对可能马上就要再次用到的情况。在后续FindvalueAsync调用中传递相同的键值,就能直接获取缓存的数据。该模式使用了以下辅助方法(方法的实现未列出)。
	GetCachedvalue 该方法在缓存中检查具有指定键的一个项,如存在就通过out参数传回该项。在缓存中发现数据,方法返回值是true;否则是 false。
	RetrieveValue 未在缓存中发现项就运行该方法。它执行必要的计算或检索,找到数据并返回之。由于该方法可能很耗时,所以异步执行。
	AddItemToLocalCache 该方法将指定项添加到本地缓存,以应对再次请求的情况。这样可防止应用程序必须再次执行昂贵的Retrievevalue操作。
理想情况下,缓存足以应对应用程序生存期内请求的大多数数据。调用RetrieveValue的次数应该越来越少。
下面来看看每次调用FindvValueAsync 方法发生了什么。大多数时候工作会同步执行（在缓存中找到了数据)。数据是整数,但包装到一个 Task<int>对象中返回。和直接返回int相比,创建和填充对象,当方法返回时从该对象中获取数据,这一套组合拳需要更多的计算时间和内存。C#的应对方案是提供ValueTask泛型类型。用它指定async方法的返回类型,造成返回值作为栈上的值类型封送,而不是作为堆上的引用。
public async ValueTask<dnt> FindValueAsync(string key）
{
	bool foundLocally = GetCachedValue(key,out int result);
	if(foundLocally)
		return result；
	result a await RetrleveValue(key);//possibly takes a long tim
		AddItemToLocalCache(key,
	return result;
}
但这并不是说ValueTask能永远代替Task。如异步方法要实际地执行await操作,ValueTask可能造成代码效率显著下降。限于时间和篇幅,这里就不解释具体原因了。原则上,只有对async方法的大多数调用都以同步方式执行,才考虑返回ValueTask对象:他时候使用Task类型。
注意  使用 ValueTask 类型需用 NuGet 包管理器在项目中添加 System.Threading.Tasks.Extensions包.
以前版本的.NET Framework 的IAsyncResult 设计模式早在NETFramework4.0引入Task类之前,人们就认识到了异步性在构建响应灵敏的应用程序时的重要性,Microsoft 引入了基于 AsyncCallback委托的IAsyncResult设计模式来应对这些情况。该模式的详情超出了本书范围,但从程序员的角度看,该模式的实现意味着.NETFramework类库的许多类型都要以两种形式公开长时间运行的操作:包含单个方法的同步形式,以及包含一对方法的异步形式.一对方法是BeginoperationName和EndoperationName.其中,OperationName是要执行的操作.例如,System.IO命名空间的MemoryStream类提供了Mrite方法向内存流同步写入数据,还提供了BeginMArite和EndNrite方法异步执行相同的操作,BeginMrite方法在新线程上发起写入操作.BeginNrite方法要求程序员提供对一个回调方法的引用,以便在写入操作完成后运行。该引用要采用AsyncCallback委托的形式.程序员要在这个方法中实现任何必要的清理工作,并调用Endwrite方法来表明操作完成。下例展示了这个模式。
...
Byte[]buffer =..;//填充要写入NemoryStream的数据
MemoryStream ms= new emoryStream();
AsyncCallback callback = new AsyncCallback(handleiriteCompleted);
ms.Beginikrite(buffer,0,buffer.Length,callback, ms);
...

private void handleWriteCompleted(IAsyncResult ar)
{
	MemoryStream ms = ar.AsyncState as MemoryStream;
	...//执行必要的理工作
	ms.Endarite(ar);
}
传回调方法的参数(handlkriteCompleted)是一个IAsyncResult对象,其中包含和异步操作的状态有关的信息以及其他状态信息。可通过该参数向回调传递用户自定义的信息,提供给BeginOperationName方法的最后一个实参被打包到该参数中。在这个例子中,向回调传递的是对MemoryStream的引用,虽然该模式可行,但过于繁琐,可读性也很差,一个操作的代码被拆分到两个方法中.以后维护时很难看出这些方法的联系.使用Task对象,可以调用TaskFactory类的静态FromAsync方法来进行简化.该方法获取BeginoperationName和EndOperationName方法,把它们包装到用Task执行的代码中.这样就不必创建AsyncCallback委托了,它由FromASync方法自动在幕后生成。所以,上个例子可以这样修改
...
Byte[] buffer ...;
MemoryStream s = new MemoryStream();
Task t = Task<int>.Factory.FromAsync(s.Beginwrite,s.Endwrite,buffer,0,buffer.Length,null);
t.Start();
await t;
...
人们用早期版本的.NETFramework开发了不少类型,为了使用它们公开的异步功能,有必要对这些技术有一定了解。

用PLINQ进行并行数据访问
数据访问是另一个要重点关注响应时间的领域,尤其是需要检索大型数据结构的时候。本书前面已演示过LINQ从可枚举数据结构中检索数据时的强大能力,但所用的例子都是单线程的。LINQ还提供了一组名为PLINQ(并行LINQ)的扩展,它基于Task,能并行执行查询来提高性能。
PILNQ的原理是将数据集划分成多个"分区",并利用任务以并行方式获取符合查询条件的数据。所有任务完成后,为每个分区获取的结果合并成一个可枚举结果集。如数据集含有大量元素,或查询条件涉及复杂的、昂贵的操作,PLINQ再合适不过。
PILNQ 的一个主要目标是尽量保持向后兼容,如果有大量现成的LINQ查询,肯定不想全部修改才能在最新版本的.NETFramework中运行。为了将现有的LINQ查询转换成PLINQ查询,可以使用扩展方法AsParallel。它返回一个ParallelQuery对象。该对象的行为和普通可枚举对象相似,只是为许多LINQ操作符(比如join和 where)都提供了并行实现。这些实现基于任务,会通过多种算法尝试以并行方式运行LINQ查询的不同部分。但和并行计算世界的其他地方一样,AsParallel方法并非万能。不能保证一用就加快速度:这完全取决于LINQ查询的本质及其执行的任务能否并行。
下面用两个例子说明PLINQ的工作机制及其适用情形。
用PLINQ增强遍历集合时的性能
第一个情形很简单。假定有一个LINQ查询遍历集合,并通过处理器密集型的计算从集合中获取元素。只要不同的计算相互独立,这种形式的查询就能从并行执行中获益。集合中的元素可划分为大量分区;确切的分区数量要取决于计算机的当前负荷以及可用的CPU数量。每个分区中的元素都可以由一个独立线程处理。所有分区都处理好之后,结果可合并到一起。任何集合只要允许通过索引访问元素,比如数组或者实现了IList<T接口的集合,都可以像这样处理。
并行化对简单集合的LINQ 查询
1.在 Microsoft Visual Studio 2017 中打开"文档"文件夹下的\MicrosoftPrss\VCSBS\Chapter24\PLINQ子文件夹中的PLINQ 解决方案。
2.在解决方案资源管理器中双击Program.cs,在"代码和文本编辑器"中显示它。这是控制台应用,主要结构已创建好。Program类包含Test1和Test2两个方法,演示了两种常见情形。Main方法依次调用每个测试方法。两个测试方法具有相同常规结构,都是创建一个LINQ查询(将在这一组练习中添加实际的代码),运行它,并显示所花的时间。每个方法的代码几乎完全独立于实际创建和运行查询的语句。
3.找到Test1方法。该方法创建一个大整数数组,用6～200的随机数填充。已为随机数生成器提供了固定种子值,所以每次运行应用程序都应该看到相同结果。
4.在该方法的第一条 TO D0注释之后添加以下加粗的LINQ查询:
// Create a LINQ query that retrieves all numbers that are greater than 100 var over100 = from n in numbers where TestIfTrue(n > 100)
	selcet n;
该LINQ查询从numbers 数组获取值大于100的所有项。n>100这个测试本身不是计算密集型操作,不足以演示并行查询的优势。所以代码调用TestIfTrue方法,通过执行一个 SpinMait操作来稍微延缓操作速度。SpinMat方法造成处
理器循环执行特殊的"无操作"(mo operation)指令,保持处理器"忙"于"什么事情都不做"一小段时间(即所谓的 Spinning,或称处理器"自旋")。下面是TestIfTrue方法的定义:
public static bool TestIfTrue(bool expr)
{
	Thread.SpinWait(100);
	return exper;
}
5.在Test1方法的第二个TO D0注释后添加以下加粗的语句:
//TO D0:Run the LINQ query,and save the results in a List <int > object
List <int> numbersOver100 = new List<int>(overl00)；
记住,LINQ查询使用了延迟执行机制,只有在实际获取结果时才会执行查询。该语句创建List<int>对象,在其中填充运行over198这个查询的结果。
6.在Test1方法的第三个TODO注释后添加以下加粗的语句:
//TO DO:Display the results 
Console.MriteLine($"There are{mumbersover100.Count) numbers over 100");
7.在"调试"菜单中选择"开始执行(个调试)"生成并运行应用程序。注意花了多少时间运行Test1以及数组中有多少项大于100.
8.多运行几次,记录平均时间。验证每次报告的大于100的数组元素的数量是相同的(应用程序用相同种子值确保测试的可重复性)。完成后,返回Visual Studio 2017.
9.LINQ查询返回每一项的逻辑独立于返回其他项,所以该查询适合进行"分区"。修改定义LINQ查询的语句,为numbers 数组指定ASParallel扩展方法,如加粗部分所示:
var over100 = from n in numbers.AsParallel()
		where TestIfrue(n>100)
		select n;
注意 如选择逻辑或计算方式要求访问共享数据,就必须对并发线程进行同步,否则会造成无法预料的结果.但同步会造成额外开销,可能使并行查询的优势荡然无存.
10.在"调试"菜单中选择"开始执行(不调试)"。验证Test1报告的项数和以前一样,但这次测试所花的时间显著缩短。多运行几次,记录平均测试时间。在双核机器上运行,时间会缩短40E??在更多核数的机器上运行,时间还会更短一些(我的四核电脑处理时间从8.3秒缩短至2.4秒)
11.关闭应用程序,返回Visual Studio。
上个练习证明了只需对 LINQ查询进行一处极小的改动,就能显著提升性能。但只有在查询需要大量CPU时间的时候,像这样的"改造"才最见效。我在这里实际是耍了一个花招,浪费了不少处理器时间却什么事情都没做。如果不假装要忙些别的什么事情,查询的并行版本实际会比顺序版本慢。下个练习将用一个LINQ查询联接内存中的两个数组。这个练习使用了更真实的数据源,所以不需要故意放慢查询速度。

并行化联接两个集合的查询
1.在"代码和文本编辑器"中打开Data.cs文件,找到CustomersInMemory类。该类包含名为Customers的公共字符串数组。Customers 中的每个字符串都容纳了一名客户的信息,不同字段以逗号分隔。经常要在文本文件中存储以逗号分隔的字段,并从应用程序中读取这种文本文件。第一个字段包含客户ID,第二个是客户公司名,其余字段容纳了地址、城市、国家/地区和邮编。
2.找到OrdersInMemory类。该类和 CustomersInMemory类相似,只是它包含名为Orders的字符串数组。每个字符串的第一个字段是订单编号,第二个是客户ID,第三个是下单日期,
3.找到OrdeInfo类。该类包含4个字段,容纳了客户ID、公司名称、订单ID和下单日期。将用一个LINQ查询在OrderInfo对象集合中填充来自Customers和Orders 数组的数据。
4.在"代码和文本编辑器"中显示Program.cs 文件,找到Program类中的Test2方法。要在该方法中创建一个LINQ查询,它通过客户ID联接Customers和Orders数组。查询将每一行结果都存储到一个OrderInfo对象中。
5.在方法的try块中,将以下加粗代码添加到第一个TO DO注释后面:
//TO DO;Create a LINQ query that retrieves customers and orders from arrays
//Store each rowu returned in an OrderInfo objec
var orderInfoQuery=from c in CustomersInMemory.Customers
					join o in OrdersInemory.Orders 
					on c.Split(',')[e]equals o.Splt(',')[1]
					select new OrderInfo
					{
						CustomerID c.split(',')[0],,
						Companyame =c. Split(',')[1],
						OorderID = Comvert.ToInt32(o.Split(',')[e]),
						OrderDate = Convert.ToDateTime(o.Split(',')[2],
							new CultureInfo("en-Lus")
					}
该语句定义LINQ查询。注意用String类的Split方法将每个字符串都分解成一个字符串数组。字符串在逗号位置分解,逗号本身会被删除。数组中的日期以USEnglish格式存储,所以将其转换成OrderInfo对象中的DateTime对象时,要指定US English格式化器。如果使用本地的默认格式化器,日期解析就可能出错。
6.在Test2方法中,在第二个TO DO注释后添加以下加粗的语句:
  //TO DO:Run the LINQquery,and save the results in a List<OrderInfo>object List<OrderInfo>orderInfo = newList<OrderInfo>(orderInfoQuery);
  该语句运行查询并填充 orderInfo 集合。
7.在第三个TO DO注释后添加以下加粗的语句:
	//TO D0:Display the results
	Console.MriteLine($"There are(orderInfo.count} orders");
8.在Main方法中注释掉调用Test1方法的语句,取消注释调用Test2方法的语句 如加粗的语句所示:
	static void Main(string[] args)
	{
		// Test1();
		Test2();
	}
9.在"调试"菜单中选择"开始执行(不调试)"。
10.验证Test2获取了830个订单,并记录测试时间。多运行几次,记录平均时间。 返回Visual Studio。
11.在Test2方法中修改LINQ查询,为Customers和Orders数组添加 AsParallel扩展方法,如加粗的部分所示:
var orderInfoQery = from c in CustomersIemory.Customers.AsParallel() 
					join o in OrdersIMemory.Orders.AsParallel()
					on c.Splt(',')[6]equals o.Ssplt(',')[1] 
					select new OrderInfo
					{
						CustomerID=c.Split(',')[0],
						CompanyName c. Split(',')[1],
						OrderID = Convert.ToInt32(o.Split(',')[e]),
						OrderOate = Corvert.TDateTime(o.split(',')[2],
							new CultureInfo("en-US"))
					};
注意 以这种方式联接两个数据源时,它们必须都是IEnumerable对象或者ParallelQuery对象.这意味着如果为第一个数据源指定 ASParallel方法,也应为另一个指定ASParallel方法,否则代码将不会运行——会报错并终止。
12.再次运行几次应用程序。注意,Test2所花的时间应该比上一次测试显著缩短。PLINQ可利用多个线程优化联接操作,能并行获取联接的每一部分的数据。
13.关闭应用程序,返回Visual Studio。
这两个简单的练习证明了ASParallel扩展方法和PLINQ的强大功能。然而,PLINQ是一个正在快速变革的技术,它的内部实现将来极有可能改变。另外,数据量和查询中执行的处理量也对PLINQ的效率有一定影响。因此,不应单靠这两个练习就总结出一套固定的规则。相反,应该在自己的环境中,针对自己的数据仔细权衡使用PLINQ所带来的性能或其他方面的优势。

取消PLINQ查询
和普通LINQ查询不一样,PLINQ查询是可以取消的。为此,需要指定来自CancellationTokensource的一个 CancellationToken 对象并使用 ParallelQuery的WithCancellation扩展方法
CancellationToken tok =...;
...
var orderInfoQuery =
	from c in CustomersIremory.Customers.AsParallel().Mithancellation(tok)
	join o in OrdersInenory.0rders.AsParallel()
	0n ...
	WithCancellation在查询中只能指定一次。取消会应用于查询中的所有数据源。如果用于生成CancellationToken的CancellationTokenSource对象被取消,查询就会停止,并抛出OperationCanceledException异常。
同步对数据的并发访问
PLINQ并非一定是应用程序的最佳技术。如手动创建自己的任务,需确保这些任务正确协调。NETFramework类库提供了可供等待任务完成的方法,可用这些方法实现比较粗糙的任务协调。但思考一下两个任务试图访问和修改相同数据会发生什么。如两个任务同时运行,重叠的操作可能破坏数据。由于不可预测,这种情况会造成很难纠正的 bug
Task类提供了强大的框架来帮助使用多个CPU内核并行执行任务。但执行并发操作一定要非常谨慎,尤其是需要共享访问相同的数据时。你对并行操作的调度方式几乎没有什么控制权,就连操作系统为使用任务来开发的应用程序提供的并行度都控制不了。这些决定都是由"运行时"来做的,具体取决于计算机的负荷和硬件。这个程度的抽象是由Microsoft 的开发团队做出的。正是因为这个原因,才使你在构建使用了并发任务的应用程序时,不需要理解低级的线程处理和调度细节。但这种抽象并非没有代价。虽然看起来能解决问题,但你必须对自己的代码的运行方式有一定程度的理解。否则,最后的结果可能是自己的应用程序的行为变得无法预测(甚至出错)
using System; 
using System.Threading;

class Program
{
	private const int NMELENENTS= 10;
	static vold Main(string[] args)
	{
		SerlalTest();
	}

	static void SerialTest()
	{
		int[]data = new int[NELEVENTS];
		int j =0;

		for(int i=0;1<NMELENENTS;i++)
		{
			j = i;
			doAdditionalProcessing();
 			data[i] = j;
			dooreAdditionalProcessing();
		}
		for(int i = 0;i<NUPNELENENTS;i++)
		{
			Console.WriteLine($"Element (1} has value(data[i]");
		}

	}
	static void donAdditionalProcessing()
	{
		Thread.Sleep(10);
	}
	static void doMoreAdditionalProcessing()
	{
		Thread.Sleep(10);
	}
}
SerialTest方法用一组值填充整数数组(以一种相当繁琐的方式),然后遍历并打印数中每一项的索引和值。作为处理过程的一部分,doAdditionalProcessing和doMoreAdditionalProcessing方法模拟执行长时间操作,这些操作可能造成"运行时"让出处理器的控制权。程序输出如下;
Element 0 has value 0
Element 1 has value 1
Element 2 has value 2
Element 3 has value 3
Element 4 has value 4
Element 5 has value 5
Element 6 has value 6
Element 7 has value 7
Element 8 has value 8
Element 9 has value 9
再来看看以下ParallelTest方法。该方法等同于SerialTest方法,只是它使用了Parallel.For构造,通过并发运行的任务来填充data数组。每个任务运行的Lambda表达式中的代码与SerialTest方法中的第一个for循环的代码是一样的。
using Systen.Threadig.Tasks;
...

static vold ParallelTest()
{
	int[] data = new int[NMELNENTS];
	int j =0;
	Parallel.For（0,NNELEENTS,(i)=>
	{
		j = 1;
		doAdditionalProcessing();
		data[1] = j;
		dororeAdditionalProcessing();
	});

	for(int i= 0;i<NUMELENTS;i++)
	{
		Console.WriteLine($"Element {1} has value (data[1]}");
	}
}
PrallelTest方法的目的是执行和SserialTest方法一样的操作,只是它使用的是并发任务,并希望能运行得更快一些。但问题在于,这样做并非总是获得预期的结果。下面展示了ParallelTest方法的一次示例输出:
Element 0 has value 1
Element 1 has value 1
Element 2 has value 4
Element 3 has value 8
Element 4 has value 4
Element 5 has value 1
Element 7 has value 8
Element 8 has value 8
Element 9 has value 9
为data数组的每一项赋的值并非总是和SerialTest方法生成的值一样。而且每次运行ParallelTest方法,都可能产生一组不同的结果。
检查paralell.For构造的逻辑就会发现问题出在哪里。Lambda表达式包含以下语句:
j = i;
doAddtionalProcessing();
data[i] = j;
dooreAdditionalProcessing();
代码看起来一点问题都没有。它将变量 1(索引变量,标识循环正运行到哪一次迭代)的当前值复制给变量了,后来又将j的值存储到索引为1的data数组元素中。如果1包含5,那么j就会被赋值5,稍后j的值被存储到data[5]中。但问题在于,在向j赋值和从中读取值之间,代码做了更多的工作;它调用了doAdditionalProcessing方法。如果这个方法花的时间较长,"运行时"可能挂起线程,并调度另一个任务。执行另一个迭代的并发任务可能将一个新值赋给j.结果就是当原始任务恢复时,赋给data[5]的j值已经不是当初存储下来的值。结果就是数据被破坏了。更麻烦的是,有时这样写的代码能按预期的那样工作,并生成正确的结果。但有时又生成错误的结果。这具体要取决于计算机当前有多忙,以及各个任务是在什么时候调度的。如果不注意,像这样的 bug会在测试期间潜伏起来,在生产环境中突然发作。
变量j由所有并发的任务共享。如果一个任务在j中存储了一个值,后又从中读取,就必须保证在此期间没有其他任务修改j。这要求在所有并发任务之间同步对变量的访问。一个解决方案是对数据进行锁定。
锁定数据
C#语言通过lock关键字提供锁定语义,以确保对资源的独占访问。lock 关键字像下面这样使用
object myLockObject = new object();
...
lock (myLockObject)
{
	//需要对共享资源进行独占访问的代码
	...
}
lock语句尝试在指定对象上获取互斥锁,注意,实际可用任何引用类型,而非只能使用object。如对象正由另一个线程锁定,它就会阻塞。线程获得锁之后,lock语句后面的代码块就会运行。在块的末尾,锁会被释放,如果另一个线程正阻寨并等待该锁,就可趁此机会获得锁并得以继续。

用于协调任务的同步基元
lock 关键字在许多简单情形中很有用,但有时有更复杂的需求。System.Threading命名空间包含大量额外的同步基元来满足这些需求。这些同步基元是和任务共同使用的类;它们公开了锁定机制,在一个任务获得锁的时候限制其他任务对资源的访问。它们支持大量锁定技术,可用来实现不同风格的并发访问,范围从简单的互斥锁(一个任务独占对资源的访问)到信号量（多个任务以一种受控的方式同时访问资源),再到 reader/iwriter锁(允许不同任务共享对资源的只读访间,需修改资源的线程则能获得独占访问权)。
下面总结了部分基元。更多信息和例子请参见MSDN文档。
注意 .NET Framework 从最早的版本开始便提供了丰富的同步基元,以下列表只包名System.Threading命名空间中的一些较新的基元,新基元和以前提供的有一定程度的重叠。应使用较新版本,因为它们是专为多处理器/多核 CPU设计和优化的。对所有同步机制的理论进行详细讨论超出了本书范围。要深入学习多线程和同步理论,请访问http://cn/RPAR2w和 htp://.cn/ReBv2g。
ManualResetEventSlim类
利用ManualResetEventSim类提供的功能,一个或多个任务可以等待一个事件。ManualResetEventSlim对象可以是两种状态之一:有信号(true)和无信号(false)。任务要创建一个ManualResetEventSlim对象并指定它的初始状态。其他任务可以调用Mait方法等待 ManualResetEventSlim对象收到信号。如果 ManualResetEventSllm对象处于无信号状态,wait方法就阻塞线程,另一个任务可以更改ManualResetEventSlim对象的状态,调用Set方法将ManualResetEventSlim对象的状态变成有信号。这个行动会释放在ManualResetEventSlim 对象上等待的所有任务,使其可以恢复运行。Reset 方法将
ManualResetEventSlim对象的状态变回无信号。
SemaphoreSlim类
可用SemaphoreSlim类控制对一个资源池的访问。SemaphoreSlim对象具有初始值(非负整数和一个可选的最大值。SemaphoreSlim对象的初始值一般是池中的资源的数量。访问资源的任务首先调用wait 方法。这个方法试图递减 SemaphoreSlim对象的值。如果值非零,就允许任务继续,并可从池中获取一个资源。完成后,任务应该调用SemaphoreSlim对象的 Release方法来递增信号量的值。
如果任务调用wait方法,而且对SemaphoreSlim对象的值进行递减会造成负值,任务就会等待,直到另一个任务调用Release。SemaphoreSlim类还提供了CurrentCount属性,可据此判断一个wait操作是有可自立即成功,还是有可能造成阻塞。
CountdownEvent 类
可将CountdownEvent 类看成是与信号量的行为相反的构造,而且它在内部使用了一个ManualResetEventSlim对象。任务创建CountdownEvent对象时要指定初始值(非负整数)。一个或多个任务能调用CountdownEvent对象的wait 方法。如果它的值非零,任务就会被阻塞。Mwait不递减CountdownEvent对象的值:相反,只有其他任务能调用Signal方法来递减值。一旦CountdownEvent对象的值抵达e,所有阻塞的任务都会收到信号,可以恢复运行。任务可用Reset方法将CountdownEvent对象的值重置为在其构造器中指定的值。任务可调用AddCount方法增大该值。可检查CurrentCount属性判断一个 wait 调用是否可能阻塞。
ReaderwriterLockSlim类
ReaderwriterLockSlim类是一个高级同步基元,它支持单个writer和多个 reader。基本思路是,对资源的修改(写入)要求独占访间,但读取不需要。因此,多个 reader 能同时访问相同的资源。
读取资源的任务调用ReaderwriterLockSlim对象的EnterReadLock方法。该操作会获取对象上的读取锁。线程结束资源访问之后,就调用ExitReadLock方法释放锁。多个线程可同时读取相同的资源,每个线程都获得自己的读取锁。

要修改资源,任务可调用同一个 ReaderwriterLockSlim对象的EnterwriteLock方法来获取写入锁。如果一个或多个任务当前拥有该对象的读取锁,EnterwriteLock方法就阻塞,直到它们全部释放。获得写入锁之后,任务可修改资源,并在完事儿之后调用ExitMriteLock方法释放写入锁
ReaderwriterLockSlim对象只有一个写入锁。如果另一个任务也试图获取写入锁,就会阻塞,直到第一个任务释放写入锁为止。
为确保写入线程不会被不确定地阻塞(老是有"插队"读取的情况),一旦某个线程请求了写入锁,后续所有EnterReadLock调用都会被阻塞,直至写入锁被获取并释放。

Barrier类
Barrier类允许在应用程序特定位置临时暂停执行一组任务,只有在所有任务都到达这个位置之后,才允许继续。可用它对执行一系列并发操作的任务进行同步,从而在算法的不同阶段推进。
任务创建Barrier对象时要指定集合中要同步的线程数。可将该值想象成Barrier类内部维护的一个任务计数。以后可调用 AddParticipant或者RemoveParticipant方法修改该值。当一个任务抵达一个同步点时,就调用Barrier对象的SignalAndwait方法,从而递减Barrier对象内部的任务计数。计数器大于零,任务就被阻塞。只有计数器变成e之后,在Barrier对象上等待的所有任务才会被释放并继续运行。
Barrier 类提供 ParticipantCount 属 性来指定参与同步的任务数;还有ParticipantsRemaining属性来指出还有多少个线程需调用SignalAndwait,才能升起栅栏并让阻塞的任务继续。
还可在Barrier构造器中指定委托,所有线程都抵达栅栏时,该委托引用的方法就会运行。Barrier对象作为参数传给方法。只有方法完成后才升起栅栏并让任务继续。

取消同步
MaualResetEventSlim,SemaphoreSlim,CountdownEvent和Barrier类都支持前面描述的取消模型。每个类的等待操作都能获取可选的CancellationToken参数（即取消标志,它从一个CancellationTokenSource 对象获得）。一旦调用CancellationTokensource对象的Cancel方法,引用了CancellationToken的所有等待操作都会终止,并抛出 OperationCanceledException 异常(该异常可能包装到一个AggregateException中,具体取决于等待操作的上下文)。
以下代码演示了如何调用一个 SemaphoreSlim对象的wait方法并指定取消标志。如等待操作被取消,OperationcanceledException的异常处理程序就会运行。
CallationTokenSource cancellationTokensource = new CancellationTokensource();
CancellationToken cancellationToken = cancellationTokerSource.Token;
...
//该信号量保护一个资源也(池中有3个资源）
SemaphoreSlim semaphoreSlim- new Semaphoreslim(3);
try
{
	semaphoreslim.Mait(cancellationToken);
}
catch(OperationCanceledException e)
{
	...
}
并发集合类
许多线程应用程序都要求用集合来存储和获取数据。.NETFramework提供的标准集合类默认不是线程安全的。虽然可用之前描述的同步基元添加、查询和删除集合元素的代码包装起来,但是过程容易出错,伸缩性也不佳。.NET Framework 在System.Collections.Concurrent命名空间提供了几个线程安全的集合类和接口,它们基
于任务而设计。下面进行了简单总结。
ConcurrentBag<T>是常规用途的类,用于容纳无序的数据项集合。它包含了用于插入(Add)、删除(TryTake)和检查(TryPeek)数据项的方法。这些方法线程安全。集合可枚举,可用 foreach 语句遍历。
ConcurrentDictionary<TKey,TValue>实现了泛型Dictionary<TKey,TValue>集合类的线程安全版本。提供了 TryAdd,ContainsKey,TryGetvalue,TryRemove和 Tryupdate等方法,可添加、查询、删除和修改字典中的项。
ConcurrentQueue<T>实现了第18章描述的泛型 Queue<T>类的线程安全版本。提供了Enqueue,TryDequeue和TryPeek方法,可添加、删除和查询队列中的项。
ConcurrentStack<T>实现了泛型 Stack<T>类的线程安全版本。提供了Push,TryPop和TryPeek等方法,以进行入栈、出栈和查询操作。
注意 为集合类的方法添加线程安全性会带来额外的运行时开销,所以这些类和普通集合类相比会慢一些,决定是否要对一组访问共享资源的操作进行"并行化"时,一定要考虑到这个事实。

使用并发集合和锁实现线程安全的数据访问
下面的一组练习将实现一个应用程序,通过一个统计采样算法计算PI。最开始以单线程方式执行计算。然后修改代码,使用并行任务执行计算。在此过程中,会遇到一些数据同步问题,并练习用并发集合类和锁来解决问题,确保正确协调任务。这里用来计算PI的算法基于一些简单的数学计算和统计学采样。先画半径为r的圆,再画一个外切正方形,它的四个边和圆相切。因此,正方形边长为2*r,正方形面积S像下面这样计算:
S=(2*r)*(2*r)
或者
S=4*r*r
圆的面积C像下面这样计算:
C = PI*r*r
根据上述公式得出以下结论:
r*r=C/PI
以及:
r*r=S/4
所以:
S/4=C/PI
所以可以像下面这样计算PI:
PI=4*C/S
难点在于判断 C/S比值是多少。这就要用到统计学采样了。可以生成一组随机点,它们均匀分布在正方形中,同时统计有多少点落在圆内。如随机样本足够多,落在圆中的点和总共生成的点的比值就是两个形状的面积比值,即C/S。而你唯一要做的就是计数。
那么,怎样判断一个点是否落在圆内呢?为了帮助你理解解决方案,请在一张坐标纸上画一个正方形,正方形中心是原点(0,0)。然后,可以生成范围在(-r,-)到(+r,+r)的坐标,这些点肯定在正方形内。为了判断任何一个坐标(x,y)是否同时在圆内,可计算这个坐标所代表的点到原点的距离。根据勾股定理,距离d=(x*x)+(y*y)的平方根。如果d小于或等于r,则坐标(r,y)代表的点就在圆内。
该算法可进一步简化,只生成右上象限的坐标,也就是在生成坐标时,将随机数的范围限制在0～r之内。本练习将采用这个思路。

注意 单核CPU无法体验到单线程和多线程方案的不同。另外,练习之间不要启动额外的程序或服务,否则也会影响效果．
用单线程计算PI
1.如Microsoft Visual Studio2017尚未启动,请启动。
2.打开"文档"文件夹中的MicrosoftPress\VCSBS\Chapter24\CalculatePI子文件夹中的CalculatePI解决方案
3. 在解决方案资源管理器中,双击Programcs在"代码和文本编辑器"中显示它。
这是控制台应用程序。主干结构已创建好了。
4. 滚动到文件底部,查看Main方法。
static void Nain(string[] args)
{
	double pi = SerialPI();
	Console.WriteLine($'Georetric approximation of PI calculated serlally:{pl}");

	Console.writeLine();
	//pi = ParallelPI()
	// Console.wrltelLine($Geometrlc aproxdination of PI calculated in parallel:{pl}");
}
上述代码调用 SerialPI方法,该方法使用刚才描述的统计采样算法计算PI。值作为double返回并显示。代码目前注释掉了ParallelPI方法调用,它执行相同的计算,但使用并发任务。结果应该和SerialPI方法一样。
5.检查 SerialPI方法。
static double SerlalPI()
{
	List<double> pointsList = new List<double>();
	Random random = new Random(SEED); 
	int numPolntsInCircle = 0;
	Stopwatch tlmer = new Stopwatch()
	timer.Start();

	try
	{
		//TO DO:Implement the geometric approximation of PI
		return 0;
	}
	finally
	{
		long milliseconds= timer.ElapsedNLlliseconds;
		Console.wrlteLine($"SerialPI complete:Duration:(millscconds}ms",);
		Console.MriteLine($"Points in pointsList:{pointsList.Count).Points within circle
		{numPointsInCircle)");
	}
}
该方法会生成大量坐标,并计算每个坐标到原点的距离。集合大小由常量NMPOINTS指定(位于Program类的顶部)。这个值越大,坐标集合越大,计算出来的PI值越准确。如内存充足,可试着增大NUMPOINTS的值。类似地,如应用程序
开始抛出OutOfMemoryException异常,就应减少该值,每个点到原点的距离存储在pointsList这个List<double>集合中。坐标数据用random变量生成。这是一个Random对象,种子值是常量,所以应用程序每次运行都会生成同一组随机数。(目的是帮助你判断程序正确运行。)如果愿意,可以在Program类的顶部更改SEED常量。numPointsIncircle变量用于统计 pointsList 集合中落在圆内的点数。圆的半径由 Program类顶部的RADIUS常量指定。为了方便比较这个方法和 ParallelPI
方法的性能,代码创建了名为timer的Stopwatch变量并启动它。finally块判断计算花了多少时间,并显示结果。出于稍后会讲到的原因,finally块还负责显示pointsList集合总共有多少数据项,以及落在圆中的点数。下面几个步骤将在try块中添加代码来执行计算。
6. 在try块中删除注释和 return语句。（提供这个语句的目的只是为了能够编译。)在try块中添加以下加粗的 for循环:
try
{
	for(int points = 0;points <NUMPOINTS;points++)
	{
		int xCoord = random.Next(RADIUS);
		int yCoord = random.Next(RADIUS);
		double distanceFromOrigin = Math.Sart(xCoord *XCcoord＋ yCoord * yCoord);
		pointsList.Add(distanceFromOrigin);
		doAdditionalProcessing();
	}
}
这个代码块生成一对～RADIUS的坐标值,并将它们存储到xCoord和yCoord变量。然后利用勾股定理计算它们代表的点到原点的距离,将结果(一个 double 类型的距离值)添加到 pointsList 集合。
注意  虽然这个代码块执行的计算有点多,但真正的科学计算应用程序通常包含更复杂的计算,处理器忙的时间更长．为了模拟这种情况,代码块调用了另一个名为doAdditionalProcessing的方法。该方法唯一的作用就是"干耗"一定数量的CPU周期,如以下代码所示。这是为了在演示多个任务的数据同步需求时,不必真的通过执行复杂计算(比如执行快速傅里叶变换或称 FFT)来保持CPU忙碌:
private static void doAditionalProcessing()
{
	Thread.SpinMait(SPINWAITS);
}
SPINNAITS也是在 Program类顶部定义的常量。
7.在 SerialPI方法的try块中,在for块之后添加以下加粗的foreach 语句:
try
{
	for(int points = 8;points<NPOINTS;polnts+t)
	{
		...
	}
	foreach（double datum in pointsList)
	{
		if(datum <= RADIUS
		{
			numPodntsInCircle++;
		}
	}
}
上述码遍历pointsList 集合,依次检查每个距离值。如值小于或等于圆的半径,就递增numPointsInCircle变量。循环结束后,numPointsInCircle包含的就是落在圆中的点的总数。
8.为try块添加以下加粗的语句,把它放到 foreach块的后面:
try
{
	for(int podnts ■ 6;points< NNPOINTS;points+)
	{
		...
	}

	foreach（double datum in pointsList)
	{
		...
	}
	double pf = 4.0*numPointsInCircle/MNPOINTS;
	return pi;
}
第一个语句根据圆内的点数和总点数的比值来计算PI,公式已在本节开头介绍过。PI值作为方法的结果返回。
9.在"调试"菜单中选择"开始执行(不调试)"。
注意 你的机器显示的PI值应该和图中显示的PI值相同(计时自然不同),除非你更改了NUMPOINTS,RADIUS或SEED常量。
10.关闭控制台窗口,返回Visual Studio

在SerialPI方法中,研究一下for循环的代码,会发现用于生成点和计算到原点的距离的代码很适合"并行化"。下个练习将演示具体做法
使用并行任务计算PI
1.在"代码和文本编辑器"中显示 Program.cs的内容。
2.找到 ParallelPI方法。它包含和 SerialPI方法最开始时(没有在try块中计算PI时）完全一样的代码。
3.在try块中删除注释和 return 语句。添加以下加粗的Parallel.For 语句:
try
{
	Parallel.For（0,NUMPOINMTS,(x)=>
	{
		int xCoord = random.Next(RADIUS);
		int yCoord = random.Next(RADIUS);
		double distanceFromOrigin a Math.sqrt(xCoord *xCoord+ yCoord * yCoord);
		pointsList.Add(distanceFromOrigin);
		dodditionalProcessing();
	});
}
这是SerialPI方法中的 for循环的并行版本。原始for循环主体包装在一个Lambda表达式中。这样每次循环迭代都可以用一个任务来进行,而任务可以并行运行。具体的并行度要取决于处理器内核数量以及其他资源的可用情况
4.将以下加粗的代码添加到 try 块的 Parallel.For语句之后。这些代码和SerialPI方法中对应的语句完全相同
try
{
	Parallel.For(...
	{
		...
	});
	foreach(double datum in pointsList)
	{
		if(datum =< RADIUS)
		{
			numPointsInCircle++;
		}
	}
	double pi=4.6*numPointsInCircle /NUMPOINTS;
	return pi;
}
5.在 Program.cs 文件末尾的Main方法中,取消注释 ParallelPI方法调用和显示结果的Console.MriteLine 语句。
6.在"调试"菜单中选择"开始执行(不调试)"
SerialPI方法的结果和以前完全一样。但ParallelPI方法的结果令人不解。随机数生成器取的是相同种子值,所以应生成相同的随机数序列,落在圆中的点数应该一样。另一个疑点是,ParallelPI方法的pointsList集合包含的点数(实际是距离值的数量)要比 SerialPI方法中的集合包含的点数少。

注意 如pointsList集合包含点数和以前一样,请试着再运行一次应用程序,大多数时候,它包含的数据项都少于以前
6. 关闭控制台窗口,返回VisualStudio.
那么,并行计算哪里出了问题?为了调查错误根源,一个很好的起点是 pointsList集合中数据项的数量。集合是泛型 List<double>对象。但这个类型不是线程安全的。Parallel.For语句中的代码调用Add方法向集合追加一个值,但要记住,这个代码是由并行的任务执行的。后果就是一些Add调用相互干扰,造成数据被破坏。一个解决方案是使用System.Collections.Concurrent命名空间中的一个并发集合类,这种集合是线程安全的。其中,泛型ConcurrentBag<T类可能最适合目前这种情况。
使用线程安全的集合
1．在"代码和文本编辑器"中显示Program.cs 的内容。
2.在文件顶部添加以下 using指令:
using System.Collections.Concurrent;
3. 找到 ParallelPI方法。在方法起始处,将实例化 List<double>集合的语句替换成创建ConcurrentBag<double>集合的语句,如加粗的语句所示:
static double ParallelPI()
{
	ConcurrentBag<double> pointsList = new ConcurrentBag<double>();
	Random random =...；
}
注意,不能为该类指定默认容量,所以构造器不获取参数。
需要修改方法的其他代码;还是用Add方法向ConcurrentBag<T>集合添加项,这和List<T>集合一样。
4.在"调试"菜单中选择"开始执行(不调试)"
随后将运行程序,并使用 SerialPI和 ParallelPI方法分别显示 PI的近似值。
这次 ParallelPI方法中的 pointsList 集合包含正确数量的点(实际是一些距离值)。但落在圆中的点数仍然非常高;它本应和 SerialPI方法报告的点数一样。
还要注意,ParallelPI 方法现在花的时间比上一个练习多。这是因为ConcurrentBag<T>类中的方法必须对数据进行锁定和解锁来确保线程安全性。这个过程增大了调用方法的开销。这证明了在考虑对一个操作进行"并行化"时,必须考虑到随之而来的开销。
5.关闭控制台窗口,返回Visual Studio.
现在,pointsList集合中的点的数量正确了,但这些点的值令人生疑。Parallel.For构造中的代码调用Random对象的Next方法,但和泛型类 List<T>的方法一样,这个方法不是线程安全的。遗憾的是,Random类没有提供个并发版本,所以必须采用其他披术固定 Next方法的调用顺序。由于每个调用都相当短暂,所以可考虑用一个锁来保护对这个方法的调用。

用锁来序列化方法调用
1.在"代码和文本编辑器"中显示Program.cs 的内容。
2. 找到 ParallelPI方法,修改 Parallel.For 语句中的Lambda表达式,用lock语句将对 random.Next的调用保护起来。将 pointsList集合指定为lock的目标,如加粗的语句所示:
static double ParallelPI()
{
	...
	Parallel.For(0,NMPOINTS,(x)=>
	{
		int xCoord;
		int yCoord;

		lock(pointsList)
		{
			xCoord = random.Next(RADIU5S);
			yCoord= random.Next(RADIUS);
		}
		double dstanceFromOrigin Math.Sort(xCoord *xCoord ＋yCoord * yoord); 
		pointsList.Add(distancefromOrigin)
		doAdditionalProcessing();
	});
	...
}
注意,XCoord和 yCoord变量在lock语句外部声明。这是由于lock语句定义了它自己的作用域,块内定义的变量在退出块后消失
3.在"调试"菜单中选择"开始执行(不调试)"。
4.关闭控制台窗口,返回Visual Studio。

实现 UWP应用的用户界面
理解典型 UWP应用的特色
为UWP应用实现可伸缩的用户界面,以适应不同屏幕大小和方向;
为UWP应用创建并应用样式
Windows的最新版本引入了一个构建和开发高度交互式应用程序的平台,实现了一直连接、触摸驱动并支持嵌入传感器的用户界面。升级的应用程序安全性和生存期模型改变了用户和应用程序的互动方式。该平台就是本书一直有所提及的WindowsRuntime(WinRT)。可用VisualStudio开发能适应从平板电脑到台式机的多种设备的WinRT应用程序。从Windows 8/8.1和Visual Studio 2013开始,可在Windows 商店中将这些应用程序作为"WindowsStore应用"发布。

另外,可单独使用在Visual Studio 中集成的WindowsPhoneSDK8.0设计和实现在WindowsPhone8设备上运行的应用程序。这些应用程序在许多地方都和平板和桌面应用程序相似,但在一个更具限制的环境下工作。这种环境常常资源有限,并需支持不同UI布局。因此,Windows Phone8应用程序使用的是WinRT的一个不同的版本,称为Windows PhoneRuntime。可将Windows Phone 8应用程序作为Windows Phone Store 应用发布到商店。还可使用VisualStudio 提供的Portable Class Library模板创建类库,以便在Windowds 平板/桌面应用程序和WindowsPhone8应用程序之间共享应用程序和业务逻辑。但WindowsStore 应用和Windows Phone Store 应用截然不同,它们实现的功能完全不一样。

再往后,Microsoft寻求统一这些平台并减少差异。该策略在Windows 10上通过"通用Windows 平台"应用得以贯彻。这种应用使用WinRT的一个修改版本,称为"通用Windows 平台"(Universal Windows Platform,UWP)。UWP应用可在多种Windows10设备上运行,不需要维护单独的代码库。不仅手机、平板和台式机,就连Xbox也支持UWP。

注意 UWP定义了一组核心特性和功能。UWP将设备划分为多种设备家族:桌面设备家族、移动设备家族和Xbox设备家族等等。每个设备家族都定义了一组API和 用于实现这些API的设备。另外,通用设备家族定义了所有设备家族都支持的一 组核心特性和功能,每个设备家族的库都包含条件方法,允许应用检测它当前在什么设备家族上运行.
介绍UWP的基础概念,帮你开始用Visual Studio 2017构建在这种环境下工作的应用。将介绍Visual Studio 2017为构建UWP应用而提供的新功能和工具。将实际构建一个具有Windows10外观和感觉的UWP应用。重点解释如何实现易于伸缩的用户界面来适应不同的设备分辨率和屏幕大小,以及如何通过应用样式为应用程序赋予不同的外观和感觉。之后各章将专注于应用的功能和其他特色。

UWP应用的特点
今天的手持和平板设备允许通过触摸与应用交互,UWP应用的设计也要基于这种形式的用户体验。Windows10提供了丰富的触屏控制:如使用的不是触摸屏,也支持用鼠标和键盘来操作。但应用程序不需要分开提供触摸和鼠标功能;只需围绕触摸来设计。如用户更愿意使用键鼠,或设备不支持触摸,仍可正常操作。
GUI通过对手势的响应向用户提供视觉反馈,从而大幅增强应用程序的专业性。VisualSudio2017提供的UWP应用模板包含一个动画库,可用它在自己的应用程序中标准化动画反馈,在风格上实现与Microsoft操作系统和自带软件的统一。
注意 "手势"是指用手指执行的各种触摸操作,例如,可手指"点击",效果等用鼠标点击,但是,手势能做的事情比鼠标多得多,例如,两个手指在屏幕上转动可以实现"旋转".在典型的Windows10应用中,该手势造成选中的项目朝转动方向旋转。其他手势还有"捏放"来进行缩小或放大,"长按"显示项目的更多信息(类似鼠标右键点击),"滑动"拖动项目。
UWP的设计目标是在大范围设备上运行。这些设备具有不同屏幕大小和分辨率。所以在实现UWP应用时,需让它适应运行环境,能根据屏幕大小和方向自行调整。这样你的软件才能面向更大的市场。此外,许多现代设备都能通过内置的传感器和加速计来检测方向和加速度。UWP应用能在设备发生倾斜或旋转后调整布局,使用户随时都能以舒适的方式工作。另外,移动性是许多现代应用程序的核心要求,UWP应用允许用户漫游。他们的数据任何时候都能从云端迁移到当前所用设备
。
UWP应用的生存期也有别于传统桌面应用程序。在智能手机等设备上运行时,当用户将焦点切换到其他应用时,你的应用应该能暂停执行,并在焦点返回时恢复运行。这有助于节省资源和延长电池寿命。事实上,Windows可能在发现系统资源(如内存)不足时关闭挂起的应用。应用下次运行时,应该能从之前离开的位置恢复。这意味着需要在代码中管理应用的状态信息,把它保存到磁盘,并在需要时恢复。
注意 要进一步了解如何管理UWP应用的生存期,请参考"启动、恢复和后台任务"(https:/msdn.microsoftcom/library/windows/apps/h46508.aspx)
开发好新的UTWP应用之后,可用VisualStudio2017提供的工具打包并上传到Windows应用商店供消费者下载和安装。应用可收费,也可免费。这种分发和部署机制的前提是你的应用必须可信,且符合Microsoft的安全策略。应用上传到Windows 应用商店后,会经过一系列检查来验证它不含恶意代码,并符合UWP应用的安全要求。这些安全限制规定了应用如何访问计算机上的资源。例如,UWP应用默认不能直接向文件系统写入或侦听网络的入站请求(病毒和其他悉意软件的两种常见行为)。但如果确实需要执行这些受限操作,可在应用的Package.appxmanifest 文件的清单数据中把它们指定为功能。这些信息会记录到应用的元数据中,并通知Microsoft执行额外的测试来验证应用使用这些功能的方式。
Package.appxmanifest文件是XML文档,但可以在VisualStudio中使用清单设计器来编辑,如下图所示。其中,"功能"标签页指定的就是应用程序能执行的受限操作。
注意 要进一步了解 UWP 应用支持的功能,请参考"应用功能声明",网址为
htps:/docs.microsof.com/h-cn/windowshinwp/packaging/app-capability-declarations
在这个例子中,应用程序声明它需要执行以下任务。
从Intemet接收入站数据,但不能作为服务器,也不能访问局域网。
访问GPS信息来了解设备位置。
读写用户"图片"文件夹中的文件。
它会醒用户注意这些要求,用户也可在应用安装好之后禁用设置。所以,应用程序必须能检测这种情况,准备好采用替代方案或完全禁用这些功能。理论上的东西足够多了,下面开始构建UWP应用。

使用空白模板构建UWP应用
构建UWP应用最简单的方式就是使用VisualStudio2017在Windows10上自带的模板。本书之前的许多GUI应用程序都使用了"空白应用"模板。它是一个很好的起点。
以下练习将为虚构的AdventureWorks公司设计和实现一个简单应用的UI。公司制造并销售自行车及相关用品。该应用允许用户输入和修改Adventure Works的客户细节。
创建Adventure Works Customers 应用
1.启动Visual Studio 2017
2. 在"文件"菜单中选择"新建"|"项目"。
3、在左侧窗格展开"VisualC#",单击"Windows 通用"。
4.在中间窗格选择"空白应用(通用Windows)"。
5.在"名称"文本框中输入Customers。
6. 在"位置"中指定"文档"文件夹下的Microsoft Press\VCSBS\Chapter25子文件夹。
7.单击"确定"。
8.在随后出现的对话框中接受目标版本和最低版本的默认值。单击"确定"。
	随后会新建应用并显示"概述"页,其中包含一些链接,指导你开始创建、配置和部署UWP应用。
9.在解决 在解决方案资源管理器中双击MainPage.xaml。
随会在设计视图中显示空白页。可从工具箱拖放各种控。本练习将重点放在定义窗体布局的XAML标记上面,如下所示。
<Page
	x:Classa"Customers.NainPage"
	xmlns="http://schemas.microsoft.com/wdinfx/206/xaml/presentation"
	xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" 
	mlns:local="using:Customers"
	xmlns:d="http://schemnas.microsoft.com/expression/blend/2008"
	xmlns:mc="http://schemas.openvmlformats.org/markup-compatibility/2006"
	mc:Ignorable="d"
	Background="{ThemeResource ApplicationPageBackgroundThemeBrush}">
	<Grid>
	</Grid>
</Page>
窗体以XAML标记<Page>开头,以</Page>结束。之间的一切定义了页面内容。
<Page>标记的属性包含许多 xmlns:id = "_"。"形式的声明。这些是XAML命名空间声明,工作方式类似于C#的using指令,都是将项带入作用域。添加到页面的许多控件和其他项都是在这些XAML命名空间中定义的,目前可忽略大多数声明。但有一个看起来很奇特的声明要注意:
xmlns:local="using:Customers"
该声明将C#Customers 命名空间中的项带入作用域,使开发人员能在自己的XAML 代码中通过附加local前缀的方式引用该命名空间中的类和其他类型。Customers命名空间是为当前应用的代码生成的命名空间。
10.在解决方案资源管理器中展开 MainPage.xaml,双击MainPage.xaml.cs 显示它。
11.以前的练习说过,该 C#文件包含应用程序逻辑和事件处理程序,如下所示(省略顶部的using指令以节省篇幅):
//https:/go.mcrosoft.com/fwlink/PLinkId-4e2352&clcid-ex884 上介绍了"空白页"项模板
nanespace Customers
{
	///<summary>
	///可用于自身或导航至 Frame 内部的空白页
	///</summary
	public sealed partial class MainPage:Page
	{
		public MainPage()
		{
			this.Initializecomponent();
		}
	}
}
文件定义了Customers命名空间中的类型。页由名为MainPage的类实现,该类派生自Page类。Page类实现了UWP应用的XAML页面的默认功能,所以开发人员只需在MainPage类中实现自己的应用程序的特有功能。
12.返回设计视图。查看该页的XAML标记,注意<Page>标记包含以下属性;
x:Class"Customers.MainPage"
该属性将定义页面布局的XAML标记连接到提供应用程序逻辑的MainPage类。
这便是简单UWP应用的基本结构。当然,图形应用程序最吸引人的还是它向用户展示信息的方式。但这并非总是想象的那么简单。设计吸引人的、易于使用的图形界面要求专业技能,不是所有开发人员都能掌握(我自己就没有)。但是,有这些技能的许多图形艺术家并不是程序员,所以他们虽然能设计出色的UI,但实现不了让它变得真正有用的逻辑。
幸好,Visual Studio2017允许将界面设计与业务逻辑分开。这样艺术家和程序员就能合作开发又酷又好用的应用了。程序员只需关注应用的基本布局,样式什么的交给艺术家。

实现可伸缩用户界面
进行UWP应用的UI布局时,最关键的就是理解如何使它具有伸缩性,能适应不同的屏幕大小。以下练习将展示如何实现伸缩性。
布局Customers 应用页面
1.注意,在设计视图顶部的工具栏中,可利用下拉列表选择设计平面的分辨率和大小,还有一对按钮为支持旋转的设备选择横向或纵向(平板和手机支持,桌面、Xbox、Surface Hub、loT设备和HoloLens 设备不支持)。可利用下图所示的这些选项快速查看UI在不同设备上的表现。默认布局是横向13.5寸SurfaceBook屏幕。该规格不支持纵向模式。
2. 从下拉列表选择8"Tablet(1280×800)。这是支持旋转的平板规格,横向和纵向模式均可用。
最后选择13.3"Desktop。这是我们最终为Customers 应用程序选择的尺寸规格。默认横向。
注意：设计视困显示的页面可能过小或过大,利用窗口左下方的"缩放"下拉列表调整到舒适状态即可。也可利用Cr+鼠标滚轮来调整
3.在Visual Studio 中查看MainPage页的XAML标记。其中包含一个属性设置:
	Background="{ThemeResource AoplicationPageBackgroundTheeBrush}"
注意 Background属性如何指定目前并不重要,这是使用样式的一个例子。
为了构建可伸缩的、灵活的用户界面,有必要理解Grid控件的工作原理。Page元素只能包含一个项,如愿意可将Grid控件替换成Button,如下所示。
<Page
	...
	<Button Content="Click Me"/>
</Page>
注意 不要输入以上代码,它纯粹是为了演示。
但这样会使应用程序变得没什么用——窗体只包含一个按钮,其他什么都不显示。如添加第二个控件(比如TextBox),代码将不能编译,显示如下图所示的错误,rid控件的作用是允许在页上添加多个项。Grid是容器控件,可在其中包含其他大量控件,而且可指定其他控件在网格中的位置。还有别的容器控件。例如,StackPanel控件自动垂直排列其中的控件,每个控件都紧接在上一个控件下方。
本应用将用Grid 容纳供用户输入和查看客户数据的控件。
4.在页中添加一个TextBlock控件,要么从工具箱拖动,要么直接在XAML窗格的起始<Grid>标记之后输入<TextBlock/>。如下所示:
<Grid>
	<extBlock/>
</Grid>
提示 如果没有看到工具箱,请选择"视图"|"工具箱",我们要用到的控件在"常XAML控件"类别中．另外,可直接在XAML窗格中输入页面布局代码。并非一定要从工具箱拖动。
5.该TextBlock用于显示页的标题。使用下表的值设置TextBlock控件的属性。
属性名称  					
HorizontalAlignment 				Left
Margin								400,90,0,0
Textwrapping						Wrap
Text 								Adventure Morks Customers
VerticalAlignmen					Top
FontS1ze							50
既可使用属性窗口设置,也可直接在XAML窗格中输入,如加粗的代码所示
<TextBlock HorizontalAlignment="Left"Margin="400,90,0,0" Textwrapping="Mrap"
Texta"Adventure Morks Customers"VerticalAlignment="Top"FontSize="50"/>
注意,将控件从工具箱拖放到窗体上,有两条连接线会显示控件的两个边距离容器控件边缘的距离。在本例中,TextBlock 控件的两条连接线显示距离网格左边400,距离网格顶边90。如果在运行时改变Grid控件的大小,TextBlock会自行移动来保持这些距离(错定),造成TextBlock到Grid右边和底边的距离发生改变。要指定控件锚定到哪一边(或者哪些边),可以设置Hor1zontalAlignment和VerticalAlignment属性,然后设置Margin属性来指定到锚定边的距离。在本例中,TextBlock的HorizontalAlignment属性设为Left,VerticalAlignment属性设为Top,表明控件锚定网格左边和顶边。Margin属性包含4个值,指定了控件到容器左边、顶边、右边和底边的距离（(以此顺序)。如果控件的一边没有锚定到容器的一边,可在Nargin属性中将对应值设为0.
6.添加另外4个TextBlock控件。它们是要显示的用户数据的标签。用下表的值设置属性。
控件 						属性 					名称
						HorizontalAlignmen 			Left
						Margin 						330,190,9,0
第一个标签 				Textwrapping 				Wrap
						Text 						ID. 
						VerticalAlignment 			Top
						FontS1ze 					28
						HorizontalAlignment 		Left
						Margin 						466,190,60
第二个标签 				Textwrapping 				Wrap
						Text 						Title
						VerticalAlignment 			Top
						FontSize 					20
						Hor1zontalAlignment 		Left
						Margin 						620,190,0,0
第三个标签 				TextNrapping 				Wrap
						Text 						First Name
						VerticalAlignment 			Top
						FontSize 					20
						HorizontalAlignment 		Left
						Margin 						975,190,0，0
第四个标签 				TextNrapping 				Wrap
						Text 						Last Name
						VerticalAlignment 			Top
						FontSize 					20
和之前一样,可以拖放控件并使用属性窗口来设置,也可直接在XAML窗格的现有TextBlock控件之后、结束</Grid>标记之前输入。
<TextBlock HorizontalAligrmenta"Left"Margin="330,190,0,e" Texthrapping="Wrap"
Texte="ID"VerticalAlignmenta"Top"FontSize="20"/>
<TextBlock HorizontalAligment="Left"argin="60,19?,8"Textwrapping="Wrap"
Text="Title"VerticalAlignment="Top"FontSize="20"/）>
<TextBlock HorizontalAlignment="Left"Margin="628,190,6,e"Textirapping="Wrap"
Texta="First Name"VerticalAligmmente="Top"FontSlze="20"/>
<TextBlock HorizontalAlignment="Left"Margin="975,198,0,0"Texthrapping="Wrap"
Text="Last Name"VerticalAlignment="Top"FontSizem"20"/>
7 再添加3个TextBox控件来显示显示ID、FirstName和LastName。根据下表设置控件的属性值。注意,Text属性应该设为空白字符串""。另外,名为 id 的TextBox标记为只读,因为客户ID由以后添加的代码自动生成。
控件      				属性名称 				值
						X:Name 					id
						HorizontalAlignment     Left
第一个TextBox 			Margin 					300,240,0,0
						Textwrapping 			Wrap.
						Text 					留空不填
						VerticalAlignment 		Top
第一个 TextBox 			FontSize 				20
						IsReadOnly 				True
						X:Name 					firstName
						HorizontalAlignment 	Left
						Margin 					550,240,0,0
第二个TextBox 			TextWrapping 			Wrap
						Text 					留空不填
						VerticalAlignment 		Top
						FontSize 				20
						X:Nam6 					lastName
						HorizontalAlignment 	Left
						Margin 					875,240,0,0
第三个TextBox 			TextWrapping 			Wrap
						Text 					留空不增
						VerticalAlignment 		Top
						FontSize 				20
以下代码是等价的XAML标记:
<TextBox x:Names"id"HorizontalAlignmenta"Left"Nargins"300,240,0,0" Texthrapping="Wrap" Text="" VerticalAligmenta"Top" FontSize="20"IsReadOnly"True"/>
<TextBox x:Name="firstName"HorizontalAlignment="Left"Margins"556,240,0,0" Textirapping="wrap"Texta"VerticalAlignment=Top"Midth="300"FontSlze="20"/>
<TextBox x:Name="lastName"HorizontalAlignment="Left"Nargin="875,240,0,0" Textwrapping="wrap"Text=""VerticalAligmments"Top"Midth="30"FontSizes"20"/>
Name属性不是控件必须的,但要在C#代码中引用控件就必须设置。注意 Name属性附加了x:前缀,它引用由顶部的 Page 标记的属性指定的 XML 命名空间http://schemas.microsoft.com/winfx/2006/xaml。该命名空间定义了所有控件的Name 属性。
注意:不需要理解Name属性为何要这样定义,但如果想知道更多信息,可参考"x:Name指令",网址为http:/msdn.microsof.com/ibrary/ms75229.aspx。
Width 属性指定控件宽度,TextwMrapping属性指定输入的文字超出这个宽度怎么办。本例是自动换行(控件垂直扩充)。设为Nokrap则随着输入自动水平滚动。
8.添加一个ComboBox 控件,定位到id 和firstName 两个文本框之间的TitleTextBlock控件下方。如下表所示设置属性。
属性名称              				值
X:Name  							title
HorizontalAlignment 				Left
Margin 								420,240,0,0
VerticalAlignment 					Top
Width 								100
FontS1ze 							20
等价的XAML标记如下:
<ComboBox x:Name="title"HorizontalAligmente="Left"Margins"428,240,0,0" VerticalAligment="Top"Midth"100"FontSize="20"/>
该ComboBox控件显示一组可供用户选择的值。
9.在 XAML 窗格中将ComboBox控件的定义修改成下面这样,其中添加了4个ComboBoxItem控件。
<ComboBox x:Name="title"HorizontalAlignmenta"Left"Nargin="428,240,0,0"
VerticalAligrment="Top"Midths"100"FontSizes"20">
	<ComboBoxItem Content="Mr"/>
	<ComboBoxIten Content="Mrs"/>
	<ComboBoxItem Contenta"Ms"/>
	<ComboBoxItem Contenta"Miss"/>
</ComboBox>
应用程序运行时,会在下拉列表显示各个ComboxBoxItem元素,用户可从中选择一个。
注意一个语法问题,独立的 ComboBox 标记拆分成起始ComboBox>标记和结束</ComboBox>标记。ComboBoxItem控件放到两者之间。
注意 ComboBox控件除了能显示简单元素,比如一组显示了文本的ComboBoxItem控件,还能显示较复杂的元素,比如按钮、复选框和单选租,如只是添加简单ComboBoxItem控件,直接输入XAML标记较容易,但添加复杂控件时,属性窗口提供的对象集合编辑器更佳。但是,应避免在组合框中搞太多花样,因为最好的应用总是最直观了然的。在组合框中嵌入复杂控件可能适得其反。
10.再添加两个TextBox控件和两个TextBlock控件。TextBox控件供用户输入客户电子邮件和电话号码,TextBlock控件则显示文本框的标签。根据下表设置属性
控件           			属性名称  						值
						HorizontalAlignment 			Left
						Margin 							300,390,0,0
						TextWrapping 					Wrap
第一个 TextBlock 		Text 							Email
						VerticalAlignment 				Top
						FontSize 						20
						×:Name 							email
						HorizontalAlignment 			Left
						Margin 							450,390,0,0
						TextWrapping                    Wrap 
第一个TextBox 			Text 							留空不填
						VerticalAlignment 				Top
						Width 							400
						FontSize 						20
						HorizontalAlignment 			Left
						Margin 							300,540,0,0
						TextWrapping 					Wrap 
第二个TextBlock 			Text 							Phone
						VerticalAlignment 				Top
						FontSize 						20
						X:Name 							phone
						HorizontalAlignment 			Left
						Margin 							450,540.0,0
第二个TextBox 			TextWrapplng 					Wrap
						Text 							留空不填
						VerticalAlignment    			Top
						Width 							200
						FontSize 						20
这些控件的XAML标记如下所示:
<Text8lock HorizontalAligment="Left"Margin="300,390,0,0"TexthWrapping="Wrap"
Text="Email"VerticalAlignmenta"Top""FontSize="20"/> 
<TextBox x:Name="email"HorizontalAligment="Left"Nargin="450,390,0,0" Textbwrapping-"wrap"Texta"VerticalAlignmenta"Top"wdidthe"400"FontSize="20"/> 
<TextBlock HorizontalAlignmenta"Left"Nargin="300,540,0,0"Texthrapping="wrap" Text="Phone"VerticalAlignment="Top"FontS1zem"20"/> 
<TextBox x:Namea"phone"Hor1zontalAligrmenta"Left"Margin="456,540,0,0" TexthWrapping="wrap"Text=""VerticalAlignment"Top"Midthe"200"FontSize="20"/>
11.在"调试"菜单中选择"开始调试"生成并运行应用程序。
应用程序启动并显示窗体。可在窗体中输入并从组合框选择称谓,但别的就做不了什么了。一个更大的问题是窗格在自由缩放的时候看起来太糟糕了。右边的显示被切掉了,大多数文本自动换行,而且Last Name 文本框只剩一半。
12.点击并拖动窗口右下角来放大窗口,使文本和控件按照它们在VisulStudio设计视图那样正常显示。这才是窗体设计的最佳大小。
13.缩小窗口。窗体大部分都消失了。有的TextBlock 内容发生自动换行,这个时候的窗体显然没什么用。
14.返回Visual Studio,选择"调试"|"停止调试"。
这个简单的例子让你体验了为什么在布局时要小心。虽然应用在和设计视图一样大小的窗口中看起来不错,但一旦切换到更小的视图,就变得不好用甚至完全没法用。另外,应用假定用户在横向设备上使用。如果在设计视图中临时切换成12"Tablet规格,并单击"纵向"按钮,就能模拟在平板设备上运行应用并旋转到纵向模式。不要忘记在实验完成之后调回13.3"Desktop
目前的布局还不能伸缩并适应不同屏幕大小和方向。幸好,可利用Grid控件的属性和一个名为"可视状态管理器"的功能解决问题。

用模拟器测试UWP应用
即使手边没有平板电脑,也可用Visual Studio2017提供的"模拟器"来测试UWP应用在移动设备上的表现。模拟器模拟平板设备,允许模拟像捏放和轻扫这样的手势,还能模拟屏幕旋转和修改分辨率等。
要在模拟器中送行应用程序,请在Visual Studio2017工具栏上选择"调试目标",默认调试目标是"本地计算机",这会导致应用程序在本地计算机上运行,但可从这个列表中选择"模拟器",从而在调试时自动启动模拟器.注意,调试目标可以设为一台不同的计算机来执行远程调试（会提示输入网络地址)。
选好"模拟器"之后、从"调试"菜单中运行应用,模拟器就会启动并显示应用程序。右侧工具栏允许使用鼠标模仿手势。如应用程序要求设备的地理位置信息,甚至可以模拟用户的位置.但在测试应用程序布局时,最重要的工具是顺时针旋转、逆时针旋转和更改分辨率,下图展示了Customers 应用程序在模拟器中运行的样子。
模拟器的行为就是真正的Windows 10计算机的行为(它本质上是到你自己计算机的一个远程桌面连接).要停止模拟器,在VisualStudio 中单击"停止调试",或者右击"开始"
按扭(模拟器的,不是桌面的),选择"关机或注销"|"断开连接"
注意,VisualStudio还支持特殊移动设备的模拟器。有的没有在"调试目标"下拉列表中列出,但可选择"下载新的仿真程序"来下载。
用Grid 控件实现表格布局
可用Grid控件实现表格布局。Grid包含行和列,可指定要将控件放在哪一行和哪一列。Grid控件的一个优点是可以用相对值指定行和列的大小。这样当网格缩小或放大来适应不同的屏幕大小和方向时,行和列也能成比例地缩小和放大。行列交汇构成一个单元格。将控件放到单元格中,它们会随着行和列的缩小和放大而移动。所以,实现可伸缩界面的关键就是将界面分解成一组单元格,相关元素放到同一个单元格中。单元格可包含另一个网格,以便对每个元素进行准确定位。
以Customers应用程序为例,UI可以划分为两个主要区域。一个是标题区域,一个是包含客户详细信息的主体区域。不同区域之间要有一定间距,窗体底部要有边距。可以为每个区域都指定相对大小。
容纳这些元素需定义4行,并将相关项放到各自的行中。其中,主体可以用另一个更复杂的网格来描述。
同样地,每一行的高度都是相对值,宽度也是。另外,注意容纳Email和Phone信息的TextBox和网格有一点冲突。如果愿意,可以定义嵌套更深的网格来对齐这些项。但请注意,网格的目的只是定义元素的相对位置和间距,元素完全允许超过单元格的边界。
以下练习将修改Customers应用程序的布局,用上述网格布局定位控件。
修改布局以适应不同的屏幕大小和方向
1.在Customers 应用程序的XAML窗格中,在现有Grid元素内添加另一个Grid。新Grid的边距设为距离父Grid左右两边10像素,距离顶边和底边20像素,如加粗代码所示
<Grid>
	<Grid Margin="18,20,10,20">
	</Grid> 
	<TextBlock HorizontalAlignmenta"Left"Texthkrapping="Wrap" 
		Text="Adventure iorks Customers"... />
	...
</Grid>
行和列可作为现有Gr1d的一部分定义,但为了保持与其他UWP应用一致的外观和感觉,左侧和顶部应该留一些空。
2.将以下加粗的<Grid.RoMDefinitions>区段添加到新的Grid元素中:
<Grid Margin="10,20,10,20">
	<Grid.RoMDefinitions>
		<RoMDefinition Height="2"/>
 		<RoMDefinition Heighta"*"/>
		<RowDefindtion Heighte"10t*"/> 
		<RoMDefinition Heighta"2"/>
	</Grid.RoMDefinitions>
</Grid>
<Grid.RoWDefinitions>区段定义网格中的行。本例定义4行。可用绝对值(以像素为单位)指定行的大小,也可用*操作符指出这是相对大小(造成Windows在程序运行时根据屏幕大小和分辨率计算行的大小)。本例的值对应于前面图示的header(标题)、body(主体)、spacer(间隔)和bottom margin(底部边距)的相对大小。
3. 将包含标题文本"Adventure Works Customers"的TextBlock控件移到Grid中,放到结束</Grid.ROMDefinitions>标记之后、结束</Grid>标记之前。
4.为该 TextBlock 控件添加Grid.Row属性,值设为e,指出 TextBlock应定位在Grid的第一行(Grid控件的行列编号都从0开始)。
<Grid Margin="10,20,10,20">
	<Grid.RowDefinitions>
	...
	</Grid.RoMDefinition>
	<TextBlock Grid.RoW="0"...Text="Adventure Works Customers"../>
	...
</Grid>
注意 Grid.Row是所谓的附加属性(atachedproperty),也就是从容器控件获得的属性网格外部的TextBlock没有Row属性(因为没有意义),但只要定位到网格中,Row属性就会附加到 Text8lock上,TextBlock控件可向其赋值.然后,Grid控件根据这个值判新在哪里显示TextBlock控件。附加属性很容易区分,因为它必然是ContainerType.PropertyName这样的形式。
5.删除Margin属性,将HorizontalAlignment和VerticalAlignment属性设为Center。这会造成TextBlock在行内居中。
目前Grid和 TextBlock控件的XAML标记如下所示(改动的地方加粗显示)
<Grid Margin="10,20,10,20">
	...
	</Grd.RonDefinitions>
	<TextBlock Grid.Row="e" HorizontalAligrment="Center"Textirapping="wrap"
Text="Adventure works Customers"VerticalAligment="Center"FontSize"50"/>
	...
</Grid>
6.在TextBlock控件后添加另一个嵌套Grid控件。该网格对主体中的所有控件进行布局，应该出现在外层Grid的第3行（行大小是10*）,所以将Grid.Row属性设为2,如加粗的代码所示：
<Grid Margin="10,20,10,20*>
	<Grid.RowDefinitions)
		<RowDefinitionHedght="2*"/>
		<RowDefinition Heighte"*"/>
		<RowDefinition Heighta"10*"/>
		<RowDefinition Heighte"2*"/>
	</Grid.ROwDefindtions>
	<TextBlock Grid.Row="0" HorizontalAlignmenta"Center".../>
	<Grid Grld.Row="2>
	</Grid>
	...
</Grid>
7.在新Grid 控件中添加以下<Grid.RowDefinition>和<Gr1d.ColumnDefinition>区段:
<Grid Grid.Row="2">
	<Grid.RowDefinitions>
		<RowDefinition Height="*"/>
		<RowDefinition Height="*"/>
		<RowoDefinition Height="2*"/>
		<RowDefindtion Height="*"/>
		<ROwDefinition Height="2*"/>
		<RowDefinition Heighta"*"/>
		<RowDefinition Heighta"4*"/>
	</Grid.ROdDefinitlons>
	<Grid.ColummDefinitions>
		<ColumrDefinition wMidth"*"/>
		<ColumrDefinition Mdthe"*"/>
		<ColumnDefinition Mdth="20"/>
		<ColumDefinition width="*"/>
		<ColumDefinition wMidth="28"/
		<ColumrDefindtion Midthe"2*"/>
		<Columrbefindition Midth="20"/>
		<ColumrDefinition Widthm"2*"/
		<ColummDefindtion Width="*"/>
	</Grid.ColummDefinitions>
</Grid>
这些代码定义了前面示意图所描述的行列高度和宽度。控件列间隔20像素
8.将显示ID、Title、Last Name和 First Name标签的Text8lock控件移动到嵌套 Grid控件中,放到结束<Grid.ColummDefinitions>标记之后。
9.将每个Text8lock的Grid.Row 属性设为O(从而在第一行显示这些标签)。将ID标签的Grid.Column属性设为1,Title标签的Grid.Column属性设为3,FirstName标签的Grid.Column属性设为5,Last Name 标签的Grid.Column属性设为7。
10.删除所有 TextBlock 控件的Margin属性,将Hor1zontalAlignment和VerticalAlignment属性设为Ccenter。目前这些控件的XAML标记如下所示(改动的地方加粗显示)
<Grid Grid.Row"2">
	<Grid.RowDefinitions>
		...
 	</Grid.RowDefinitions>
	<Grid.ColumnDefinitions>
	...
 	</Grid.ColumnDefinition> 
 	<TextBlock Grid.Row="0"Grid.Column="1" HorizontalAligmmenta"Center" Textwrapping="wrap"Text="ID"VerticalAlignment="Center"FontSize="20"/> 
 	<TextBlock Grid.Row="0"Grid.Ccolumms"3" HorizontalAligrmenta="Center" Textirapping="wrap" TextaTitle"VerticalAlignment="Center"FontSize="20"/> 
 	<TextBlock Grid.Row="0"Grid.colum="5" HorizontalAligmment="Center"
	TextWrapping="Wrap"Texta"First Name"Verticalligment="Center" FontSize="20"/) 
	<TextBlock Grid.Rowe="0"Grid.Column="7" HorizontalAlignmenta="Center"
	TextWrapping="Wrap" Text"Last Name"Verticalligment="Center"FontSizem"20"/)
</Grid>
11.将id、firstName 和lastName等 TextBox控件和 title ComboBox控件移动到嵌套 Grid控件中,放到显示Last Name 的TextBlock控件之后。
将这些控件放到Grid的行1.id控件放到列1,title 控件列3,firstName控件列5,lastName控件列7。
删除所有控件的Margin属性,将VerticalAlignment属性设为Center。删除Width属性,HorizontalAlignment属性设为Stretch——造成控件占据整个单元格,并随着单元格大小的改变而自动缩小或变大。
这些控件最终的XAML标记如下所示。
<Grid Grid.Row="2">
	<Grid.RowDefindtions>
	...
	<Grid.ColumnDefinitions>
	</Grid.ColumnDefinitions>
	...
	<TextBlock Grid.Row="0" Grid.Column="7"...Texta"Last Name".../>
	<TextBox Grid.Row="1"Grid.Column="1"x:Name"id" HorizontalAligmentus="Stretch"
TextWrappirg='Wrap" Text="VerticalAligment="Center" FontSize="20" IsReadOnly"True"/>
	<TextBox Grid.Row="1"Grid.Column="5"x:Name"firstName" HorizontalAligmentus="Stretch"
TextWrappirg='Wrap" Text="VerticalAligment="Center" FontSize="20" >
	<TextBox Grid.Row="1"Grid.Column="7"x:Name"lastName" HorizontalAligmentus="Stretch"
TextWrappirg='Wrap" Text="VerticalAligment="Center" FontSize="20" >
	<ComboBox Grid.Row""Grid.Columm"3" x:Name="title"HorlzontalAligmenta"Stretch"
VerticalAlignment="Center"FontSize="20">
		<ComboBoxItem Contenta"Mr"/>
		<ComboBoxItemContent="Mrs"/>
		<ComboBoxItem Content="Ms"/>
		<ComboBoxItemContent="Miss"/>
	</ComboBox>
</Grid>
12.将显示Email标签的TextBlock控件和 email TextBox控件移动到嵌套Grid控件中,放到 titleComboBox控件之后。

将这些控件放到Grid控件的行3。Email标签放到列1,emailTextBox控件放到列3.另外,将emailTextBox控件的Grid.ColumnSpan属性设为5;这使其跨越5列,就像前面的示意图展示的那样。

将 Email标签控件的 HorizontalAlignment属性设为Center,但emailTextBox的HorizontalAlignment属性仍然设为Left;该控件应左对齐它跨越的第一列,而不是在5个列的范围内居中。

将 Email标签和 emailTextBox控件的VerticalAlignment属性设为Center。删除这些控件的Margin属性。下面是这些控件最终的XAML标记:
<Grid Grid.Row="2">
	<Grid.RowDefinitions>
		...
	</Grid.RowDefindtions>
	<Grid.ColumnDefinitions>
		... 
	</Grid.ColumDefinitions>
	...
	<ComboBox Grid.Row="1"Grid.Colum"3" x:Name"title" HprizortalAligment="Stretdh"
VerticalAlignment="Center"FontSize="20">
	...
	</ComboBox>
	<TextBlock Grid.Row="3" Grid.Columns"1" HorizontalAlignment="Center"
TexthWrapping="Wrap" Text="Email"VerticalAlignment="Center"FontSizes"20"/)
	<TextBox Grid.Row="3" Grid.Columns"3"Grid.Columnspans"5"x:Name="email"
HbrizontalAligmentu"Left" Textiragpinge"wrap" Texte""VerticalAligment="Center
Width="400"FontSi1ze="20"/>
</Grid>
13.将显示 Phone标签的TextBlock控件和 phone TextBox控件移动到嵌套Grid控件中,放到email TextBox控件之后。
将这些控件放到Grid控件的行5。将Phone标签放到列1,phoneTextBox控件放到列3。将phoneTextBox控件的Grid.ColumnSpan属性设为3。
将 Phone标签控件的HorizontalAlignment属性设为Center,phoneTextBox的HorizontalAlignment属性则继续保持Left。
将两个控件的VerticalAlignment属性设为Center并删除 Margin属性。
两个控件最终的XAML标记如下所示:
<Grid Grid.Row="2">
	<Grid.RoMDefinitions>
	...
	</Grid.RowDefinitions>
	<Grid.ColumnDefinitions>
	...
	</Grid.ColumnDefinitions>
	...
	<TextBox.…."x:Name="email".../>
	<TextBlock Grid.Row="5"Grid.Column="1"HorizontalAlignment="Center"
TextiWrapping="Wrap"Texta"Phone"VerticalAlignmenta"Center"FontSize="20"/>
	<TextBoxGrid.Row="5"Grid.Colum="3"Grid.ColumnSpan="3"x:Name="phone"
	HorizontalAligment="Left" TextbWrapping="Wrap"Text=""VerticalAligment="Center"
Width"200" FontSize="28
<Grid/>
14.在Visual Studio 2017工具栏的"调试目标"下拉列表中选择"模拟器"。将在模拟器中运行应用程序,查看布局在不同分辨率和屏幕大小时的自适应情况。
15.在"调试"菜单中选择"开始调试"。
随即启动模拟器并运行Customers应用。最大化应用使它占据模拟器的整个屏幕。点击"更改分辨率",使用1366×768的分辨率。另外,确保模拟器目前是以横向模式显示(如果纵向模式就点击"顺时针旋转"）。验证控件的间距非常匀称。
16.单击"顺时针旋转"以纵向模式显示。uCstomers应用会调整UI布局,控件间距仍然很匀称,且完全可用。
17.点击"逆时针旋转"来恢复横向模式,然后点击"更改分辨率",使用2560×1400的分辨率。注意,控件布局还是很匀称,虽然标签文字可能有点看不清(除非当前实际使用的就是27寸显示器）)。
18.再次点击"更改分辨率"使用1024×768的分辨率。
控件的间距和大小同样会自动调整来呈现一个养眼的用户界面。
19.双击窗体顶边将窗体还原为窗口。拖动并改变窗口大小,使其在屏幕左半部显示。最小化窗口宽度,模拟应用在手机屏幕上的显示。
20.在Visual Stdio 中单击"停止调试",从而关闭模拟器并返回Visual Studio。
22.在"调试目标"下拉列表中选择"本地计算机"。

用可视状态管理器调整布局
Customers应用的UI能适应不同分辨率和屏幕大小,但视图宽度变小后仍不理想。另外,在手机上使用效果不佳,因为手机宽度更小。稍微想一下就知道问题不出在控件缩放,而是出在布局。
创建几个版本的MainPage.xaml文件,每个设备家族一个。每个XAML文件均链接到同一个代码隐藏文件MainPage.xamls,全部运行相同的代码。例如,要为智能手机创建XAML文件,就在项目中添加一个名为DeviceFamily-Mobile的文件夹(一定要是这个名字),并使用"项目"|"添加新项"命令在文件夹中添加名为MainPage.xaml的一个新的XAML视图。根据想在手机上达到的效果对页面进行布局。XAML视图会自动链接到现有MainPage.xamlcs文件。运行时,UWP根据运行应用的设备类型自动选择合适的视图。
可通过"可视状态管理器"在运行时修改页面布局。所有UWP应用都实现了可视状态管理器,它跟踪应用的可视状态,能检测窗口高度和宽度变化。可添加XAML标记,根据窗口大小来定位控件。该标记能移动控件或显示隐藏控件。
可通过"可视状态管理器"根据窗口高度和宽度切换不同视图。它综合了前两种方式的优点,实现起来最轻松,无需使用许多繁琐的XAML代码计算每个控件的最佳位置。还最灵活,窗口在同一个设备上变窄也能起作用。
后续练习将采用第三种方式。第一步是定义客户数据在窄屏上的布局
定义窄视图的布局
1.在Customers 应用程序的XAML窗格中,向定义控件表格布局的Grid控件添加以下加粗的x:Name和Visib1lity属性。
<Grid/>
	 <Grid x:Name="customersTabularView"Nargin="10,20,10,20"Visibility"Collapsed">
	 ...
	 </Grid>
</Grid>
该Grid用于容纳窗体的默认视图。后续练习将在其他XAML标记中引用该Grid,所以需为它指定名称。Visib1lity 属性指定控件是显示(Visible)还是隐藏（Collapsed)。默认值是Visible,但暂时隐藏该 Grid,并定义另一个Grid 以列格式显示数据。	

2.在 cusLomersTabularView Grid 控什的结束（/Grid>标记后添加另一个Grid,x:Name 属性设为customersColumnarView,Margin 属性设为10,20,18,20,Visibility属性设为Visible。该 Grid将容纳窗体的"窄"视图。网格中的字段将采用之前描述的列布局。	 
提示 要使结构更易读,可点击XAML标记左侧的+或-符号,从而展开或收缩 XAML窗格中的元素
<Grid>
	<Grid x:Name="customersTabularVe/"陷rgin="1e,20),18,20" Vsibility="Collapsed">
	...
	</Grid>
	<Grid x:Name="customersColummarView"Nargins"186,20,19,20"Visibilitya"Visible">
	</Grid>
</Grid>
3.在customersColumnarView Grid控件中添加以下行定义。
<Grid x:Name="customersColumarView" Margin="10,20,10,20"Vsibllity=Visible"> 
	<Grid.RomOefinitions>
		<RoMDefinition Heighta"*"/>
		<RomOefin在tion Hefght="10*"/>
	</Grid.RoMDefintions>
</Grid>
第一行显示标题,第二行(这一行高度大得多)显示供用户输入数据的控件。
4.在行定义后添加以下 TextBlock 控件,在Grid 控件第一行显示被截短的标题"Customers"。将FontSize 设为 30.
<Grid x:Name="customersColumarvView"Margin="18,20,16,20"Visib1lity="Visible">
	<Grid.RowDefinitions>
	...
	</Grid.RowDefinitions>
	<TextBlock Grid.Row="e"HorizontalAlignment="Center"TextWrapping="Wrap"
Text="Customers"VerticalAlignmenta"Center"FontSize="30"/> 
</Grid>
5. 在customersColumnarViewGrid控件的行1添加另一个Grid控件,以便用两列显示标签和数据输入控件。在Grid中添加以下行列定义。
<TextBlock Grid.Rowe"0".../> 
<Grid Grid.Row="1"> 
	<Grld.ColumnDefinitions>
		<ColummDefinition/>
		<ColumDefin tion/>
</Grid.ColumnDefinitions> 
<Grid.RomDefinitions>
		<RowDefinition/>
		<RowDefinition/>
		<RowDefin生tion/
		<RowDefInition/>
		<RowDefinition/>
	<RowDefinition/>
</Grid.RomDefinitions> </Grid>
注意,如果集合中所有行或列都有相同的高度或宽度,就不需要指定大小了。
6.将ID、Title、First Name 和Last Name 等 TextBlock控件的XAML标记从customersTabularViewGrid控件复制到新Grid中,放到刚才添加的行定义之后。ID控件放到行G,Title控件行1,FirstName控件行2,LastName控件行3。所有控件都放到列0。
<Grid.RowDefinitions>
...
</Grid.RowDefindtions>
<Text8lock Grid.Row="0" Grid.Colum="0" HorizontalAlignmenta"Center"
TextWrapping="Wrap" Text="ID" VerticalAligment="Center" FontSize="20"/>
<TextBlock Grid.Row="1"Grid.column="0"HorizontalAlignment="Center"
TextWarapping="Wrap"Text="Title"VerticalAligmente"Center"FontSize="20"/
<TextBlock Grid.Row="2"Grid.Column="0"HorlzontalAlignmenta"Center"
TextWrapping="Wrap"Text="First Name"VerticalAligmment="Center"FontSize="20",
<TextBlock Grid.Row="3"Grid.colums"e"HorizontalAlignment="Center"
TextWrapping="Wrap" Text="Last Name"VerticalAlignmenta"Center"FontSize="20"/>
7.将id、firstName和lastName这三个TextBox控件以及titleComboBox控件从customersTabularViewGrid控件复制到新Grid中,放到TextBox控件之后。id控件放到行O,title行1,fistName行2,lastName行3。全部4个控件都放到列1.另外,为所有控件名称附加字母c(代表column或列)来改名。这是为了防止和customersTabularViewGrid中的现有控件冲突。
TextBlock Grid.Row="3"Grid.colums*e"HbrizontalAligrment="Center"
TextWrapping="Wrap" Text="Last Name".../>
<TextBox Grid.Row="0"Grid.Column="1"x:Name="cId" HorizontalAlignment="Stretch"
TexWrapping="Wrap" Text="VerticalAligments"Center"FontSize="20" IsRead0nly"True"/>
<TextBox Grid.Row="2"Grid.Colum="1"x:Namea"cFirstName"HorlzontalAlignmente"Stretch"
TexWrapping="Wrap"Text=""VerticalAligment="Center"FontSLzem"20"/>
<TextBox Grid.Row="3"Grid.column="1"x:Names"cLastame"HorizontalAlignment="Stretch"
TextWhrapping="Wrap" Text="VerticalAligment="℃enter"FontSize"20"/>
<ComboBox Grid.Row="1"Grld.Columm="1"x:Name="cTitle"HorizontalAligmenta"Stretch"
VerticalAligrmenta"Center"FontSizes="20">
	<Combo8oxItemContent="Mr">
	<Combo8odItem Contente"Wrs"/>
	<ComboBoxItem Contenta"Ms"/>
	<comboBoxItem Ccontent="wiss"/>
</ComboBox>
8. 将代表电子邮件地址和电话号码的 TextBlock 和 TextBox 控件从customersTabularView Grid控件复制到新Grid中,放到cTitleComboBox控件之后。将两个TextBlock控件放到列e,占用行4和行5.两个TextBox控件放到列1,也是占用行4和行5。将emailTextBox控件的名称更改为CEmail,phoneTextBox控件的名称更改为cPhone。删除cEmail和cPhone控件的width属性,把它们的 HorizontalAlignment属性设为 Stretch。
<ComboBox..>
	...
</ComboBox>
TextBlock Grid.Row="4"Grid.Colum="0" HbrizontalAligments"Center" TextWrapig="Wrap"
Text="Email"VerticalAllgnment="Center"FontSize="20"/>
TextBox Grid.Row='4"Grld.Column="1"x:Name="cEmail"HorlzontalAligment="Stretch"
TextWrapping="Wrap"Text=""VerticalAlignment="Center"FontSizes"20"/> 
<Textslock Grid.Row="5" Grid.colum="0" HbrizortalAligments="Certer" Textbrapirg'Wrap"
Text="Phone"VerticalAligrment="Center"FontSize="20"/> 
<TextBox Grid.Row="5"Grid.Column="1"x:Name="cPhone"HorizontalAligment="Stretch"
TextWrapping="Wrap" Text=""VerticalAlignment="Center" FontSize="20"/>
9.返回customersTabularView Grid控件的XAML标记,将Visibil4ty属性设为Visible:
<Grid x:Names"customersTabularView" Margin="18,20,16,20"Visibflitys"Vsible">
10.在customersColumnarView Grid控件的XAML标记中,将Visibility属性设为Collapsed:
<Grid x:Name="customersColumarVieM"Nargins"16,20,19,20""Visibility"Collapsed">
计视图将显示Customers 窗体的原始表格布局。这是应用的默认视图。
现已定义好了窄视图的布局。你或许会感到疑惑,前面只是复制了许多控件,并以不同方式进行布局。那么,在不同视图之间切换时,一个视图中的数据如何传输到另一个?例如,假定应用程序以全屏幕模式运行时输入了一个客户的详细信息,那么当切换到窄视图后,新控件并不包含刚才输入的信息。解决这个问题的方案是数据绑定,它将数据和多个控件关联。数据改变时,所有控件都显示更新的信息。
这时要用到触发器。它们在某些显示参数(比如高度或宽度）发生变化时通知可视状态管理器。可在应用的XAML标记中定义由这些触发器执行的可视状态过渡。下一个练习演示具体怎么做。

使用可视状态管理器修改布局
1.在Customers应用程序的XAML窗格中,在customersColumnarView Grid控件的结束</Grid>标记后添加以下标记:
<Grid x:Names"customersColumarView"Margin="18,20,196,20"Visibllfty="Visible">
	...
 </Grid>
 <VisualStatetManager.VisualStateGroups>
 	<VisualstateGroup>
		<VisualState X:Name="TabularLayout"/>
	</VisualstateGroup>
</VisualstateManager.VisualstateGroups>
定义可视状态的过渡需实现一个或多个可视状态组,指定当可视状态管理器切换到该状态时应发生什么过渡。为每个状态都指定有意义的名称来注明用途
2.将以下加粗的可视状态触发器添加到可视状态组:
<VisualstatetManager.VisualStateGroups>
	<VisualstateGroup>
		<VisualState x:Name="TabularLayout">
			<Visualstate.StateTriggers>
				<AdaptiveTrigger MinWindowMolidth="660"/>
			</VisualState,StateTriggers>
		</VisualState>
	</VisualStateGroup>
</VisualStateManager.VisualStateGroups>
该触发器在窗口宽度超过660像素时触发。大于该宽度应切换为表格布局。如低于该宽度,Customers窗体上的控件和标签开始自动换行和难以使用,所以应切换为列布局(窄视图)
3.在触发器定义后添加以下加粗的代码:
VisualstateManager.VisualStateGroups>
	<VisualStateGroup>
		<VisualState x:Name="TabularLayout">
			<VisualState. StateTriggers>
				<AdaptiveTrigger WinwindowWidth="660"/>
			</VisualState.StateTriggers>
			<VisualState. Setters>
				<Setter Target="customersTabularView.Visibility" Values"Visible"/>
				<Setter Target="customerscolummarView.Visibility"Values"Collapsed"/>
			</VisualState.Setters>
		</VisualState>
	</visualstateiroup>
</VisualsStateManager.VisualsStateGroups>
这些代码指定触发器触发后采取的行动。行动用Setter元素定义。每个Setter都指定要设置的属性及其值。本例就是使customersTabularView Grid控件可见,使customersColumnarView Grid控件隐藏。
4.在TabularLayout 可视状态后添加另一个针对窄视图的可视状态,并定义其触发器和触发后采取的行。
<VisualStateManager.VisualStateGroups>
	<VisualStateGroup>
		<VisualState x:Name="TabularLayout">
			...
		</VisualState> 
		<VisualState x:Name="ColumarLayout">
			<VisualState.StateTriggers>
				<AdaptiveTrigger MinidindowMaidth="0"/>
			</VisualState.StateTriggers> 
			<VisualsState. Setters>
				<Setter Target="customersTabularview.Visibility" Value="Collapsed"/>
				<Setter Target="customerscolumarView.Visiblity" Value="Visible"/>
			</Visualstate.Setters>
		</Visualstate>
	</VisualStateGroup>
</Visualstatetanager.VisualstateGroups>
窗口宽度低于660像素时发生该过渡。应用将可视状态切换为ColumnarLayout,隐藏customersTabularViewGrid,显示 customersColumnarView Grid.
5.在"调试"菜单中选择"开始调试"。应用开始运行并显示Customers 窗体。数据用表格布局显示。
注意 如果你现在用的显示器分辨率小于1366×768,就像前面描述的那样用模拟器运行。为模拟器配置1366×768的分辨率.
6.改变Customers应用的窗口大小用窄视图显示。窗口宽度小于60像素后将切换为列布局。
7.改变窗口大小(或直接最大化),窗口宽度超过660像素后将还原为表格布局.
8.返回Visual Studio并停止调试。

向UI应用样式
了解应用程序的基本布局机制后,下一步是应用样式来增强界面的吸引力。UWP应用中的控件提供了大量属性来更改字体、颜色、大小和其他特性。可单独为每个控件设置属性,但如果大量控件都需要相同样式就不合适了。此外,好的应用都做到了UI样式的统一,单独设置很难保持一致性。常在河边走,哪有不湿鞋?
UWP应用允许定义可重用样式。可创建资源字典将其作为应用级资源来实现,让应用的所有页的控件都能使用。还可在一个页的XAML标记中定义本地资源,只有那个页才能使用。以下练习为Customers应用程序定义一些简单样式,将其应用于Customers 窗体上的控件。
为Customers 窗体定义样式
1.在解决方案资源管理器中右击Customers项目,选择"添加"|"新建项"。
2. 在"添加新项"对话框中点击"资源字典"。在"名称"文本框中输入AppStyles.xaml,单击"添加"。
随后会在"代码和文本编辑器"窗口中显示AppStylesxaml文件。资源字典是XAML文件,定义了可由应用程序使用的资源。AppStyles.xaml文件的内容如下
<Resourceoictionary
	xmlns"http://schemas.microsoft.com/wdinfx/2006/xaml/presentation"
	xmlns:xe"http:/schemas.Microsoft,com/wdnfx/2006/xaml"
	xmlns:locals"using:Custoners">
</ResourceDictionary>
样式只是资源的一种,还有其他许多资源。事实上,首先添加的资源并不是样式,而是用于描绘Customers窗体最外层Grid控件背景的一个ImageBrush。
3.在解决方案资源管理器中右击Customers 项目,选择"添加"|"新建文件夹"。将新文件夹的名称更改为Images
4.右击Images 文件夹,选择"添加"|"现有项"。
5.在"添加现有项"对话框中,切换到"文档"文件夹下的MicrosoftPress\VCSBS\Chapter 25\Resources 文件夹,选中 woodjpg并单击"添加"按钮。wood.jpg文件添加到Customers项目的Images文件夹。这是准备在Customers窗体中使用的一张本纹背景图片。
6.在AppStyles.xaml文件中添加以下加粗的XAML标记:
<Resourceoictionary
	xmlns="http://schemas.microsoft.com/wdinfx/2086/xaml/presentation"
	xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
	xmlns:localm"using:Customers">
	<ImageBrush x:Keye"wood8rush"ImageSource="Images/wood.jpg"/>
</ResourceDictionary>
该标记创建名为 WoodBrush的 ImageBrush 资源。可用该画笔设置控件背景来显示 wood.jpg。
7.在ImageBrush资源下方添加以下加粗的样式。
<ResourceDictionary
	...>

	<ImageBrush x:Keye"woodBrush"ImageSource="Images/wood.jpg/>
	<Style x:Keya"GridStyle"TargetTypea"Grid">
		<Setter Property="Background"Value="(StaticResource WoodBrush)"/>
	</Style>
</ResourceDictionry>
该标记演示了如何定义样式。Style元素要有名称（以便在应用程序中引用),而且要指定样式应用于什么控件类型。该样式将应用于Grid控件。
样式主体包括一个或多个 Setter 元素。本例将Background 属性设为名为wMoodBrush 的ImageBrush 资源。但语法有一点怪。既可引用系统定义的属性值(例如,将背景设为纯红色就使用"Red"),也可指定已定义的资源。引用资源需使用StaticResource关键字,然后将整个表达式放到大括号中。
8.使用该样式必须先更新应用的全局资源字典,添加对AppStylesxaml文件的引用。在解决方案资源管理器中双击App.xaml来显示它,如下所示。
<Application X:Class="Customers.App"
	x:mlns="http://schemas.microsoft.com/wdnfx/2006/xaml/presentation"
	xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" 
	xmlns:local="using:Customers" 
	RequestedTheme="Light">

</Application>
App.xaml文件目前只定义了App 对象并引入了几个命名空间,全局资源字典空白。

9.在App.xaml文件中添加以下加租的代码。
<Application
	X:Classm"Customers.App" 
	xmlnsa"http://schemas.microsoft.com/winfx/2006/xaml/presentation"
	xmlns:x"http://schemas.microsoft.com/wdnfx/206/xaml" 
	xmlns:local="using:Customers" 
	RequestedTheme="Light">

	<Application.Resources>
		<ResourceDictionary
			<ResourceDictionary.NergedDictionaries>
				<ResourceDictionary Source="AppStyles.xaml"/>
			</ResourceDctionary.MergedDictionaries>
		</ResourceDictionary>
	</Application.Resources>
</Applicatio>
该标记将AppStyles.xaml文件中定义的资源添加到全局资源字典的可用资源列表中。现在整个应用程序都可以使用这些资源了。
10.切换到正在显示Customers 窗体UI的MainPage.xaml文件。在XAML窗格中找到最外层Grid控件。
<Grid>
添加 Style 属性来引用GridStyle样式,如加粗部分所示。
<Grid Style="(StaticResource GrldStyle}">
设计视图中的Grid控件应显示木纹背景
11.返回AppStyles.xaml文件,在GridStyle样式后面添加以下 FontStyle样式。
<style x:Keye"Grldstyle" TargetType-="Grld">
	...
</Style>
<Style x:Key="FontStyle"TargetType="TextBlock">
	<Setter Property="FontFamily"Value="Segoe Print"/>
</Style>
该样式应用于TextBlock元素,将字体修改成SegoePrint,一种手写体风格的字体。目前可以在需要该字体的每个TextBlock控件中都引用FontStyle样式,但是既然如此还不如直接在每个控件的标记中设置FontFamily属性。样式真正变得强大是将多个属性合并起来的时候,如后续几个步骤所示。
12.将以下 HeaderStyle样式添加到AppStyles.xaml文件中。
<Style x:Key"FontStyle"TargetType="TextBlock">
	...
</Style>
<Style x:;Key="Headerstyle"TargetTtype"Text8lock" BasedOn="{StaticResourceFontStyle}>"
	<Setter Propertya"HorizontalAlignment"Valuea"Center"/>
	<Setter Property="TextNkrapping"Value="wirap"/> 
	<Setter/"> Property="verticalAlignment"Value="Center"/>
	<Setter Property="Foreground"Value="SteelBlue"/>
</style>
该复合样式设置了TextBlock的HorizontalAlignment、TextNrapping、VerticalAlignment和Foreground属性。另外,HeaderStyle 样式使用BasedOn属性引用FontStyle样式。BasedOn属性提供了简单的样式继承形式。
该样式将用于格式化 customersTabularGrid和customersColumnarGrid控件顶部显示的标签。但这些标题的字号不同(表格布局的标题比列布局的大一些),所以要创建另外两个样式来扩展HeaderStyle样式。
13.在 AppStyles.xaml文件中添加以下样式。
<style x:Keym"Headerstyle" TargetType:"TextBlock"Basedn="{StaticResourceFontStyle}>
	...
</Stytle>
<stylex:Keye"TabularteaderStyle"TargetType"TetBlodk" BasedD"(StatidResarceHeaderstyle}">
	<Setter Propertya"FontSize"Valuem"30"/>
</Style>
注意,这些样式选用的字号比Grd控件中的标题目前使用的字号稍小,这是因为Segoe Print字体比默认字体大。
14.返回 MainPage.xaml 文件,找到customersSTabularView Grid 控件中显示Adventure Works Customers 标签的TextBlock控件的XAML标记。
Text8lock Grid.Row="0" HorizontalAligrment="Center" TextWrappings"Wrap"
Text="Adventure Works Customers"VerticalAlignmenta"Center"FontSize="50"/>
15.修改这个控件的属性来引用TabularHeaderStyle样式,如加粗部分所示。
<TextBlock Grid.Row ="0"Styles="{StaticResource TabularHeaderStyle}"
Text="Adventure Works Customers"/>
16. 找到customersColumnarView Grid控件中显示 Customers标签的TextBlock控件的XAML标记。
TextBlock Grid.Row="e"HorizontalAligneenta"Center" TextWrapping="Wrap"
Text="Customers"VerticalAligment="Center"FontSize="30"/>
修改这个控件的属性来引用ColumnarHeaderStyle样式,如加粗的部分所示。
<TextBlock Grid.Row="0"Styles"(StaticResource ColumnarHeaderStyle)"
Text="Customers"/>
注意设计视图没有变化,因为 ColumnarView Grid控件默认是折叠(隐藏）的。但稍后运行应用就能看到效果。
17.返回 AppStyles.xaml文件。修改 HeaderStyle样式来添加额外的属性 Setter元素,如加粗的语句所示。
<Style x:Keys="HeaderStyle"TargetType="Text8lock"Basedon="(StaticResourceFontstyle)">
	<Setter Property="HorizontalAligrment"Value="Center"/)
	<Setter Propertye"Texthrapping"Value="wrap"/>
	<Setter Property="verticalAlignment"Value="Center"/>
	<Setter Property="Foreground"Values"Steel8lue"/)
	<Setter Property="RenderTransformOrigin"Value="e8.5,6.5"/>
	<Setter Property="RenderTransform2>
		<Setter.Value>
			<CompositeTransform Rotation="-5">
		</Setter.Value>
	</Setter>
</Style>
这些元素通过一个变换使标题文本围绕中点旋转5度。
注意 本例展示了一个简单的变换(transformation).可通过RenderTransform属性执行大量变换动作,且多个变换可合并,例如,可在x和y轴平移,并可进行倾针和按比例缩放等.另外注意,RenderTransform属性的值本身就是一个"属性/值"
对(本例属性是Rotation,值是-5)）。这种情况要用<Setter.Value>标记指定值。
18.切换到MainPagexaml文件。在设计视图中,标题现在应该微微上翘
19.在AppStyes.xaml文件中添加以下样式。
<Style X:Keya"Labelstyle" TargetType="TextBlock"Basedon="(StaticResourceFontStyle}">
	<Setter Property"FontSize"Valuea"30"/>
	<Setter Propertye"HorizontalAlignment"Value="Center"/>
	<Setter Property="Textihrapping"Values"wrap"/>
	<Setter Property="VerticalAlignment"Value="Center"/>
 	<Setter Property="Foreground"Value="Antiquekhite"/>
</Style>
该样式应用于各个TextBlock元素,它们为TextBox和ComboBox控件(用于输入客户信息)提供标签。样式引用了和标题一样的字体样式,但将其他属性设为更适合标签的值。
20.返回MainPage.xaml文件。在XAML窗格中修改customersSTabularview和customersColumnarViewGrid控件中的所有标签 TextBlock 控件:删除HorizontalAlignment、Textwrapping、VerticalAlignment和 FontSize属性并引用 LabelStyle样式,如加粗的部分所示。
<Grid x:Name="customersTabularView" Margin="18,20,18,20"Visib1lity="Visible">
	...
	<Grid Grid.Row="2">
		...
		<TextBlock Grid.Row="0"Grid.Column"1"Style"{StatidResource Labelstyle}"
Text="ID"/>
		<TextBlock Grid.Row="0" Grid.Colum="3"Styles"{StaticResource LabelStyle}"
Text="Title"/>
		<TextBlock Grid.Row="0"Grid.Column="5"Style="{StaticResource Labelstyle}"
Text="First Name"/>
		<TextBlock Grid.Row="0" Grid.Column=7"Style="{StaticResource Labelstyle}"
Text"Last Name"/>
		...
		<TextBlock Grid.Row="3"Grid.Colum="1"Style="{StaticResource LabelStyle}"
Text="Email"/>
		...
		<TextBlock Grid.Row="5"Grid. Colum"1" Style="{StaticResource Labelstyle}
Text="Phone"/>
		...
		</Grid>
	</Grid>
	<Grid x:Names"customersColumarVieM"Margin="18,20,18,20"Visibility"Collapsed">
		...
		<Grid Grid.Row="1">
		...
		<Text8lock Grid.ROwe"e"Grid.Colum="e" Style="{StaticResource Labelstyle}"
Texte"ID"/>
		<TextBlock Grid.ROw="i"Grid.Columa"e"Style="{StaticResource Labelstyle}"
Text"Title"/>
		<TextBlock Grid.Row="2" Grid.Columm="0" Style="{StaticResource Labelstyle}"
Text="First Name"/>
		<TextBlock Grid.Row="3"Grid.Colum="0" Style"{StaticResource LuabelStyle}"
Text="Last Name"/>
		...
		<TextBlock Grid.Row="4"Grid.Colum="0" Style="{StaticResource LabelStyle}"
Text="Email"/>
		...
		<TextBlock Grid.Row="5"Grid.Colum="0"Style="{StaticResource Labelstyle}"
Text="Phone"/>
		...
	</Grid>
</Grid>
21.在"调试"菜单中选择"开始调试"生成并运行应用程序。
注意 分辨率低于1366×768就用模拟器运行
将显示Customers窗体并应用和设计视图一样的样式。在文本框中输入任意英语文本,注意,它们使用的是TextBox控件的默认字体和样式
注意 虽然Segoe Print 字体显示标签和标题效果不错,但不适合数据输入,因为有的字符很难区分。例如,小写字母（和数字1就很像,大写字母O和数字O几乎一模一样。因此,就用TextBox控件的默认字体好了.
22.改变窗口大小,验证在窄视图中,customersColumnarView网格中的控件也正确应用了样式
23.返回 Visual Studio 并停止调试。
可用样式轻松实现许多很酷的效果。此外,和单独设置属性相比,精心设计的样式还使代码变得更易维护。例如,要改变Customers 应用的标签和标题字体,单独修改FontStyle样式就可以了。总之,要尽量使用样式。除了增强可维护性,样式还使窗体的XAML标记变得更简洁。窗体的XAML只需指定控件和布局就可以了,不必指定控件如何在窗体上显示。还可使用Microsoft Blend for Visual Studio 2017定义复杂样式并将其集成到应用程序。专业图形艺术家可用Blend生成定制样式,以XAML标记的形式将样式提供给应用程序开发人员。开发人员为UI元素添加合适的Style标记来引用这些样式。

在UWP应用中显示和搜索数据
理解如何使用Model-View-ViewModel模式实现UWP应用的逻辑
使用数据绑定显示和修改视图中的数据
创建ViewModel使视图能和模型交互
将UWP应用和Cortana集成,提供语音激活的搜索功能

实现 Model-View-ViewModel模式
结构良好的UWP应用会将UI设计与应用程序使用的数据和实现应用程序功能的业务逻辑分开。这有助于避免各个组件之间的依赖性,修改的数据的呈现方式不需要修改业务逻辑或底层数据模型。另外,不同的人可以方便地设计和实现不同的元素。例如,图形艺术家专注于UI外观设计,数据库专家专注于实现高效的数据结构集来存取数据,而C#开发人员专门负责业务逻辑。这是很常见的开发模式,并非UWP应用独享。过去几年间,人们开发了许多技术来进行完善。
最流行(虽然有争议)的是 Model-View-ViewModel(MVVM)设计模式。在该设计模式中,模型(Mode)提供应用程序需要的数据,视图（View)则指定数据在UI中的显示方式。视图模型(ViewModel包含用于连接两者的逻辑,它获取用户输入并将其转换成对模型执行业务操作的指令:它还从模型获取数据,并以视图要求的方式格式化。下图展示了MVVM模式各元素间的关系。注意,应用程序可能提供相同数据的多个视图。例如在UWP应用中,可实现不同的可视状态,用不同的屏幕布局来呈现信息。ViewModel的一个工作就是确保来自相同模型的数据能由不同视图显示和处理。在UWP应用中,视图可配置数据绑定以连接ViewModel提供的数据。另外,视图可调用由ViewModel实现的命令,请求ViewModel更新模型中的数据或执行业务操作。

通过数据绑定显示数据
开始为Customers应用实现ViewModel之前,有必要先了解一下数据绑定,以及如何运用这种技术在UI中显示数据。数据绑定允许将控件的属性和对象的属性链接起来;对象属性值改变,控件属性值也改变。数据绑定还可以是双向的:控件属性值改变,对象属性也改变。以下练习演示了如何用数据绑定显示数据。
通过数据绑定显示客户信息
1.启动Visual Studio 2017。
2. 打开"文档"文件夹下的MicrosoftPress\VCSBS\Chapter26\DataBinding子文件夹中的Customers解决方案。它克隆了第25章开发的Customers 应用,但UI布局稍有变动,即控件在蓝色背景上显示,显得更醒目。
注意 蓝色背景用一个 Rectangle控件创建,该控件跨越和显示标题/数据的TextBlock/TextBox控件一样的行和列.矩形用LinearGradientBrush填充,从顶部的中蓝色渐变到底部的深蓝色。下面是customersTabularViewGrid控件中的Rectangle控件的XAML标记.(customerSColumnarView Grid控件包含类似的Rectangle控件,跨越那个布局使用的行和列.）
<Rectangle Grid.Row="0" Grid.Rom6pan="6" Grid.Column="1" Grid.Columspan="7"...>
	<Rectangle.Fill>
		<LinearGradientBrush EndPoint="0.5,1"StartPoint="0.5,0">
			<GradientStop Color="#FF0E3895"/>
			<GradientStop Color="#FF141415" Offset="e.929"/>
		</LinearGradientBrush)
	</Rectangle.Fill>
</Rectangle>
3. 在解决方案资源管理器中右击Customers 项目,选择"添加" "类"。
4.在"添加新项"对话框中确定选中的是"类"模板,在"名称"文本框中输入Customer.es,单击"添加"。将用该类实现Customer数据类型,然后实现数据绑定,以便在UI中显示Customer对象的详细信息。
5. 在Customers.cs 文件中使Customer类成为公共类,添加以下加粗的私有字段和公共属性。
public class Customer
{
	public int _customerID;
	public int CustomerID
	{
		get => this._customerID;
		set{this._customerID= value;}
	}

	private string _title;
	public string Title
	{
		get m=> this._title;
		set{this._title = value;}
	}

	public string _firstName;
	public string FirstName
	{
		get m> this._firstName;
		set{this._firstName = value;}
	}

	public string _emailAddress;
	public string EmailAddress
	{
		get => this._emalAddress;
		set{this._emailAddress a value;}
	}

	public string _phone;
	public string Phone
	{
		get => this._phone;
		set{this.phone value;}
	}
}
注意 你可能奇怪这些属性为何不作为自动属性实现,毕竟它们唯一做的事情就是获取和设置字段值．但下一个练习将为这些属性添加额外的代码。
6.在解决方案资源管理器中双击MainPage.xaml文件显示设计视图。
7.在XAML窗格中找到id TextBox控件并修改其Text属性,如加粗部分所示:
<TextBox Grid.Row="1"Grid.column="1"x:Name="id"...
Texta"{Binding CustomerID}".../>
Text="{Binding路经"指出 Text属性的值在运行时由路径表达式提供。本例的路径是CustomerID,所以控件将显示CustomerID表达式的值。但需提供更多信息指明CustomerID实际是Customer对象的属性。这需要设置控件的DataContext
属性,这将在稍后进行。
9.为窗体上其他每个文本控件都添加以下绑定表达式。将数据绑定应用于customersTabularView和customersColumnView Grid控件中的TextBox控件,如加粗部分所示。
<Grid X:Namea"custonersTabularVies"...>
	...
	<TextBox Grid.Row="1"Grid.Colum="5"X:Name="firstName"...
Text="(Binding Firstame}".../>
	<TextBox Grid.Row="1"Grid.Colum="7"x:Nane="lastame"..
Text"(Binding LastName}".../>
	...
	<TextBox Grid.Row="3"Grid.Colum="3"Grid.ColummSpan="3"
X:Name="email"...Text="{Binding EmailAddress}"../>
	...
	<TextBox Grid.Row="5"Grid.Colum="3"Grid.Columnspan="3"
x:Namem"phone".….Text="{Binding Phone}"..."/>
</Grid>
<Grid x:Name="customersColummarView"Margin="10,20,10,20"
Visibility="Collapsed">
	...
<TextBox Grid.Row="0"Grid.Column="1"x:Name="cId"...
Text="{Binding CustomerD}".../>
	...
	<TextBox Grid.Row="2"Grid.Coluna"1"x:Name="CFirstNane"...
Text="(Binding FirstName}".../>
	<TextBox Grid.Rowe"3"Grid.Column="1"x:Name=cLastName"...
Text="{Binding LastName}".../>
	...
	TextBox Grid.Row="4"Grid.Column="1"x:Name="cEmail"...
Text="{Binding EmailAddress}".../>
	...
	TextBox Grid.Row="5"Grid.Column="1"x:Name="cPhone"...
Text="{Binding Phone}".../}
<Grid>
注意 同一个绑定表达式可用于多个控件。例如,id和cId这两个TextBox控件都使用了{BindingCustomerID}表达式,所以两者显示一样的数据
9. 在解决方案资源管理器中展开MainPage.xaml文件,双击MainPage.xaml.cs文件来显示它。在MainPage构造器中添加以下加粗的语句
public MainPage()
{
	this.InitializeComponent()

	Customer customer = new Customer
	{
		CustomerID = 1, 
		Title="Mr",
 		Firstame ="John" 
 		LastName ="Sharp",
		EmailAddress"john@contoso.com", 
		Phone = "111-1111"
	};
}
代码创建Customer类的新实例并填充一些示例数据。
10.创建好新的Customer对象后,添加以下加粗的语句。
Custoner customer = new customer
{
	...
};
this.DataContext = customer;
该语句指定 MainPage 窗体上的控件要绑定到哪个对象。每个控件的XAML标记Text="{Binding路径}"都针对该对象进行解析。例如,idTextBox和cIdTextBox控件都指定了Text="{BindingCustomerID}",所以都显示窗体绑定到的那个Customer对象的 CustomerID属性的值。
注意 本例设置窗体的 Dataontext属性,向窗体的所有控件都自动应用同一个数据纳定,也可设置单独控件的DataContext属性,将个别控件绑定到不同对象．
11.在"调试"菜单中选择"开始调试"生成并运行应用程序。
12.将应用切换到窄视图,验证显示相同的数据,窄视图和全屏幕视图中的控件绑定到相同的数据。
13.在窄视图中,将电子邮件地址更改为john@treyresearch.com。
14.将应用切换回宽视图,注意,该视图中的电子邮件地址没有变化。
15.返回Visual Studio并停止调试。
16.在Visual Studio 中显示Customer类的代码,在EmailAddress属性的set属性访问器中设置断点。
17.在"调试"菜单中选择"开始调试"。
18.调试器第一次到达断点时,按功能键F5继续运行。
19.Customers 应用程序 UI出现后,切换到窄视图并将电子邮件 改为john@treyresearch.com。
20.切换回宽视图。注意调试器没有到达EmailAddress属性的set访问器的断点。也就是说,emallTextBox失去焦点时,更新的值没有写回Customer对象。
21.返回Visual Studio并停止调试
22.删除断点。

通过数据绑定修改数据
上一个练习演示了如何通过数据绑定显示对象中的数据。但数据绑定默认是单向操作,对显示的数据进行的任何改动都不会写回数据源。证据就是在窄视图中修改电子邮件地址,切换回宽视图数据根本没变。可修改XAML标记的Binding规范的Mode参数来实现双向数据绑定。Mode参数指定数据绑定是单向(默认)还是双向。下一个练习演示具体做法。
实现双向数据绑定来修改客户信息
1.在设计视图中显示MainPage.xaml文件,修改每个TextBox控件的XAML标记如加粗部分所示:
<Grid x:Name="customersTabularView"...>
	...
	<TextBox Grid.Row="1" Grid.Column="1"x:Name="id"...
Text="{Binding CustomerID,Mode=TwoWay)".../>
	...
	<TextBox Grid.Row="1"Grid.Column="5"x:Name="firstName".. 
Text="FirstName,Mode=TwoWay}"../>
	<TextBox Grid.Row="1" Grid.Column="7" x:Name="lastName"...
Text="{Binding LastName,Mode=TWoWay}".../>
	...
	<TextBox Grid.Row="3"Grid.ColumN="3"Grid.ColumnSpan="3" 
x:Name="email"...Text="{Binding EmailAddress,Mode=TWoWay)"../>
	...
<TextBox Grid.Row="5"Grid.Column="3"Grid.Columspanm="3" 
x:Name="phone"...Text="{Binding Phone,Mode=TWoWay}"..."/>
</Grid>
<Grid x:Name="customersColumarView"Margin="10,20,10,20"...>
	...
	<TextDox Grid.Row="e"Grid.Column="1"x:Name="cId"...
Text="{Binding CustomerID,Mode=TWoWay}".../>
	...
	<TextBox Grid.Row="2"Grid.Column="1"x:Name="cFirstName"...
Text="(Binding FirstName,Mode=TWoWay}".../>
	<TextBox Grid.Row="3"Grid.Column="1"x:Name="cLsastName"...
Text="(Binding LastName,Mode=TWoWay}".../>
...
	<TextBox Grid.Row="4"Grid.Column="1"x:Name="cEmail"...
Text="(Binding FirstName,Mode=TWoWay}"../>
...
	<TextBox Grid.Rowe"5"Grid.Columm"1"x:Name="cPhone".
Text="(Binding Phone,Mode=TWoMay)".../>
</Grid>
Binding规范的Mode参数指出数据绑定是单向(默认)还是双向。将Binding规范的Node参数设为TMokay,任何更改都将传回控件所绑定的对象。
2.在"调试"菜单中选择"开始调试"来生成并运行应用程序。
3. 以宽视图显示应用时,将电邮地址更改为john@treyresearch.com,然后改变窗口大小,以窄视图显示应用程序。注意,虽然将数据绑定模式更改为Twoway,但窄视图显示的电子邮件地址没有更新,仍是john@contoso.com。
4.返回Visual Studio并停止调试。
显然有什么地方不对!现在的问题不是数据有没有更新,而是视图不显示数据的最新版本(重新在Customer类的EmailAddress属性的set访问器中设置断点,会发现每当电子邮件地址发生改变,而且焦点从TextBox控件离开时,都会到达断点)。数据绑定不是魔法,它无法知道所绑定的数据何时已发生变化。对象需要向UI发送一个PropertyChanged事件来告诉数据绑定发生了变化。该事件是INotifyPropertyChanged接口的一部分,支持双向数据绑定的所有对象都应实现该接口。这正是下个练习要做的事情。
在Customer类中实现 INotifyPropertyChanged接口
1.在Visual Studio 中显示Customercs文件。
2．在文件顶部添加以下 using指令:using System.componentModel;
该命名空间定义了INotifyPropertyChanged接口。
3.修改 Customer类来实现INotifyPropertyChanged接口,如加粗部分所示:
public class Customer:IMotifypropertyChanged
4.将以下加粗的 PropertyChanged 事件添加到Customer类,放到Phone属性后:
public class Customer:INotifyPropertyChanged
{
	...
	public string _phone;
	public string Phone{
		get{return this._phone;）
		set{this._phone = value;）
	}

	public event PropertyahangedEventHandler PropertyChanged;
}
INotifyPropertyChanged接口唯一定义的就是该事件。实现该接口的所有类都必须提供该事件,而且每次要向外部世界通知一个属性值的变动时都应引发该事件。
5.在Customer类中添加以下方法,放到PropertyChanged 事件后:
public class Customer:INotifyPropertyChanged
{
	...
	public event PropertythangedEventHandler PropertyOhanged; 
	protected virtual void OnPropertyChanged(string propertyName)
	{
		if (PropertyChanged != null)
		{
			PropertyChanged(this,new PropertyahangedEventArgs(propertyName));
		}
	}
}
OnPropertyChanged 方法引发 PropertyChanged 事件。PropertyChanged 事件的PropertyChangedEventArgs 参数指定了发生改变的属性的名称。该值作为参数传给 OnPropertyChanged方法。
注意 可用空条件操作符(?.)和Invoke 方法将OnPropertyChanged 方法的代码精简为一个语句,例如:
PropertyChanged?.Invoke(this,new Property hangedEventArgs(propertyName);
但我的个人习惯是优先可读性而不是代码简化,这样以后好维护。
6.修改 Customer 类的所有属性的set访问器,指定在值被修改时都调用OnPropertyChanged方法。如加粗的部分所示:
public class Customer:INotifypropertyChanged
{
	public int _customerID;
	public int CustomerID
	{
		get =>this._customerID;
		Set
		{
			this._customerID = value;
			this.OnPropertyChangad(nameof(CustomerID);
		}
	}
	public string_title;
	public string Title
	{
		get => ths.title;
		set
		{
			this. title = value;
			this.OnPropertyahanged(nameof(Title);
		}
	}
	public string_firstame;
	public string FirstName
	{
		get => this.firstName;
		set
		{
			this.firstName value;
			this.OnPropertyOhanged(nameof(FirstName));
		}
	}
	publlc string lastName;
	public string LastName
	{
		get a>this._lastName;
		set
		{
			this.lastName value;
			this.OnPropertyOhanged(nameof(LastName));
		}
	}
	public string _emallAddress;
	public string EmailAddress
	{
		get => this.phone;
		set
		{
			this.phone = value;
			this.OnPropertyChanged(nameof(Phone))
		}
	}
	...
}
这里演示的nameof操作符是C#的一个很少使用、但用处很大的功能。它以字符串形式返回作为实参传递的变量的名称。不使用nameof 操作符,就必须使用硬编 码的字符串值。例如;
public int CustomerID
{
	get => this._customerID;
	ser
	{
		this._customerD a value;
		this.OnPropertyChanged("CustomerID");
	}
}
虽然用字符串值能少打一些字,但将来如果修改了属性名称就可能造成bug。原因是本应同时修改字符串值。如忘记修改,代码仍能编译并运行,只是在运行时对属性值的任何修改都不会引发事件。这会造成很难发现的bug。而使用nameof操作符,属性名变化后如果忘记修改传给nameof的实参,代码将不能编译,使你能快速、方便地修正。
7.在"调试"菜单中选择"开始调试"来生成并运行应用程序。
8.以宽视图显示应用时,将电子邮件地址更改为john@treyresearch.com,将电话号 码更改为222-222。
9.改变窗口大小,以窄视图显示应用,验证电子邮件和电话都已改变。
10.在窄视图中将 FirstName 更改为James,再在宽视图中验证名字已改变。
11.返回Visual Studio 并停止调试。

为 ComboBox控件使用数据绑定
为TextBox或TextBlock 等控件使用数据绑定很简单,但ComboBox控件较为特殊,因为它实际要显示两样东西:下拉列表(供用户从中选择一项)和当前选定的那一项的值。如实现数据绑定来显示ComboBox控件下拉列表中的值列表,那么用户选择的值必须是该列表的成员。在Customers应用中,可设置Selectedvalue属性,为titleComboBox控件的当前选定值配置数据绑定,如下所示
<comboBox...x:Names"title"…. Selectevaluem"(Binding Title}"./>
但要记住,下拉列表的值列表是硬编码到XAML标记中的,如下所示:
<ComboBox...X:Names"title"...
	<ComboBoxtem Contenta"Mr"/>
	<ComboBoxIten Content="Wrs"/>
	<ComboBoxItemContent="Ns"/>
	<ComboBoxItemContent="Miss"/>
</ComboBox>
该标记在控件创建后才会实际应用,所以数据绑定指定的值在列表中是找不到的。构造数据绑定的时候,列表还不存在!结果是值不会显示。如果愿意可自行尝试——像上面展示的那样配置SelectedValue属性的数据绑定并运行应用程序。最初显示时,title ComboBox将是空白的,即使客户有Mr的称谓。
有几个解决方案,但最简单的就是创建包含有效值列表的数据源,然后指定ComboBox控件将该列表作为下拉列表的值列表。该步骤要在为ComboBbox应用数据绑定之前完成。
为title ComboBox控件实现数据绑定
1.在Visual Studio 中显示MainPage.xaml.cs 文件。
2.将以下加粗的代码添加到MainPage 构造器中:
public MainPage()
{
	this.InitallzeComponent();
	List<strling titles a new List<string>
	{
		"Mr","Mrs","MS","Miss"
	};
	this.title.ItemsSource = titles;
	this.cTitle.ItemsSource= titles;

	Customer customer = new Customer
	{
		...
	};
	this.DataContext = customer;
}
上述代码创建一个字符串列表,其中含有客户所有可能的称谓。然后,代码设置两个titleComboBox控件的ItemsSource属性来引用该列表(记住每个视图都有一个ComboBox控件)。这些代码的位置至关重要。它们必须在设置MainPage窗体的DataContext属性
之前运行,也就是必须在数据和窗体上的控件绑定之前运行。
注意 商业应用一般从数据库或其他数据源获取CombOBox控件所显示的值列表,而不是使用硬编码的列表。
3. 用设计视图显示MainPage.xaml。
4.如加粗的代码所示修改title和cTitle ComboBox控件的XAML标记。
<Grid x:Names"customersTabularView"...>
	...
	<ComboBox Grid.Row="1"Grid.Column="3"X:Name="title"...
Selectedvalue="(Binding Title,Mode=Twoway}">
	</ComboBox>
	...
</Grid>
<Grid X:Name"customersColumarView"...>
	...
	<ComboBox Grid.Row="1"Grid.Column="1"x:Name="cTitle"...
SelectedvalueValue="{Binding Title,Mode=TwoWay}">
	</ComboBox>
	...
</Grid>
注意,每个控件的ComboBoxItem元素列表已经删除了,而且SelectedValue属性配置成与Customer对象的Title字段绑定。
5.在"调试"菜单中选择"开始调试"生成并运行应用程序。
6.在宽视图中,验证客户称谓正确显示(默认 Mr)。点击ComboBox控件的下箭头,验证其中包含 Mr、Mrs、Ms和Miss等值
7. 改变窗口大小以窄视图显示应用并进行相同的检查。注意,可在窄视图中更改称谓。切换回宽视图后将显示新称谓。
8.返回VisualStudio并停止调试。

创建ViewModel
前面探讨了如何配置数据绑定将数据源同UI 控件连接,但所用的数据源非常简单,仅由单个客户构成。现实世界的数据源一般复杂得多,由不同对象类型的集合构成.用MVVM的术语来说,数据源一般由模型提供,而U(视图)只是间接地通过一个Viewodel对象与模型通信。这里的基本出发点是,模型和视图应相互独立;修改UI不需要修改模型,而修改了模型之后,UI不需要跟着修改。
ViewModel 在视图和模型之间建立了连接,还实现了应用程序的业务逻辑。同样地,业务逻辑应独立于视图和模型。ViewModel通过实现一组命令向视图公开业务逻辑。UI可根据用户在应用中的导航方式来触发命令。下个练习将扩展Customers 应用,实现包含Customer 对象列表的模型,并创建ViewModel来提供命令,使视图能在不同客户之间移动。
创建ViewModel来管理客户信息
1.打开"文档"文件夹下的Microsoft Press\VCSBS\Chapter26\ViewModel文件夹中的Customers解决方案,它是之前同名应用程序的完成版本。如愿意,可继续使用自己的版本。
2.在解决方案资源管理器中右击Customers 项目,选择"添加"|"类"。
3.在"添加新项"对话框的"名称"框中输入ViewModeL.cs,单击"添加"。该类提供基本的ViewModel,其中包含一个Customer 对象集合。UI 将和该Viewodel公开的数据绑定。
4.在ViewModel.cs 文件中将类标记为 public,添加以下加粗的代码:
public class VieModel
{
	private List<Customer>customers;

	public VieModel()
	{
		this.customers = new List<Customer>
		{
			new Customer{
				CustomerID = 1,
				Title = "Mr",
				FirstName="John",
				LastName:"Sharp",
				EmailAddress="john@contoso.com",
				Phone="111-11"},
			new Customer{
				CustomerID = 2, 
				Title = "Wrs", 
				FirstName="Diana" 
				Lastamem"Sharp", 
				EmallAddress"diana@contoso.c
				Phone="11-1112"),
			newCustomer{ 
				CustomerD a 3, 
				Title = "Ms",
				FirstName="Francesca":
				LastName="Sharp",
				EmailAddresse"frankie@contoso.con
				Phone="111-1113

		}
	}
}
ViewModel类将一个List<Customer>对象作为它的模型,构造器用示例数据填充该列表。严格地说,应将数据放到一个单独的Nodel类中。但考虑到本练习的目的，我们就使用这些示例数据。
5.在Viewodel类中添加以下加粗的私有变量currentCustomer,在构造器中把它初始化为零:
class ViewModel
{
	private List<Customer> customers;
	private int currentCustomer;

	public VewModel()
	{
		this.currentCustomer = 6;
		this.customers = new List<Customer>
		{
			...
		}
	}
}
ViewModel类用该变量跟踪视图当前显示的Customer对象。
6.在Viewodel类中添加Current属性,放到构造器之后:
class VieModel
{
	...
	public ViewModel()
	{
		...
	}

	public Customer Current
	{
		 get=>this.customers.Count>0?this.customers[currentCustomer]:null;
	}
}
Current属性访问模型中的当前 Customer对象。没有客户就返回 null。
注意 最好为数据模型提供受控访问;只有ViewModel才能修改模型。但这并不会妨碍视图更新ViewModel呈现的数据———它只是无法修改模型来引用不同的数据源.
7.打开 MainPage.xaml.cs 文件
8.在MainPage构造器中删除创建Customer对象的代码,替换成创建ViewModel类实例的一个语句。修改设置MainPage对象的 DataContext属性的语句来引用新的Viewodel对象,如加粗的语句所示:
public MainPage()
{
	...
	this.cTitle.ItemsSource titles;
	ViewModel viewModel a new ViesNodel();
	this.DataContext = viewodel;
}
9.在设计视图中打开MainPage.xaml文件。
10.在XAML窗格中修改TextBox和ComboBox控件的数据绑定,引用由ViewModel公开的Current属性所返回的客户对象的属性,如加粗部分所示
<Grid X;Name="customersTabularView"...>
	...
	<TextBox Grid.Row="1"Grid.Columnm"1"x:Namem"id"...
Text="{Binding Current.CustomerID,Mode=TwoWay)".../)>
	<TextBox Grid.Row="1"Grid.Columnm"5"x:Namem"firstName"...
Text="{Binding Current.CustomerID,Mode=TwoWay)".../)>
	<TextBox Grid.Row="1"Grid.Columnm"7"x:Namem"lastName"...
Text="{Binding Current.CustomerID,Mode=TwoWay)".../)>
	<ComboBox Grid.Row="1"Grid.Columa="3"x:Name="title"...
SelectedValue="{Binding Current.Title,Mode=TwoWay}">
	</ComboBox>
	...
	<TextBox Grid.Row="3"Grid.Column="3"...X:Name="email"...
Text="{Binding Current.EmailAddress,Mde=TwoWay }".../>
	...
	<TextBox Grid.Row="5"Grid,Columns"3".….x:Name="phone"...
Text="{Binding Current.Phone,Node=TwoWay}"..."/>
</Grid>
<Grid x:Name="customersColumarView"Margin="10,20,10,20"...>
	...
	<TextBox Grid.Row="1"Grid.Columnm"1"x:Namem"cId"...
Text="{Binding Current.CustomerID,Mode=TwoWay)".../)>
	<TextBox Grid.Row="1"Grid.Columnm"5"x:Namem"firstName"...
Text="{Binding Current.CustomerID,Mode=TwoWay)".../)>
	<TextBox Grid.Row="1"Grid.Columnm"7"x:Namem"lastName"...
Text="{Binding Current.CustomerID,Mode=TwoWay)".../)>
	<ComboBox Grid.Row="1"Grid.Columa="3"x:Name="title"...
SelectedValue="{Binding Current.Title,Mode=TwoWay}">
	</ComboBox>
	...
	<TextBox Grid.Row"4"Grid.Column="1"x:Names"cEmail"...
Text="(Binding Curent.EmailAddress,Mode=TwoWay }".../>
	...
	<TextBox Grid.Row="5"Grid.Column="1"X:Name="cPhone"...
Text"(Binding Current. Phone,Mode=TwoWay )".../>
</Grid>
11.在"调试"菜单中选择"开始调试"生成并运行应用程序。
12.验证应用程序显示客户John Sharp(客户列表的第一个客户)的详细信息。修改客户细节并切换宽窄视图,证实数据绑定仍能正确工作。
13.返回VisualStudio并停止调试。
ViewModel 通过Current属性提供对客户信息的访问,但没有提供在不同客户之间导航的方式。可实现方法来递增和递减currentCustomer变量,使Current属性能获取不同的客户。但这样做的时候,又不能使视图对Viewodel产生依赖。最常见的解决方案是Command模式。在这个模式中,Viewodel用方法来实现可由视图调用的命令。这里的关键在于不能在视图的代码中显式引用这些方法名。所以,需要将命令绑定到由U控件触发的操作。这正是下一节的练习要做的事情。

向ViewModel添加命令
ViewModel所公开的命令必须实现 ICommand 接口,控件的操作才能和命令绑定。该接口定义了以下方法和事件。
CanExecute 该方法返回Boolean值来指出命令是否能够运行。通过该方法,ViewModel可基于上下文来启用或禁用命令。例如,从列表获取下一个客户的命令只有在确实有客户时才执行。没有更多客户,命令应被禁用。
Execute 命令被调用时运行该方法。
CanExecuteChangedViewModel的状态改变时触发该事件。之前能运行的命令现在可能被禁用,反之亦然。例如,假定 UI调用命令从列表获取下一个客户,如果这是最后一个客户,则后续CanExecute调用返回false。这时应触发CanExecuteChanged 事件来指出命令已被禁用。
下一个练习创建泛型Command类来实现ICommand接口。
实现 Command 类
1.在Visual Studio 右击Customers 项目,选择"添加""类"。
2.在"添加新项"对话框的"名称"文本框中输入Command.es,单击"添加"按钮。
3.在Command.cs 文件顶部添加以下using指令:
using Systen.MindoMs.Input;
ICommand接口在该命名空间中定义。
4.使 Command类成为公共类,指定它要实现ICommand接口,如加粗部分所示
public class command:ICommand
{
}
5.在Command类中添加以下私有字段:
publlic class Command:Icommand
{
	private Action methodToExecute= null;
	private Func<bool>methodToDetectCanExecute = null;
}
Action委托引用无参和无返回值的方法。Func<T>委托引用的方法也无参,但要返回由类型参数T指定的那个类型的值。
methodToExecute字段引用的是在被视图调用时由Command对象运行的代码,而methodToDetectCanExecute字段引用的方法检测命令能否运行(取决于应用的状态或数据,命令可能被禁用)。
6. 为Command类添加构造器。构造器获取两个参数:一个Action对象和一个 Func<T>对象,参数值赋给methodToExecute和 methodToDetectCanExecute字段,如以下加粗代码所示:
public Command:IComand
{
	...
	public Comand(Action methodToExecute,Func<bool>methodToDetectCanExecute)
	{
		this.methodToExecute= methodToExecute;
		this.methodTrDetectCanExecute= methodToDetectCanExecute;
	}
}
ViewModel为每个命令都创建该类的实例。ViewModel提供用于运行命令的方法,以及在调用构造器时检测命令是否应该启用的方法,
7.使用methodToExecute 和 methodToDetectCanExecute 字段引用的方法来实现Comand类的Execute和CanExecute 方法,如下所示:
public Comand:IComand
{
	...
	public Command(Action methodToExecute,Func<bool>methodToDetectCanExecute)
	{
		`...
	}
	public void Execute(object parameter)
	{
		this.methodToExecute();
	}
	public bool CanExecute(object parameter)
	{
		if(this.methodToDetectCanExecute == null)
		{
			 return true;
		}
		else
		{
			return this.methodToDetectCanExecute();
		}
	}
}
ViewModel为构造器的methodToDetectCanExecute参数提供了 null引用表明命令总是可以运行, CanExecute返回 true。
8.为 Command类添加公共 CanExecuteChanged 事件:
public Comand:IComand
{
	...
	public bool CanExecute(object parameter)
	{
		...
	}
	publfc event EventandlerCanExecuteChanged;
}
将命令绑定到控件,控件将自动订阅该事件。ViewModel状态更新且CanExecute的返回值改变,Comand 对象就应引发该事件。最简单的做法是使用计时器按大致每秒一次的频率引发CanExecuteChanged事件。然后,控件可调用CanExecute
判断命令是否仍可执行,并根据结果启用或禁用自己。
9 在文件顶部添加以下 using指令:
using Windows.UI.Xaml;
10.在Comand类中添加以下加粗的字段,放到构造器之前:
public class Ccomand:IComand
{
	...
	private Func<bool> methodToDbetectCanExecute = null; 
	private DispatcherTimer canExecuteChangedventTimer = null;

	public Command(Action methodToExecute,Func<bool>methodToDetectCanExecute)
	{
		...
	}
}
Windows.UI.Xaml命名空间定义的DispatcherTimer类实现了一个计时器,它按指定周期引发事件。将用canExecuteChangedEventTimer字段以1秒的周期引发CanExecuteChanged 事件
11.在Comand类末尾添加以下加粗的 canExecuteChangedEventTimer_Tick方法:
public class Comand:IComannd
{
	...
	public event EventHandler CanExecuteChanged;

	void canExecuteChangedEeventTimer_Tick(object sender,object e)
	{
		if(this.CanExecuteChanged ! = null)
		{
			this.CanExecuteChanged(this,EventArgs.Empty);
		}
	}
}
起码有一个控件绑定到命令,该方法就引发CanExecuteChanged事件。严格地说,引发事件之前,方法还应检查对象的状态是否发生改变。但是,由于计时器周期较长(相对于处理器周期),所以不检查状态变化对性能的影响微乎其微。
12.在Command 构造器中添加以下加粗的语句
public class Command:ICommand
{
	...
	public Command(Action methodToExecute, Func<bool>methodToDetectCanExecute)
	{
		this.methodToExecute = methodToExecute;
		this.methodTcDetectCanExecute = methodToDetectCanExecute;

		this.canExecuteChangedEventTimer= new DispatcherTimer();
		this.canExecuteOhangedEventTimer.Tidk += canExecuteOhangedEventTimer_Tick;
		this.canExecuteChangedEventTimer.Interval= new TimeSpan(0,0,1);
		this.canExecuteChangedEventTimer.Start();
	}
	...
}
这些代码初始化,DispatcherTimer对象,将计时器周期设为1秒并启动计时器。
13.选择"生成"|"生成解决方案"。验证应用程序正确生成。
现在就可以用Command类向Viewodel类添加命令了。下一个练习将定义命令,使视图能在不同客户之间移动。
向Viesodel类添加 NextCustomer和PreviousCustomer 命令
1.在Visual Studio 中显示ViewModel.cs 文件。
2. 在文件顶部添加以下 using 指令,修改VieModel 类的定义来实现INotifyPropertyChanged接口:
...
using System.ComponentModel;

namespace Customers
{
	public class Vieodel:INotifyPropertyChanged
	{
		...
	}
}
3. 在Viewodel类末尾添加 PropertyChanged事件和OnPropertyChanged方法。其实就是在Customer类中添加的代码:
public class Viesodel:INotifyPropertyChanged
{
	...
	public event PropertyOhangedEventHandler PropertyOhanged;
	protected virtual vofld OnPropertyChanged(string propertyiame)
	{
		if（Propertyohanged != null)
		{
			PertyChanged(this, new PropertyChangedEventArgs(propertyame));
		}
	}
}
记住,视图在控件的数据绑定表达式中通过Current属性来引用数据。ViewNodel类移动至不同客户时,必须引发PropertyChanged 事件通知视图要显示的数据发生了变化。
4.在Viewodel类中添加以下字段和属性,放到构造器之后:
public class ViewDdel :INotifypropertyChanged
{
	...
	public ViewMdel()
	{
		...
	}

	private bool_isAtStart;
	public bool IsAtStart
	{
		get > this.isAtStart;
		set
		{
			this._isAtStart a value;
			this.OnPropertyChanged(nameof(IsAtStart));
		}
		private bool_isAtEnd;
		public bool IsAtEnd
		{
			this._isAtEnd = value;
			this.OnPropertyChanged(nameof(IsAtEnd));
		}
	}
}
将用这两个属性跟踪ViewModel的状态。如ViewModel的currentCustomer字段定位在customers集合起始处,IsAtStart属性将设为true;定位在customers集合末尾,IsAtEnd属性将设为true。
5.修改构造器来设置IsAtStart和ISAtEnd属性,如加粗的语句所示:
public ViewModel()
{
	this.currentCustomer = 0;
	this.IsAtStart = true;
	this.IsAtEnd = false;
	this.customers = new List<Custoner>
	...
}
6. 将以下加粗的私有方法Next和 Previous 添加到Viewodel类,放到 Current属性之后:
public class ViewModel:INotifyPropertychanged
{
	...
	public Customer Current
	{
		if(this.customers.Count-1>this.currentCustomer)
		{
			this.currentCustomer++;
			this.OnPropertyChanged(nameof(Current);
			this.IsAtStart= false;
			this.ISAtEnd =(this.customers.Count-1 == this.currentCustomer):
		}
	}
	private void Prevous()
	{
		if(this.currentCustomer>0)
		{
			this.currentCustomer--;
			this.OnPropertyChanged(nameof(Current)); 
			this.IsAtEnd= false;
			this.IsAtStart=(this.currentCustomer==0);
		}
	}
	...
}
注意 Count属性返回集合中的数据项数量,但记住集合项编号是从0到 Count-1.
这些方法更新currentCustomer变量来引用客户列表中的下一个(或上一个)客户。注意,方法负责维护IsAtStart和ISAtEnd属性的值,并通过为Current属性引发PropertyChanged事件来指出当前客户已发生改变。两个方法都私有,不应从ViewModel类外部访问。外部类通过命令来运行这些方法。命令将在下面的步骤中添加
7.public class Viewodel:INotifypropertyahanged
public class ViewModel:INotifypropertyahanged
{
	private List<Customer>customers; 
	private int currentCustomer;
	public Command NextCustomer{get;private set; }
	public Command PreviousCustomer { get;privte set;}
	...
}
视图将绑定到这些Command 对象,允许在客户之间导航。
8.在Viewodel构造器中设置 NextCustomer 和PreviouSCustomer属性来引用新的Command对象,如下所示:
public ViewModel()
{
	this.currentCustomer = 0; 
	this.IsAtStart = true; 
	ths.IsAtEnd false;
	this.NextCustomer = new Comand(this.Next,()=>
		this.customers.Count >1 && !this.IsAtEnd);
	this.PreviousCustomer = new Command(this.Prevous,()=>
 		this.customers.Count >0 && !this.IsAtStart);
 	this.customers = new List<Customer>
 	{
 		...
 	}
}
NextCustomer Command指定在调用Execute方法时执行Next方法。Lambda表达式()=> this.customers.Count>1 &&Ithis.IsAtEnd)是运行CanExecute方法时要调用的函数。只要客户列表包含至少一个客户,而且ViewModel当前定位的不是列表最后一个客户,表达式就返回 true。PreviousCustomerCommand
大同小异,它调用Previous 方法从列表获取上一个客户,CanExecute方法引用表达式()a>this.customers.Count>0 && !this.ISAtStart)。如客户列表包含至少一个客户,而且ViewModel当前定位的不是第一个客户,表达式就返回true。
9.选择"生成"│"生成解决方案"。验证应用正确生成。
将NextCustomer和PreviousCustomer命令添加到ViewModel中之后,就可以将这些命令和视图中的按钮绑定。点击按钮将运行对应的命令。
Mirosoft发布了在UWP应用中为视图添加按钮的规范。调用命令的按钮一般要放到命令栏上。UWP应用提供了两个命令栏,一个在窗体顶部,一个在底部。在应用或数据中导航的按钮通常放到顶部,下一个练习将采用这个布局。
注意 访问 htp:/msda.microsoftcom/ibraryiwindows/apps/hh465302aspr了解Microsoft命令栏实现规范。

在Customers 窗体中添加 Next和Previous按钮
1.以设计视图显示 MainPage.xaml 文件。
2.滚动到 XAML窗格底部,在结束</Page>标记之前、最后一个</Grid>标记之后添加以下加粗的标记:
	...
	</Grid>
	<Page.TopAppBar>
		<ComandBar>
			<AppBarButton X:Name="previousCustomer" Icon="Previous"
Labels="Previous"Comand="{Binding PathePrevousCustomer}"/>
			<AppBarButton x:Name="nextCustomer"Icon="Next"
Label="Next"Comandm"{Binding Path-NextCustomer}"/>
		</CommandBar>
	</Page.TopAppBar>
</Page>
这些XAML标记有下面几点需要注意。
命令栏默认出现在屏幕顶部并显示按钮图标。每个按钮的标签仅在用户点击命令栏右侧的"更多".)按钮时才显示。但如果应用程序设计在多种语言化中使用,就不要为标签使用硬编码的值。相反,要将标签文本存储到语言文化特有的资源文件中,并在应用程序运行时动态绑定Label属性。欲知详情,请查阅文档中的"本地化UI和应用包清单中的字符串"主题,网址是http:// cn/RDhLomm。
CommandBar控件只能包含有限的一组控件（这些控件实现了ICommandBarElement接口),其中包括AppBarButton, AppBarToggleButton和 AppBarSeparator。这些控件专为CommandBar设计。试图向命令栏添加像按钮这样的控件将显示错误消息:"无法向该集合分配指定的值"。
UWP应用模板包含许多现成的图标供你在 AppBarButton控件上显示（比如示例代码使用的Previous 和Next)。还可定义自己的图标和位图。
每个按钮都有Command属性,可与实现了ICommand接口的对象绑定。本例将按钮绑定到Viewodel类中的PrevousCustomer和NextCustomer 命令。在运行时点击这两个按钮将运行对应的命令。
3.在"调试"菜单中单击"开始调试"。
随即显示Customers 窗体,其中包含John Sharp的详细信息。命令栏在窗体顶部出现,其中包含Next和Previous 按钮,注意,Previous按钮被禁用,这是由于ViewModel的IsAtStart属性为true,Previous按钮引用的Command对象的CanExecute方法指出命令不能运行。
4.点击命令栏最右侧的省略号。将显示所有按钮的文本标签。再次点击省略号恢复。
5.在命令栏中点击Next。随即显示客户2(Diana Sharp）的详细信息。短暂延迟(最多1秒)后,Previous按钮被启用。IsAtStart属性不再为true,所以命令的CanExecute方法返回true。但在命令中的计时器对象到期并触发CanExecuteChanged 事件之前(这要花最多1秒的时间),按钮是不会收到这个更改通知的。
注意 要对命令状态的变化做出更迅捷的响应,可在Command类中设置更短的计时器周期,但不要太短,过于频繁引发CanExecuteChanged 事件只会影响UI性能。
6.在命令栏中再次点击Next。
7.随即显示客户3(Francesca Sharp)的详细信息,短暂延迟后将禁用Next按钮。这次Viewodel的IsAtEnd属性变为true,所以Next按钮引用的Command对象的CanExecute方法返回 true,命令被禁用
8.改变窗口大小,用窄视图显示,验证应用仍能正常工作。利用Next和Previous按钮可在客户列表中前后移动。
9.返回Visual Sudio并停止调试。

用Cortana搜索数据
Windows10应用的一个重要功能是可以和语音激活的数字助理 Cortana(小娜)集成。可用Cortana激活应用并向其传送命令。一个常见的需求是用Cortana发起一个搜索请求,并让应用做出响应。应用可将结果发送回Cortana来显示(称为后台激活),或者应用自己显示结果(称为前台激活)。本节将扩展Customers应用,允许用户根据姓名来搜索特定客户。可自己扩展该应用来覆盖其他属性,或将搜索元素合并成更复杂的查询。
本节的练习要求启用Cortana。右击Windows开始按钮,选择"搜索"。在左侧工具栏中单击"设置"(齿轮图标。在设置页中将"让Cortana 响应"你好小娜""开关从"关"滑动至"开",Cortana还要求用一个Microsoft账户登录,会在必要时提示你连接。该步骤是必要的,因为语音识别由云端而不是本地设备上运行的一个外部服务处理.
为应用添加语音激活分三步走。
1.创建语音命令定义(Voice-Command Definition,VCD)文件,描述应用能响应的命令。这是一个XML文件,作为应用程序的一部分部署。
2.向Cortana 注册语音命令。一般在应用开始运行时做这件事情。应用至少运行一次才能被Cortana识别。之后,如Cortana将某个命令和应用关联,就会自动启动应用。为免词汇表紊乱,Cortana会"遗忘"两周都没有激活过的应用的语音命令。需重新注册才能再次识别。所以,一个常见的实践是应用每次启动都注册语音命令。目的是重置"遗忘"记数器,再为应用争取两周的时间。
3. 在应用中处理语音激活。Cortana 向应用传送与导致应用被激活的命令有关的信息。代码负责解析命令,提取实参并执行恰当的操作。这是实现语音集成最复杂的一步。
以下练习通过Customers 应用演示这一过程
为Customers 应用创建语音命令定义(VCD)文件
1.在 Visual Studio2017中打开"文档"文件夹下的MicrosoftPress\VCSBS\Chapter26Cortana子文件夹中的Customers解决方案。
这个版本的 Customers 应用程序包含上个练习创建好的ViewModel,但数据源包含更多客户的详细信息。客户信息仍然用List<Customer>对象容纳,但这个对象现在由DataSource.cs文件中的DataSource类创建。ViewModel类引用该列表而不是像上个练习那样创建包含3个客户的小集合。
2.在解决方案资源管理器中右击Customers 项目并选择"添加"I"新建项"。
3.在"添加新项"对话框左侧窗格选择"VisualC#",在中间窗格选择"XML文件",在"名称"文本框中输入CustomerVoiceCommands.xml,单击"添加"。
Visual Studio 将生成并显示一个默认XML文件
在XML文件中添加以下加粗的标记。
<?xml version="1.0"encoding="utf-8"?>
<Voicecomands xmlns-"http://schemas,microsoft,com/voicecomands/1.2">
	<CommandSet xml:lang="en-us"Name="CustomersComands">
		<CommandPrefix>Customers</CommandPrefix>
		<Example>Show details of John Sharp</Example>
	</ComandSet>
</VoiceComands>
语音命令在一个命令集中定义。每个命令集都有命令前缀(由ComandPrefix元素指定),Cortana在运行时根据它来识别应用。命令前缀不一定要和应用名称一致。例如,如果应用的名称很长或含有数字,Cortana就可能难以识别。这时可用命令前缀提供更短和更好发音的别名。Example 元素包含一个例句,向用户演示如何调用命令。查询"What can I say?"或"Help"时会显示该例句
注意 命令前缀应反映应用的用途,不要和其他已知应用或服务冲突。例如,如指定命令前缓"Facebook",应用就可能通不过Windows应用高店的审核。
5.居住地不在美国,就将CommandSet元素的xml:lang属性修改成对应的语言文化。例如,开发面向中国的应用就设置xml:lang="zh-cn"。这一点很重要。和本地语言文化不符,Cortana在运行时就无法识别当地的语音命令。该设计的出发点是应该为应用将运行的每一种语言文化都指定单独的CommandSet元素,从而为不同语言文化提供备选命令。Cortana根据运行应用的机器的语言文化来决定要使用哪个命令集。
6.在CommandSet元素中添加以下加粗的Command和PhraseTopic元素。
<?ml version="1.0" encoding"utf-8"?>
<VoicecComands xnlns="http:/schemas.microsoft.com/voicecomands/1.2">
	<ComandSet xmlns:lang="en-us"Name="CustomersComands">
		<CommandPrefix>Customers</CommandPrefix>
		<Example>Show details of John Sharp</Example>
			<Comand Name="showDetails0f">
				<Example>show details of John Sharp</Example>
				<ListenFor RequdreAppName="BeforeOrAfterPhrase">
					show details of {customer}
				</ListenFor>
				<ListenFor RequireAppName="BeforeOrAfterPhrase"
					show details for{customer}
				</ListenFor> 
				<ListenFor RequireAppName="BeforeOrAfterPhrase"
					search for{customer}
				</ListenFor>
				<FeedbackoLooking for(customer}/Feedback>
				<Navigate/>
 			</Command>
			<PhraseTopic Labels"customer"Scenarion"Search">
				<Subject>Person Names</Subject）
			</PhraseTopic>
	</CommandSet>
</VoiceComands>
可在命令集中添加一个或多个命令,每个都调用应用中的一个操作。每个命令都有唯一标识符(Name属性)。该标识符传给 Cortana调用的应用,使应用能判断用户说的是哪个命令,并相应决定要执行的操作。
Example元素中的文本在用户选择你的应用并查询"WhatcanIsay?"时由Cortana显示。Cortana会为你的应用能理解的每个命令显示例句。
Cortana根据ListenFor元素的设置识别用户在发出什么请求时调用该应用。可指定多个ListenFor短语来增强灵活性。在本例中,用户可以说三句话来调用命令。
用户说的话应包含应用的名称或者由CommandSet元素指定的前缀。本例中,名称(或前缀允许在所说的话开始或结束的位置指定(RequireAppName 属性设为BeforeOrAfterPhrase)。例如,"Customers,show details of JohnSharp"或"SearchforJohnSharpinCustomers"。ListenFor短语中的文本{customer}是由PhraseTopic元素(稍后说明）管理的占位符。
Feedback元素设置Cortana在识别出一个请求之后的反馈。{customer}占位符将被替换为用户指定的客户,Navigate元素指定Cortana在前台启动应用。可用该元素的Target属性指定显示哪一页(如应用有多页)。Customers 应用仅一页,所以未指定Target属性。要在后台运行应用并将数据传回Cortana显示,就指定一个VoiceCommandService 元素而不是 Navigate。详情参考"使用语音命令激活后台应用",网址是htutp://cn/RDhG2xp。
PhraseTopic(短语主题）元素在所说的话中定义一个占位符。Label属性指定该元素和哪个占位符关联。在运行时,Cortana将这个位置说的词代入短语主题。
Scenario属性和Subject元素是可选的,用于提示Cortana如何解释这些词。在本例中,所说的词被用作搜索实参并由人的姓名构成。其他Scenario包括ShortMessage或NaturalLanguage。Cortana在这些场景中可能以不同方式对词进行解析。其他 Subject 包括 addresses,phone number 或city and state。
7.选择"文件"│"保存CustomerVoiceCommands.xml"并关闭文件。
8.在解决方案资源管理器中选择CustomerVoiceCommands.xml文件。在属性窗口中,将"复制到输出目录"属性更改为"如果较新则复制"。这会造成XML文件在发生改变后复制到应用程序文件夹,还造成它和应用一起部署。

下一步是应用运行时向Cortana注册语音命令。可在Appxamlcs文件的OnLaunched方法中做这件事情。应用程序每次启动并触发 Launched 事件时将运行该方法。可在应用程序关闭时保存状态信息(例如当前正在看哪个客户的资料）。应用程序下次启动,则利用该事件还原状态(例如显示同一名客户)。还可利用该事件执行应用程序每次运行都应采取的操作。
向Cortana注册语音命令
1.在解决方案资源管理器中展开App.xaml,双击 App.xaml.cs 打开。
2.在文件顶部添加以下 using指令。
using Windows.Storage;
using windows.Applicationodel.Voicecommands;
using Syste.Diagnostics;
3.找到 OnLaunched 方法,添加 async修饰符来启用异步操作。
protected async override void OnLaunched(LaunchActivatedEventArgs e)
{
...
}
4.在OnLaunched 方法末尾添加以下加粗的代码。
protected async override void OnLaunched(LaunchActivatedEventArgs e)
{
	...
	//Ensure the current window is active
	window.Current.Activate();
	try
	{
		var storageFile = await Package.Currenrt.
			InstalledLocation.GetF1leAsync(@"CustomerVoiceComands.xml");
await VoiceComandDefinitionManager.
			InstallCommandDefindtionsFromStorageFlleAsync(storageFile);
	}
	catch(Exception ex)
	{
		Debug.WriteLine($"Instaling VodceCommands Failed:{ex.ToString()}");
	}
}
第一个语句从应用程序文件夹获取包含语音命令定义的XML文件。随后将文件传给VoiceCommandDefintionManager管理器。该类为操作系统提供了注册和查询语音命令定义的接口。静态InstalICommandDefinitionsFromStorageFileAsync方法注册指定存储文件中的语音命令。如在此期间发生异常,异常将被记录,但允许应用程序继续运行(只是不能响应语音命令)。
最后一步是在Cortana 识别出语音命令后让应用做出响应。本例可使用App类的OnActivated方法捕捉Activated事件。向方法传递一个IActivatedEventArgs类型的参数,其中包含对传给应用的数据进行描述的信息,包括任何语音激活命令的细节。
在Customers 应用中处理语音激活
1.在"代码和文本编辑器"窗口中,在App类末尾添加以下OnActivated 事件方法。
protected override void OnActivted(IActivatedeventrgs args)
{
	base,OmActivated(args);
}
处理语音激活之前,该语句先调用被重载的OnActivated方法执行任何必要的默认激活处理。
2.在OnActivated 方法中添加以下加粗的if语句块。
protected override void OnActivated(IActivatedEventArgs args)
{
	base.OnActivated(args);

	if(args.Kind = ActivationkKind.Voicecomand)
	{
		var comandArgs = args as VoiceCommandActivatedEventArgs; 
		var speechRecognitionResult = comandArgs.Result;
		var comandName = speechRecognitionResult.RulePath.First();
	}
}
该块判断应用是不是通过一个语音命令由Cortana激活的。如果是,args参数就包含一个VoiceCommandActivatedEventArgs对象。其Result属性值是一个SpeechRecognitionResult对象,代表用于激活应用的语音命令。该对象中的RulePath 列表包含激活应用的短语(用户说的话)中的元素。其中第一项是Cortana所识别的命令名称。在Customers应用程序中,CustomerSearchCommands.xml文件唯一定义的命令就是 shoMDetailsOf。
3. 在OnActivated 方法中添加以下加粗的代码。
if(args.Kind = ActivationKind.Voficecomand)
{
	...
	var commandName = speechRecognitionResult.RulePath.First();
	string customerName ="";

	switch（commandName)
	{
		case"shoMDetailsOf":
			customerName speechRecognitionResult.SemanticInterpretation.
				Properties["customer"].FirstOrDefault();
			break;
		default:
			break;
	}
}
switch语句验证语音命令是showDetailsOf。添加更多语音命令需扩展此switch语句。语音数据包含的其他未知命令会被忽略。speechRecognitionResult对象的SemanticInterpretation属性包含和Cortana识别的短语的属性有关的信息。Customers应用的命令包括{customer}占位符,代码获取由用户发音并由Cortana解析的该占位符的文本值。
4.在OnActivated方法末尾添加以下加粗的代码,放到switch 语句之后。
protected override void OnActivated(IActivatedEeventArgs args)
{
	...
	if(args.Kind = ActivationkKind.VoiceCommand)
	{
		...
		switch (commmand)
		{
			...
		}

		Frame rootFrame = window.Current.Content as Frame;
		if(rootFrame = null)
		{
			rootFrame = new Frame();
			rootFrame.NavigationFailed += OnNavigationFailed
			Window.Current.Content = rootFrame;
		}

		rootFrame.Navigate(typeof(MainPage),customerName);
		Window.Current.Activate();
	}
}
第一个代码块是样板代码,目的是确保应用程序窗口打开以显示一个页。第二个块在该窗口中显示MainPage页。Frame 对象的Navigate方法造成MainPage成为活动页。该页利用第二个参数传递的对象获取和要显示的内容有关的上下文信息。在本例中,参数是包含客户姓名的一个字符串。
5. 打开ViewModel.cs 文件并找到ViewNodel构造器。该构造器中的代码进行了少许重构,将初始化视图状态的语句移至单独的_initializeState方法中,如下所示:
public ViewModel()
{
	_initializeState();
	this.customers = DataSource.Customers;	
}
private void _initializeState()
{
	this.currentCustomer = 0;
	this.IsAtStart = true;
	this.IsAtEnd = false;
	this.NextCustomer = new Comand(this.Next,()=>
		this.customers.Count>1&& !this.IsAtEnd);
	this.PreviousCustomer= new Command(this.Previous,()=>
	this.customers.Count>0 && !this.IsAtStart);
}
6.为View的odel类添加另一个构造器,获取客户姓名字符串并根据它筛选数据源中的记录。如下所示:
public ViewModel(string customerName)
{
	_initializeState();
	string[] names = customerName.Split(new[] {''}, 2,
		stringsplitOptions.RemoveEmptyeEntries);
	this.customers =
		(fromc in Datasource.Customers
		where string.Compare(c.FirstName. Toupper(),names[0].Tupper())=0 &&
		(names.Length > 1?
		string.Compare(c.LastName.ToUpper(), names[1].ToUpper()==0:true)
		select c).ToList();
}
客户名字可能包含名和姓,也可能只包含其中一项。String类的Split方法根据一个分隔符列表将字符串分解成子串。在本例中,Split 方法将名字分解成最多两部分(如用户提供了以一个或多个空格分隔的名和姓)。结果存储到names数组。LINQ查询利用该数据找出名和names数组第一项匹配,姓和第二项匹配的所有客户。如用户只指定名或姓,则 names数组只包含一项,LINQ查询就只匹配名。为消除大小写敏感性,所有字符串比较都使用字符串的大写版本。最后生成的匹配客户列表赋给视图模型中的customers 列表。
7.返回MainPage.xaml.cs 文件
8.在MainPage类末尾添加以下 OnNavigatedTo 方法,放到构造器后面。
public sealed partial class NadnPage:Pag
{
	public MainPage()
	{
		...
	}
	protected override void OnNavigatedTo(NavigationEventArgs e)
	{
		string customerName = e.Parameter as string;
		if(!string.IsNullOrEmpty(customerName))
		{
			ViewModel vieodel = new Viesodel(customerName);
			this.DataContext = viewModel;
		}
	}
}
OnavigatedTo 方法在应用程序使用 Navigate 方法显示(navigates to)该页时运行。提供的任何实参都出现在NavigationEventArgs参数的Parameter属性中。代码尝试将Parameter属性中的数据转换成字符串。如果成功,就将字符串作为客户名字传给ViewModel构造器。然后将生成的Vewodel(它只包含和该名字匹配的客户)设为页面的数据上下文。
9.选择"生成"│"生成解决方案",验证解决方案成功编译。
作为最后的修饰,下个练习将添加一组图标在Windows10和Cortana中更好地表示你的应用。这些图标比"空白应用"模板默认的灰白色X图标好看多了。

为Customers应用添加图标
1.在解决方案资源管理器中右击Asets文件夹,选择"添加"|"现有项"。
2.切换到"文档"文件夹中的MicrosoftPressVCSBS\Chapter26\Resourcs子文件列选择其中三个AdventureWorks徽标文件,单击"添加"。
3.在解决方案资源管理器中双击Package.appxmanifest文件,在清单设计器中显示它。
4.单击"视觉对象资产"标签,在左侧窗格单击"中等磁贴"。
5.向下滚动至"预览图像"区域,在"比例资产"列表中单击"比例100"图像下方的省略号按钮。切换到Assets 文件夹,选中AdventureWorksLogo150x150.png,单击"打开"。该资产的图像将在框中显示。在左侧窗格单击"应用图标"。向下滚动至"预览图像"区域,在"比例资产"列表中单击"比例100"图像下方的省略号按钮。切换到 Assets 文件夹,选中AdventureWorksLogo44x44.png,单击"打开"。
7.在左侧窗格单击"初始屏幕"。向下滚动至"预览图像"区域,在"比例资产"列表中单击"比例100"图像下方的省略号按钮。切换到 Assets 文件夹,选中AdventureWorksLogo620x300.png,单击"打开"。
7.选择"调试"I|"开始执行(不调试)"来生成并运行应用。验证应用启动时会短暂显示初始屏幕,然后显示客户OrlandoGee的详细信息。应该能和往常一样在客户列表中前进后退。通过运行应用,还向Cortana注册了用于调用应用的语音命令。
8.关闭应用。

测试语音功能
1.激活Cortana并说出以下查询,或在搜索框中键入以下内容:
Customers show detafls forBrlian Johnson
注意 如果是说话而不是打字,记住先用"Hey,Cortana"命令提醒Cortana．不管是说出命令还是打字,Cortana都以相同方式做出响应。
Cortana 应识别该命令,知道它应定向至Customers 应用。Contna 随后启动 Customers 应用并显示 Brian Johnson 的详细信息。注意,命令栏上的Previous 和Next 按钮不可用,因为只有一名匹配的客户
2.返回Cortana,说出以下查询,或在搜索框中键入以下内容:
Search for John in Customers
这次应用会找出所有名字是John的客户。会返回多个匹配项,可用命令栏上的Previous和Next按钮在不同结果之间移动。
3.实验其他搜索。注意可采用"Searchfor…","Showdetailsfor·"和"Showdetailsof…"等形式,并在命令开头或末尾指定应用名称(在末尾指定要附加"in"前缀)）。如键入或说出其他Cortana不理解的形式,Cortana会改为执行一次Bing搜索。
4.完成后返回Visual Studio。

为语音命令提供语音响应
除了向应用发送语音命令,还可让应用提供语音响应,为此,UWP应用要利用Windows10的语音合成功能。实现该功能的过程并不复杂,但有一点要注意:应用只有在收到语音命令后才应该用语音做出响应。如用户是键入而不是说出来,应用应保持静默。幸好,可通过检查 comandNode属性判断命令是说出来的还是键入的。通过对命令执行语义解释来
返回该属性,如下所：
SpeechRecognitionResult speechRecognitionResult=...;
string commandMode = speechRecognitionResult.SemanticInterpretation.
	Properties["comandPode"].FirstorDefault();
commandMode属性值是字符串,根据用户如何输入命令,可能包含"text"或"voice"以下练习将根据该字符串决定应用要用语音来响应还是保持静默。
为搜索请求添加语音响应
1.在Visual Studio 中打开App.xaml.cs 文件。
2.在OnActivated方法中添加以下加粗的语句。
protected override void OnActivated(IActivatedEventAdrgs args)
{
	...
	if(args.Kind == ActivationKind.VodceComand)
	{
		var commandArgs= args as VoiceCommandActivatedEventArgs;
		var speechRecognitionResult = commandArgs.Result;
		var commandName = speechRecognitionResult.RulePath.First();
		string commanMode =speechRecognitionResult. SemanticInterpretation
			Properties["commandMode"].FirstOrDefault();
		string customerName= "";
		...
	}
}
3.在方法末尾修改调用Navigate方法的语句,传递NavigationAngs对象作为第二个参数。该对象包装了客户姓名和命令模式
protected override void OnActivated(IActivatedEventArgs args)
{
	...
	if(args.Kind == Activationkind.VoiceComand)
	{
		...
		switch(comandName)
		{
			...
		}

		...
		rootFrame.Navigate(typeof(MainPage),
			new NavigationArgs(customerName,comanMode));
		Window.Current.Activate()
	}
}
Visual Studio 报告NavigationArgs类型未找到,这是由于NavigationArgs类型还不存在,需要创建。
4.右击代码中的 NavigationArgs对象引用,选择"快速操作和重构"。在弹出菜单中选择"在新文件中生成class"NavigationArgs""这样会创建新文件 NavigationArgs.cs,其中包含私有字段commanMode和customerName,还有对这些字段进行填充的公共构造器。必须修改该类使字段能从外部访问。最好的办法就是将字段转换为只读属性。
5.在解决方案资源管理器中双击NavigationArgs.cs 文件来显示它。
6.修改commandNode和customerName字段,把它们变成可由应用程序其他类型访问的只读属性,如加粗的代码所示。
internal class NavigationArgs
{
	internal string comandode{ get;}
	internal string customertlame{ get;}

	public NavigationArgs(string customerName,string comanMode)
	{
		this.customertName = customerName;
		this.commanMode = comandMode;
	}
}
7.返回MainPage.xaml.es 并找到OnNavigatedTo方法,像下面这样修改该方法。
protected override async void OnNavigatedTo(NavigationEventArgs e)
{
	NavigationArgs args= e.Parameter as NavigationArgs;
	if(args != null)
	{
		string customerName = args.customerName;
		ViewModel viewodel = new ViewModel(customerName);
		this.DataContext = viewModel;

		if(args.comandMode =="voice")
		{
			if(viewModel.Current != null)
			{
				await Say($"Here are the details for{customerName}");
			}
			else
			{
				await Say($"{customertlame} was not found");
			}
		}
	}
}
注意,Say方法尚未实现,稍后创建该方法。
8.在文件顶部添加以下 using指令。
using Windows.Media.Speechsynthesis;
using System.Threading.Tasks;

9.在MainPage类末尾添加以下 Say 方法。
private async Task Say(string message)
{
	MediafElement mediaElement = new MediaElement();
	var synth = now SpecehSynthesizer();
	SpeechSynthesisStream stream =
			await synth.SynthesizeTextToStreamAsymc(message);
		mediaElement.SetSource(stream,stream.ContentType);
		mediaElement.Play();
}
Windows.Nedia.SpeechSynthesis命名空间中的SpeechSynthes1zer类可生成包含合成语音的媒体流。该流传给一个MediaElement对象来播放。
10.选择"调试"|"开始执行(不调试)"来生成并运行应用程序。
11.激活 Cortana并说出以下查询:
Customers show detalls forBrian Johnson
Cortana将在Customers 应用中显示 Brian Johnson的详细信息,并说"Here are the details for Brian Johnson"
12.在Cortana搜索框中手动输入以下查询:
Customers show details for John
验证应用这一次在显示了名为John的客户的列表之后保持静默
13.尝试键入或者说话来实验其他查询。完成后关闭应用。

在 UWP 应用中访问远程数据库
通过实体框架创建实体模型来获取和修改数据库中的信息
创建REST Web服务,通过实体模型提供对数据库的远程访问
使用REST Web服务从远程数据库获取数据
使用REST Web 服务插入、更新和删除远程数据库中的数据

从数据库获取数据
到目前为止,使用的数据都限定为应用的ViewModel中嵌入的简单集合。而真实应用程序所显示和维护的数据一般存储在关系式数据库这样的数据源中。
UWP应用不能通过Microsoft 的技术直接访问关系式数据库(虽然有些第三方数据库解决方案可供选择)。这表面上限制挺大,但实际是有原因的。首先,它消除了UWP应用对外部资源的依赖,使其自成一体,能方便地从 Windows Store打包和下载,无须在计算机上安装和配置数据库管理系统。其次,许多Windows10设备的资源都非常吃紧,没有运 行本地数据库管理系统的内存或磁盘空间。但许多商业应用程序确实需要访问数据库。这
时可用Web服务米满足需求。
Web 服务可实现多种功能,但最常见的还是提供一个接口让应用程序连接远程数据源来获取和更新数据。Web服务可位于任何地方。可以和应用程序在同一台计算机上,也可以在另一个大洲的Web服务器上。只要能连上,就能通过Web 服务提供对自己的信息存储的访问。可利用Visual Studio提供的模板和工具快速和方便地构建Web服务。最简单的
策略是使用实体框架(Entiy Framework)生成实体模型,以该模型为基础创建Web服务。
实体框架是连接关系式数据库的强大技术,它减少了在应用中添加数据访问功能所需的编码量。本章首先设置AdventureWorks数据库,它包含了Adventure Works公司的详细客户信息。
注意 因篇幅有限,本书无法更深入地讨论实体框架的使用。本章的练习只能指导你体验最基本的步骤。参考"实体框架"(htp://msdn.microsof.com/data/a937723)了解更多信息。
为了更真实地模拟现实情况,本章的练习展示了如何使用MicrosoftAzareSQLDatabase创建云端数据库,以及如何在Azure上部署Web服务。这是许多商业应用采用的架构,包括电子商务应用程序、移动银行服务以及视频流系统等。
注意 本章的练习要求 Azure 账户和订阅．如果没有 Azure 账户,可以访问htps:/azure,microsoft.com/pricing/ree-trial/注册试用账户".另外,Azure 要求和Azure 账户关联一个有效的 Microsoft 账户。访问 https:/sigmup.live.com/注册Microsoft 账户.
创建 Azure SQL数据库服务器并安装 AdventureWorks 示例数据库
1.在Web 浏览器中访问 Azure 门户网站 htps:/portal.azure.com(中国版门户则是htps://portal.azure.cn/).用Microsoft 账户登录。新用户请跳过导览。
2. 在左侧单击"创建资源"命令。
3.在"新建"页中单击"Databases"或"数据库",再单击"SQL数据库
4.在"SQL数据库"窗格执行以下任务
4.1 在"数据库名称"文本框中输入AdventureWorks.
4.2 "订阅"框保持当前订阅方式不变。
4.3 在"资源组"区域选择"新建",在文本框中输入awgroup。
4.4 在"选择源"下拉列表中单击"示例(AdventureWorksLT)"。
4.5 在"服务器"区域单击"配置所需的设置"。在"新服务器"窗格为服务器输入唯一性的名称(使用公司名或你自己的名字为佳。我使用csharpstepbystep2017。如输入的名称被占用,系统会提示,此时需输入另一个名称)。再输入管理员登录名和密码。请记录好这些登录凭据。我使用登录名JohnSharp,当然密码不可说。再选择一个就近的位置。完成后单击"选择"按钮,返回"SQL数据库"窗格。
4.6 在"想要使用SQL弹性池?"提示下方单击"不是现在"。
4.7单击"定价层",在配置窗格中单击"Basic"或"基本",最后单击"应用"。如自己为数据库付钱,这是最便宜的选项,足够本章练习使用。但如果要构建真正的大规模商业应用,就可能需要选择一个标准或以上的定价层,它们提供了更多空间和更高性能。价格当然更贵。
重要提示 除非想在月末收到一张大额账单,否则不要选择除基本之外的其他任有价层.访问https:/azuremicrosof.com/h-cn/pricing/details/sql-database/更多地了解 SQLDatabase定价.
4.8单击"创建"等待云端完成数据库服务器和数据库的创建。可单击顶部工具栏上的"通知"查看进度。部署成功后再执行后续操作。
5.单击门户左侧菜单中的"所有资源"命令。
6.在"所有资源"窗格单击你的SQLServer服务器(不是AdventureWorks数据库]
7.在"安全性"区域单击"防火墙和虚拟网络"。
8. 在右侧窗格单击"添加客户端 IP",
9.单击"保存"。验证显示消息"已成功更新服务器防火墙规则"。
注意 这些步骤是必要的,否则无法从你的计算机上运行的应用程序中连接数据库需向一组计算机开放访问权限,也可修改防火墙规则来涵盖一组IP地址。
示例AdventureWorks数据库包含一个使用SalesLT架构(MSDN将schema翻译为架构)的Customer表。该表的列含有要由UWP应用Customers 显示的数据和其他一些东西。可用实体框架选择忽略不相关的列。但如果忽略的列不允许空值又没有默认值,就不能创建新客户。Customer表的NameStyle,PasswordHash和PasswordSalt列(用于加密用户密码)适合该限制。为避免问题复杂化,将精力集中在应用本身的功能上,下个练习将从Customer表中删除这些列。

从AdventureWorks 数据库删除不需要的列
1.在Azure门户中单击"所有资源",单击AdventureWorks数据库。
2.在上方工具栏单击"连接",再单击"VisualSudio"。
3.单击"在Visual Studio 中打开"。
4.取决于所用的浏览器,可能询问是否切换应用程序或者启动外部应用程序。
5.Visual Studio 将连接数据库并在左侧的"SQLServer对象资源管理器"中显示.
6. 在"SOLServer对象资源管理器"窗格中展开AdventurcWorks数据库,展开"表",展开"SalesLT.Customer",再展开"列"
有三列不需要,它们不允许空值,所以必须删除,否则应用程序无法创建新客户。
7.按住Ctrl键,分别单击NameStyle、PasswordHash和PasswordSalt列。按Delete键将其删除。也可右击它们并选择"删除"。
8.Visual Studio分析这些列。
9.单击"更新数据库",
10.关闭 SQLServer对象资源管理器,但不要关闭Visual Studio 2017。

创建实体模型
在云端创建好AdventureWorks 数据库后,可通过实体框架创建实体模型,以便应用程序查询和更新这个数据库中的信息。如果以前用过数据库,可能熟悉像ADO.NET这样的术,可利用它提供的类库来连接数据库并运行SQL命令。ADO.NET很有用,但要求对SOL有较深入的理解。稍不注意就会将重心偏移到执行SQL命令所需的逻辑上,而不是将重心放在应用的业务逻辑上。实体框架提供了新的抽象层,减少了应用对SQL的依赖。
简单地说,实体框架在关系数据库和应用之间实现了一个映射层:它生成由一个由对象集合构成的实体模型,应用像使用其他任何集合那样使用该集合。一个集合通常对应数据库中的一个表,而每个表行都对应集合中的一项。一般用LINQ遍历集合中的项来执行查询。实体模型在幕后将查询转换成SQLSELECT命令来获取数据。可修改集合中的数据,
再安排实体模型生成并执行恰当的SQLINSERT,UPDATE和DELETE命令来进行相应的操作。总之,实体框架是连接数据库并获取和管理数据的好帮手,不要求在代码中嵌入SQL命令。
以下练习为AdventureWorks数据库的Customer表创建非常简单的实体模型。将以所谓的"数据库优先"方式进行实体建模。采用这种方式,实体框架根据数据库中的表的定义来生成类。实体框架还支持"代码优先"方式,即根据应用己实现的类来生成数据库中的表集合。
注意 要更多地了解如何用代码优先的方式创建实体模型,请参考"Code First to an Existing Database"(hitp://cn/RDhKcag)。

创建AdventureWorks 实体模型
1.在Visual Studio2017中打开"文档"文件夹下的MicrosoftPresVCSBS\Chapter27\WebService子文件夹中的Customers解决方案,该项目是上一章 Customers 应用的修改版本。ViewModel包含额外的命令来跳至客户集合的第一个和最后一个客户,命令栏包含First和Last按钮来调用这些命令。另外,Cortana搜索功能已被移除,目的是防止分散注意力。(如果想写一个该应用的语音激活版本,欢迎加回该功能。)
2.在解决方案资源管理器中右击Customers解决方案(不是Customers项目),选择"添加"|"新建项目"。
3.在"添加新项目"对话框中单击左侧的"Web"节点,再单击中间的"ASP.NETWeb应用程序(NETFramework)"模板。注意不要误选"ASP.NETCoreWeb应用程序"模板。在"名称"框中输入AdventureWorksService,单击"确定"。
4.在"新建ASP.NETWeb应用程序"对话框中单击"Azure API应用",验证已勾选"Web API"。单击"确定"。
如前所述,不可以直接从UWP应用中访问关系式数据库,即使是通过实体框架也不可以。相反,必须创建一个AzureAPI应用(这不是UWP应用),并在该应用中包含你创建的实体模型。"Azure API 应用"模板允许构建一个由 Azure 托管的Web服务,以便客户端应用程序快速和方便地连接。"WebAPI"提供了额外的向导和工具,方便你为Web服务快速创建代码,这正是下个练习要做的事情。该Web服务为Customers UWP应用提供对实体模型的远程访问。
5.在解决方案资源管理器中右击AdventureWorksService 项目并选择"属性"。
6.在属性页中单击左侧的"Web"标签,
7.在"Web"页中单击"不打开页面,等待来自外部应用程序的请求"。
从Visual Studio 运行 Web应用程序一般会启动Web 浏览器并显示应用的主页。但 AdventureWorksService 应用没有主页,它的作用是托管Web服务,以便客户端应用连接并从AdventureWorks 数据库获取数据。
8. 在"项目URL"框中将Web应用的地址更改为http:/ocalhost:5000/,单击"建虚拟目录"。在消息框中验证虚拟目录成功创建,单击"确定"。
ASP.NET项目模板创建的Web应用默认使用ISExprss来托管,会为URL选择一个随机端口。本步骤将端口设为50000,以简化后续步骤的描述。
9.选择"文件""全部保存"并关闭属性页。
10.在解决方案资源管理器中,右击AdventureWorksService项目中的"Models"文作夹,选择"添加"│"新建项"
11．在"添加新项"对话框单击"数据"节点。在中间窗格选择"ADONET实体数据模型"模板,在"名称"文本框中输入AdventureWorksModeLedmx,单击"添加" 随后运行"实体数据模型向导",可用它从现有数据库生成实体模型。
12.在"选择模型内容"页中选择"来自数据库的EF设计器",单击"下一步"。
13.在"选择您的数据连接"页中单击"新建连接"。
14.在"选择数据源"对话框中选择"MicrosoftSQLServer",单击"继续",注意,只有在之前没有使用数据连接向导并选择数据源的前提下才会出现"选择数据源"对话框。
在"连接属性"对话框中,找到"服务器名"文本框,在其中输入<servername>.database,windows,net。如果 是 中国版 Azure,则输入<servername>.database.chinacloudapL,cn。其中<servername>是上个练习创建的
Azure SOLDatabase服务器的名称。从"身份验证"下拉列表中选择"SQLServer身份验证",输入上个练习设置的管理员登录名和密码。单击"保存密码"。在"选择或输入数据库名称"文本框中输入AdventureWorks,单击"确定"。这个操作将创建到云端AdventureWorks 数据库的连接。
15.回到"选择您的数据连接"页,单击"否,从连接字符串中排除敏感数据,我将在应用程序中设置此数据"。验证已勾选"将Web.Config中的连接设置另存为",并确认连接字符串名称是 AdventureWorksEntities,单击"下一步"。
16.在"选择您的版本"页中选择"实体框架6.x",单击"下一步"。
17.如下图所示,在"选择您的数据库对象和设置"页中,展开"表",展开"SalesLT",再选择Customer。勾选"确定所生成对象的单复数形式"(本页另外两个选项默认勾选)。观察实体框架将在AdventureWorksModel命名空间中为实体模型生成类。单击"完成"。体数据模型向导为Customers表生成实体模型,并在实体模型编辑器中显示一个示意图。如果出现如下图所示的安全警告消息框,请勾选"不再显示此消息"并单击"确定"。出现安全警告是由于实体框架使用名为"T4模板"的技术为实体模型生成代码,当前已用NuGet从网上下载了这些模板.实体框架模板已由Microsoft验证,可以安全使用。
18.在实体模型编辑器中右击 MiddleName 列并选择"从模型删除"。用同样的办法从实体模型删除 Suffix,CompanyName 和 SalesPerson列。
Customers应用用不到这些列,不需要在数据库中检索它们。它们允许空值,所以可作为数据库表的一部分安全存留。但不要删除rowguid和ModifiedDate列。数据库用这些列标识Customers表中的行,并在多用户环境中跟踪对这些行的更改。删除它们会导致不能将数据正确存回数据库、
19.选择"生成"│"生成解决方案"。
20.在解决方案资源管理器中展开AdventureWorksService项目的Models文件夹,展开AdventureWorksModel.edmx,展开 AdventureWorksModel.t双击Customer.cs。该文件包含"实体数据模型向导"生成的代表客户的类。类中包含和添加到实体模型的Customer表的每一列对应的自动属性。
public partial class Custoner
{
	public int CustomerID {get; set;}
	public string Title{ get;set;}
	public string FirstName{ get; set;}
	public string LastName{ get;set;}
	public string EmailAdress{ get; set;}
	public string Phone{get; set;}
	public System.Guid roMguid( get;set; }
	public System,DateTime ModifiedDate{get;set;}
}
21.在解决方案资源管理器中展开AdventureWorksModel.edmx下的AdventureWorksModel.Context.tt,双击AdventureWorksModel.Context.cs。
文件包含AdventureworksEntities类的定义(在"实体数据模型向导"中为数据库生成连接时使用的就是这个名称）。
public partial class AdventureiorksEntities:DbContext
{
	public AdventurehaorksEntities()
		:base("namesAdventurehorksEntities")
		{
		}
		protected override void OnModelCreating(DbModelBuilder modelBuilder)
		{
			throw new UnintentionalCodeFirstException();
		}
		public DbSet<CustomeryCustomers { get;set;}
}
AdventureworksEntities 类派生自 DbContext类,应用程序利用该类提供的功能连接数据库。构造器向基类构造器传递一个参数来指定数据库连接字符串的名称。查看Web.config 文件,可在<ConnectionStrings>小节找到该字符串。其中包含运行向导时指定的参数（还有另一些信息)。但是,该字符串不包含对连接进行身
份验证所需的密码信息,因为已选择在运行时提供该数据。这将在后续步骤处理。
可暂时忽略AdventurelorksEntities类中的OnModelCreating方法。现在唯一剩下的就是Customers集合了.该集合的类型是DbSet<Customer>。可利用DbSet泛型类型提供的方法添加、更新、删除和查询数据库中的对象。它和 DbContext类配合使用,能生成对应的SOLSELECT命令从数据库获取信息并填充集合。在集合中添加、修改或删除Customer 对象时,还能生成对应的 SQLINSERT,UPDATE和 DELETE命令。一般将 DbSet 集合称为实体集合。
22.在解决方案资源管理器中右击Models 文件夹,选择"添加""类"。
23.在"添加新项"对话框中确定已选择"类"模板。在"名称"文本框中输入AdventureWorksEntities,单击"添加",
将添加并显示 AdventureworksEntities 类。该类目前和实体框架生成的同名类冲突,但我们要把它转换成分部类,对实体框架代码进行补充。分部类允许将类的代码拆分到一个或多个源代码文件。这对实体框架这样的工具很有用,允许你添加自己的代码,同时即使以后实体框架代码重新生成,也不会将你的代码覆盖。
24. 如加粗部分所示,将AdventureworksEntities 类修改成分部类。
public partial class AdventureworksEntities
{
}
25.在 AdventureworksEntities类中添加构造器来获取名为password的字符串参数。构造器应调用基类构造器,传递之前由实体数据模型向导写入 web.config文件的连接字符串的名称。
public partial class AdventureorksEntities
{
	public AdventureliorksEntities(string password)
		:base("name=AdventurehorksEntities")
		{
		}
}
26.在构造器中添加以下加粗的代码,修改实体框架使用的连接字符串来包含密码。Customers应用将调用该构造器,在运行时提供密码,
public partial class AdventureworksEntities
{
	public AdventureiorksEntities(string password)
		:base("name=AdventurekorksEntities")

		{
			this.Database.connection.Connectionstring += $";Passiord={password}";
		}
}
创建和使用RESTWeb服务
创建好实体模型,它提供了用于获取和维护客户信息的各种操作。下一步是创建Web服务,使UWP应用能访问实体模型。
Visual Studio 2017允许在ASP.NETWeb应用中直接基于实体框架生成的实体模型创建Web服务。Web服务使用实体模型从数据库获取数据以及更新数据库。我们将用"添加基架"向导创建实现了REST模型的Web服务。REST是RepresentationalStateTransfer的简称。REST模型通过一个可导航的架构,基于网络和HTTP协议来表示业务对象和服务,
可发送请求来访问这些对象和服务。要访问资源的客户端应用提交URL形式的请求,Web服务解析并处理该请求。例如,Adventure Works 可通过以下形式发布客户信息,将每个客户的详细信息作为一个资源来公开:
http:/Adventure-works.com/DataService/Customers/1
访问该URL导致Web服务获取客户1的信息。数据可通过多种格式返回,但为了便于移植,一般使用XML和JavaScript ObjetNotation (JSON)格式。针对上述请求,REST Web服务生成的典型JSON 响应如下
{
	"CustomerID":1,
	"Title":"Mr", 
	"Firstame":"Orlando", 
	"LastName":"Gee", 
	"EmaflAddress":"orlandoeadventure-works.com",
	"Phone":"245-55-0173"
}
REST模型要求应用发送恰当的HTTP动词来作为数据访问请求的一部分。例如,上述简单请求应向Web服务发送HTTPGET请求。HTTP还支持其他动词,比如POST,PUT和DELETE(分别用于创建、修改和删除资源。写代码生成正确的HTTP请求以及解析RESTWeb服务的响应,这一切听起来很复杂,但可利用VisualStudio2017提供的"添加基架"向导自动生成其中大多数代码,将主要精力放在应用程序的业务逻辑上。
以下练习将为AdventureWorks 实体模型创建简单的RESTWeb服务,以便客户端应用查询和维护客户信息。
创建 AdventureWorks Web 服务
1.在AdventureWorksService项目中右击Controllers文件夹并选择"添加"|"新搭建基建的项目"。
2.在"添加基架""向导中,在中间窗格选择"包含操作的WebAPI2控制器(使用 Entity Framework)"4,单击"添加"
3.在"添加控制器"对话框中,从"模型类"下拉列表中选择 Customer(AdventureWorksService.Models)。从"数据上下文类"下拉列表中选择AdventureWorksEntities(AdventureWorksService.Models)。勾选"使用异步控制器操作",验证"控制器名称"是CustomersController,单击"添加"。
在使用 ASP.NETWeb API模板创建的Web服务中,所有传入的Web请求都由一个或多个控制器类处理,每个控制器类都为控制器公开的每个资源公开了映射到不同类型的REST请求的方法。例如,CustomersController看起来像下面这样。
public class CustomersController:AdoiController
{
	private AdventureiorksEntities db = new AdventureiorksEntities();

	//T GET apl/Customers
	public IQueryable<Customer>GetCustomers()
	{
		return db.Customers;
	}

	//GET:api/Customers/5
	[Responseype(typeof(Customer))]
	public async Task<IHttpActionResult>GetCustomer(int id)
	{
		Customer customera await db.Customers. FindAsync(id);
		if(customer == null)
		{
			return NotFound();
		}

		return Ok(customer);
	}

	//PUT:api/Customers/5
	[ResponseType(typeof(void))]
 	public async Task<IHttpActionResult> PutCustomer(int id, Customer customer
 	{
 		if(!ModelState.Isvalid)
 		{
 			return BadRequest(ModelState)
 		}
 		if(id != customer.CustomerID)
 		{
 			return BadRequest();
 		}
 		db.Entry(customer).State = EntityState.Modified;

 		try
 		{
 			awit db.SaveChangesAsync();
 		}
 		catch(DbUpdateConcurrencyException)
 		{
 			if(!CustomerExists(id))
 			{
 				return NotFound();
 			}
 			else
 			{
 				throw;
 			}
 		}
 		return StatusCode(HttpStatusCode.NContent);
 	}

	//POST:api/Customers
	[ResponseType(typeof(Customer))]
	public async Task<IHttpActionResult> PostCustomer(Customer customer) 
	{
		...
	}   

	//DELETE:api/Customers/5
	[ResponseType(typeof(Customer))]
	public async Task<IHttpActionResult>DeleteCustomer(int id)
	{
		...
	}
	...
}
GetCustomers 方法获取所有客户,它从之前创建的实体框架数据类型返回整个Customers集合。幕后是由实体框架从数据库获取的所有客户,再用该信息填充Customers集合。客户端应用向Web服务的api/CustomersURL发送HTTPGET请求就会调用该方法。
GetCustomer方法(不是 GetCustomers)获取代表客户CustomerID的一个整数。方法通过实体框架查找客户的详细信息并返回。客户端应用向api/Customers/nURL发送HTTPGET请求就会调用该方法。其中n代表要检索的客户ID。
PutCustomer方法在向Web服务发送HTTPPUT请求时运行。请求指定一个客户ID以及客户的详细信息,方法通过实体框架更新指定客户。PostCustomer方法响应的是HTPPOST请求,获取客户的详细信息作为参数。方法用这些详细信息
向数据库添加新客户。(上述示例代码未显示细节。)最后,DeleteCustomer方法处理HTTPDELETE请求并删除指定ID的客户。
注意 Web API模板生成的代码乐观假设总是能连接到数据库,但在分布式系统的世界里,数据库和 Web服务分开放在不同服务器上,所以这个假设并非一定成立．网络容易出现瞬时误差和超时;一次连接尝试可能因临时故障而失败,短时间重试又好了.向客户端报告这种临时故障有骚扰之嫌,应尽可能悄悄地重试失败的操作,只要重试次数不超出限制(你肯定不想在数据库真的不可用时Web服务假死).要进一步了解这个策略,请参考"Cloud Service Fundamentals Data AccssLayer—Transient Fault Handling"一文(htp:/Lcn/RDhYPSe)。
ASP.NETWebAPI模板自动生成代码,将请求定向至控制器类中对应的方法。如需管理其他资源(例如Products和Orders),可以添加更多的控制器类。
注意 要想进一步了解如何使用 ASP.NETWeb API模板实现RESTWeb服务,请访问htp://www.asp.net/web-api.
可使用和CustomersController类一样的模式手动创建控制器类,并非一定要用实体框架取回和存储数据。ASP.Net Web API模板在ValuesController.cs 文件中包含一个示例控制器,可根据需要定制。
4.在CustomersController类中修改创建 AdventureworksEntities上下文对象的语句,使用获取密码参数的构造器,向构造器传递创建数据库时设置的管理员密码。在以下示例代码中,将YourPassword替换成你的密码。
public class CustomerSearchCommandsController:Apicontroller
{
	private AdventureworksEntitles db = new AdventureiorksEntities("YourPassmord");
	//GET:api/Customers
	public IQueryableCustomer> GetCustomers()
	{
		return db.	Customers;
	}
	...
}
注意 现实世界永远都不要像这样硬编码密码,相反,应把它存储到web.config文件的一个加密区域．详情参考"使用受保护的配置加密配置信息"一文,网址是http://.cn/RDhTbC9.
5.右击 Controllers 文件夹中的ValuesControllercs文件并从弹出菜单中选择"删除"。在消息框中确认删除。本练习不需要使用示例ValuesController类。
6.在解决方案资源管理器中右击AdventureWorksService项目,选择"调试"|"启动新实例"。随后会启动托管了Web服务的ISExpress服务器。VisualStudio报告网站正在运行,但别的提示就没有了。这时需要在浏览器中访问网站,才能验证它是否正常工作。
7.在Web 浏览器地址栏中输入 http:/localhost:500/api/Customers并按Enter键。
Web服务器收到对客户的HTTPGet请求,进而运行你的代码中的GetCustomers方法。结果是以一个JSON数组形式返回的所有客户的列表。
8.将URL 修改成 http://localhost:50000/api/Customers/5。这造成 Web 服务运行GetCustomer(没有s)方法并传递参数5。浏览器将显示客户5的详细信息。
9.关闭浏览器并返回Visual Studio。
10.选择"调试"|"停止调试"。
现在可以将Web服务部署到Azure而不是在本地运行。可用VisualStudio2017的"布Web"向导在云端创建Web应用并上传该应用的Web服务。

将Web 服务部署到云端
1.选择"视图"|"服务器资源管理器"。
2.右击"Azure",选择"连接到Microsof Azure 订阅"。
3.在"登录到您的账户"对话框中输入您的Azure账户凭据。 4.在解决方案资源管理器中右击AdventureWorksService项目,然后边择"发布"。
启动发布向导。
5.确认当前选择的是"新建",单击"发布",
6.在"创建App Service"对话框中接受默认应用名称(这个名称可以记录下来,以后要用作类名)。选择订阅(保持不变就好),确认资源组是 awgroup(之前用Azure门户创建)。单击"托管计划"区域的"新建"。
7.在"配置托管计划"对话框中选择一个就近的位置。在"大小"下拉列表中选择"空闲"或"共享",单击"确定"。
托管计划决定了你的API 应用在云端能享受到的资源。在幕后,Microsoft会将你的API应用放到一个Web服务器中,或者放到一个Web服务器集群中,具体取决于你选择的计划(应翻译成"套餐"）。如构建的是需每秒处理几千个请求的商业应用,自然应选择资源充裕的"计划",价格自然也不菲。目前这个测试型的应用应选择最便宜的。不过,如果只是构思和生成一些小的Web服务,这种"计划"已经足够。
8.这时已回到"创建 App Service"对话框,请单击"创建"。
随后AzureAPI应用将部署到云端。完成后会打开浏览器并显示欢迎页,其中罗列了一些文档链接来指导你使用AzureAPI应用。
9. 关闭Web浏览器并返回Visual Studio
下步是在Customers UWP应用中连接Web服务,并通过Web服务获取数据。以前完成这一步比较麻烦,需要生成HTTPREST请求,把它们发送给Web服务,等待结果,再处理返回的数据,使应用能显示它们(或处理期间发生的错误)。但将 RESTWeb服务作为AzureAPI应用部署之后,Azare能生成大量元数据来描述你的Web服务及其提供的操作。可以使用Visual Studio 的REST API客户端向导查询元数据,向导会生成一个对象模型来连接Web服务并发送请求。该对象模型隔离了通过Web收发数据的低级细节,使你能专注于业务逻辑来显示和处理通过Web服务发布的对象。下个练习将使用这些类。还要用到由Json.NET包实现的JSON 解析器。必须将这个包添加到Customers 项目
重要提示 这个练习获取每个客户的数据,如只是为了演示通过云端Web服务检索数据的概念,这样做当然无可厚非,但现实世界就要斟酌一番了．如数据库包含大量数据,这样会浪费不少网络带宽,还无谓增大了对用户设备内存
的要求.更好的方式是使用分页,客户数据分块取回(也许一次200个客户)。更新Web服务来支持这一方式.还需要Customers应用的VicwModel以透明方式取回客户块.

 从AdventureWorks Web服务获取数
1.在解决方案资源管理器中右击Customers项目的DataSource.cs文件并从弹出菜单中选择"删除"。在消息框中单击"是"按钮确认永久删除。
文件包含Customer应用程序使用的示例数据。要修改VieModel类从 Web服务获取数据,所以该文件用不着了。
2.右击Customers项目并选择"管理NuGet程序包".如提示输入连接SQLServer的密码,请关闭对话框。密码信息已由Web服务提供。
3.在"NuGet包管理器"中单击"浏览"标签,在搜索框中输入 Json.NET
4.在结果页中选择Json.NET.Web。在右侧窗格单击"安装"。
5.在预览窗口单击"确定"。
6. 如出现接受许可协议的提示,请选择接受。
7.等待程序包安装完成,关闭"NuGet包管理器"。
8.在解决方案资源管理器中右击Customers项目,选择"添加"I"RESTAPI客户端"。随后会启动一个向导,指导你生成应用程序用于连接Web 服务的对象模型。
9. 在"添加RESTAPI客户端"对话框中单击"选择Azure 资产"。
10.在"App Service"对话框中选择你的Azure订阅。在搜索框中展开awgroup资源组,选择上个练习创建的Web服务。单击"确定"。
11.回到"添加RESTAPI客户端"对话框,单击"确定"。VisualStudio会连接到Azaure并下载Web服务的源数据,同时会安装几个额外的 NuGet包,其中包含支持向导生成代码所需的库。耐心等待这个操作完成。
12．在解决方案资源管理器中应看到基于你的Web服务名称的一个新文件夹,形如AdventureWorksServicem期mmmn。展开该文件夹,再展开其中的Models 文件夹。
13.在Models文件夹中双击Customer.cs将其打开。该文件包含Customer类,建模了从Web服务获取的数据。针对用实体框架构建 Web服务时为Customer实体指定 的每个属性(atributes),该类都包含了对应的字段和属性(properties),还有一个构 造器用于创建新的Customer对象。
14.在AdventureWorksServicnnnmn文件夹中双击CustomersOperations.cs将其打开。它的代码和REST操作交互,UWP应用通过这些操作从Web服务收发数据。其 中 至 少包 含 静 态 方 法 GetCustomersMithHttpessagesASync, PostCustomerswithHttpessagesAsync,GetCustomerwithHttpMessagesAsync,PutcustomerwithHttpessagesAsync 和 beleteCustomerwithHttpessagessync。所有这些方法都包含用于构造和发送HTTP请求和处理结果所需的低级代码。欢迎研究这些代码,但暂时不需要完全理解,特别是不要修改。稍后用Visual Studio 向导来重新生成RESTWeb 客户端时,所有修改都会丢失。
15.双击CustomersOperationsExtension.cs将其打开,其中包含CustomerOperations类的一组扩展方法,作用 是提供一个简化的可编 程 API。CustomerOperationsExtens1on类通过许多成对的方法来包装CustomerOperations类中对应的操作,从而执行必要的任务处理和取消处理。例如,类提供了一对GetCustomers和GetCuslomersAsync 方法,两者都调用 CustomerOperations 类的GetCustomerswithHttpNessagesAsync 方法。 Customers UWP应用将利用这些扩展方法。
26.双击AdventureWorksServicenmmmn.cs文件将其打开,它实现了用于创建Web服务连接的AdventurekorksServicennnnnnn类。类的大部分是一系列公共和受保护构造器,用于指定Web服务的URL、安全凭据和其他选项。
我们的Web服务实际没有实现任何形式的身份验证,任何人只要知道Web服务的URL,就能向其发送请求。但真正的Web服务不允许公开公司的机密信息。由 于我们的Web服务只包含示例数据,所以省去了该任务。
虽然AzureAPI 应用的默认配置是禁用身份验证(参考后面的补充内容"AzureAPI应用的安全性"),但AdventureworksServicennnnnnn类的公共构造器还是希你提供Web服务用于身份验证的详细数据。反常但合理。因为一个应用不用身份验证,应该是由你明确制定的一项决策,而非仅仅是因为你忘了就不用。不过,AdventureworksServicennnnnnn类确实提供了不要求身份验证信息的受保护构造器。为了偷懒,你可能想直接将这些构造器的可访问性修改成公共,但注意重新生成RESTAPI客户端代码时会丢失这些修改。更何况这根本就不是好的编程实践。相反,应新建一个类来扩展AdventureworksServicennnnnnn类。在新类中添加公共构造器来调用基类中对应的受保护构造器。
Azure API 应用的安全性
部署AzureAPI应用时,身份验证默认禁用.这意味着API公开的Web服务任何人都能访问.要证明这一点,请在Azure 门户中访问自己的Azure API应用,单击"身份验证/授权"设置,身份验证很简单,点击"打开"按钮即可,随后会在下图所示的对话框中显示身份验证选项。例如,可允许通过 Microsof、Facebook、Twitter或Google账号登录(可多选).企业内部的应用可选择Azure Active Directory.无论选择什么,都需要向身份验证提供商
注册你的应用,并配置用户在通过身份验证后如何授权。信息可参考"AZure应用服务中的身份验证和授权"一文,网址是htps:/docs.microsof.com/zh-cn/azure/app-service/app-service-authentication-overview.
配置好身份验证后连接Web服务,会提示通过相应的身份验证提供商输入凭据,如创建UWP应用,可在创建用于连接Web服务的对象时,在构造器中提供这些凭据。这种对象是我们在练习中创建的AdventurekorksServicennnnnnnn类的实例。
17.在解决方案资源管理器中右击Customers项目,选择"添加"|"类"。在"添加新项"对话框的"名称"文本框中输入 AdventureWorksService.cs,单击"添加"。
18. 修改AdventureworksService类使其从AdventureiorksServicennnnnnnn类维承(记得替换掉这些mn,后文不再赘述):
class AdventureliorksService :AdventureliorksServicennnnnn
{}
19.添加加粗的公共构造器:
class AdventureworksService:AdventurehborksServicennnnnnnn
{
	public AdventureworksService()
		:base()
	{
	}
}
该构造器实际调用AdventureworksServicennnnnnnnn类的以下构造器:
protected AdventureworksServicennnmnnmn(params Delegatingtandler[] handlers):
base(handlers)
{
	this.Initialize();
}
记住params关键字指定一个参数数组。如传递空参数列表,参数数组将是空白。AdventureworksServicennnnnnnnn类的Initialize方法对Web 服务连接的设置进行初始化。
20.在解决方案资源管理器中双击ViewModel.cs 来显示ViewModel类的代码。
21.在ViewNodel构造器中注释掉将customers字段设为DataSource.Customers列表的代码,添加以下加粗的代码
public ViewModel()
{
	...
	//this.customers =DataSource.Customers;
	try
	{
		AdventurelWorksService service= new AdventureWorksService();
		this.customers = service.CustomersOperations.GetCustomers().ToList();
	}
	catch
	{
		this.customers= null;
	}
}
customers 列表包含要由应用显示的客户;之前是用你已删除的DataSource.cs文件中的数据来填充。新代码创建一个和 Web服务连接的AdventureworksService对象。对象的CustomersOperations属性引用了一个CustomerOperations对象,后者提供 GetCustomers 方法从Web服务获取数据,这之前已经讲过。数据转换成列表并存储到customers 变量中。如发生异常,customers 列表被设为null;客户不会显示。
22.在"调试"菜单中选择"开始调试",生成并运行应用程序.
应用程序会花些时间从Web服务获取信息,会显示下图所示的启动屏幕,然后填充第一个客户(Orlando Gee)的详细信息。
23.利用命令栏上的导航按钮在客户之间移动,验证窗体能正常工作。
24.返回Visual Studio 并停止调试。
通过RESTWeb服务插入、更新和删除数据
除了查询和显示数据,许多应用还要求支持插入、更新和删除数据。ASP.NETWebAPI实现了一个模型来支持这些操作,其中用到了HTTPPUT、POST和DELETE请求。根据约定,PUT请求修改Web服务中现有的资源,POST请求新建资源的实例,而DELETE 请求删除资源。ASP.NETWeb API模板的"添加基架"向导遵循这些约定。
REST Web 服务的幂等性
REST Web服务中,PUT请求应该是幂等(同前)的、也就是说,反复执行相同的更新,结果总是相同,在AdventureWorksService 例子中,如修改一个客户并将电话号码设为"88-88-888",那么不管执行这个操作多少次都没有关系,因为结果一致。这听起来似乎理所当然,但在设计 RESTWeb服务时一定要谨记这一点,确保在发生并发请求或者网络故障时Web服务的健壮性,(如客户端应用失去与Web服务的连接,它会尝试重新连接并再次执行相同的请求,而不必关心之前的请求是否成功.)所以,应该将RESTWeb服务看成是一种数据存储和检索方式,而不是一组跟业务相关的操作、
例如,假定要开发一个银行系统,开发者提供了一个CreditAccount方法在客户账户余额上增加金额,并作为PUT操作来公开该方法,由于每次调用这个操作都会造成账户余额增加,所以有必要跟踪该操作是否成功。应用程序不能以为之前的一次调用失败或超时就反复调用该操作,否则可能造成在同一个账户上反复增加金额。
要想进一步了解如何在云端应用程序中管理数据一致性,请参考"DataConsistencyPrimer"(htps://msdn.microsof. com/tibrary/dn589800.aspx)
下一个练习将扩展Customers 应用,构造合适的 REST 请求并把它们发送给AdventureWorksService Web服务,以便添加新客户以及修改现有客户的资料。不提供删除客户的功能,目的是保留全部有生意来往的客户的记录,这可能是审计所要求的。另外,即使客户长时间不活动,将来也可能重新跟你合作。
注意 商业软件普遍采取永不删除数据的做法,只是执行一下更新操作,将数据标记为"移除"来防止显示．这主要是为了保留完整数据记录,一般是出于监管要求．
在Viewodel类中实现添加和编辑功能
1.返回VisualStudio。
2.在解决方案资源管理器中双击Customers 项目根文件夹中的Customer.cs来打开。
3.在Customer类的 Phone属性后添加加粗的公共属性:
public class Customer:INotifyPropertyChanged
{
	...
	public string Phone
	{
		...
	}
	public System.Guid rowguid {get;set;}
	public System.DateTime NodifiedDate{get;set;}
	...
}
Web服务从数据库取回这些字段。之前向customers列表拷贝数据时忽略了它们。但更新数据就需要用到它们了。实体框架通过这些属性判断要修改哪些行,并在多个用户同时修改相同数据时帮助解决冲突。
4.从Customers 项目中删除ViewModel.cs 文件,允许Visual Studio将其永久删除。
5. 右击Customers 项目,选择"添加"│"现有项",选择"文档"文件夹下的MicrosofPressVCSBSIChapter27子文件夹中的ViewModelcs文件,单击"添加"。
ViewModeLcs 文件中的代码现在相当多了,有必要用区域(#region)重新组织一下以便管理。Vieodel类还添加了以下 bool属性来指出ViewModel当前的工作模式(Browsing,Adding或Editing)。这些属性在名为"Properties for managing the edit mode"的区域中定义。

IsBrowsing 该属性指出ViewModel是否处于Browsing模式。在该模式中,FirstCustomer、LastCustomer,PreviousCustomer和 NextCustomer 命令都会被启用,视图能调用这些命令来浏览数据。
ISAdding 该属性指出ViewModel是否处于Adding模式。在该模式中,FirstCustomer、LastCustomer、PreviousCustomer和NextCustomer命令被禁用。稍后要定义在该模式中启用的AddCustomer、SaveChanges和DiscardChanges命令。
IsEdting 该属性指出ViewModel是否处于Editing模式。和Adding模式一样,要禁用FirstCustomer、LastCustomer、PreviousCustomer和NextCustomer 命令。该模式要启用 EditCustomer 命令(稍后定义)。
SaveChanges和DiscardChanges命令也被启用,但AddCustomer命令被禁用。EditCustomer命令在Adding模式中被禁用。
IsAddingOrEditing 该属性指出ViewModel是否处于Adding或Editing模式。本练习定义的方法将用到该属性。
CanBrowse 如ViewModel处于Browsing模式,而且建立了到Web服务的连接,该属性就返回true。构造器中创建FirstCustomer,LastCustomer,PreviousCustomer和 NextCustomer 命令的代码进行了更新,使用该属性判
断这些命令是应启用还是禁用,如下所示。
public Viewodel()
{
	...
	this.NextCustomer = newCommand(this.Next,
		()=>{return this.CanBrowse && this.customers != null && !this.IsAtEn});
	this.PreviousCustomer= new Command(this.Previous,
		()=>{return this.CanBrowse && this.customers ! = null && !this.IsAtStart;});
	this.FirstCustomer = new Command(this.First,
		()=>{return this.CanBrowse 8& this.customers ! = null && !this.IsAtStart;});
	this.LastCustomer a new Command(this.Last,
		()=>{return this.CanBrowse 8& this.customers != null && !this.ISAtEnd;});
}
CansaveOrDiscardChanges如ViewModel处于Adding或Editing模式,而且建立了到Web服务的连接,该属性就返回true.
Methods for fetching and updating data 区域包含以下方法。
ValidateCustomer该方法获取一个Customer对象,检查 FirstName和LastName属性来确保它们非空。还要检查 EmailAddress和Phone属性来验证它们存储的信息具有有效格式。数据有效就返回true,否则返回false。本练习稍后创建 SaveChanges命令时要用到这个方法。
CopyCustomer该方法的作用是创建Customer对象的浅拷贝。创建EditCustomer命令时要先用它创建原始客户数据的拷贝,再进行修改。如用户决定放弃修改,就可利用它简单地还原。
注意  对 EmailAddress 和 Phone 属性进行验证的代码使用 System.Text.RegularExpressions 命名空间定义的Regex类执行正则表达式匹配。要在Regex对象中定义正则表达式来指定匹配模式,然后为需要验证的数据调用 Regex对象的ISatch方法。要更多地了解正则表达式和Regex类,请参考"正则表达式对象模型",网址为htp://msdn.microsof.com/ibrary/30Owbz966.
6.在新的ViewModelcs 文件中找到构造器前方的 ServerUrl字符串变量定义:private const string ServerUrl="http://ebappname>.azureebsites.net/";将字符串修改你的Web应用的名称,形如http:/adventureworksservicenmmmnmn.azurewebsites.net/。
7.在ViewModel.cs 文件中展开 Methods for fetching and updating data区域。在这个区域的ValidateCustomer方法上方添加以下 Add方法
//Create a new(empty)customer
// and put the form into Adding mode
private void Add()
{
	Customer newCustomer = new Customer{CustomerID=0);
	this.customers,Insert(currentustomer,neMCustomer); 
	this.IsAdding = true;
	this.OnPropertyChanged("Current");
}
该方法创建新的Customer对象。对象基本空白,除了CustomerID属性之外(该属性暂时设为Q以便显示:真实值在客户保存到数据库时生成)。客户添加到客户列表(视图通过数据绑定显示该列表中的数据)。ViewModel被置于Adding模式。引发PropertyChanged事件来指出Current客户发生改变。
8.在ViewModel类的开头添加以下加粗的Comand变量。
public class Vieodel:INotifyPropertyhanged
{
	...
	public Command LastCustomer{ get;private set;}
	public Command AddCustoner{ get;private set;}
	...
}
9.在ViewModel构造器中实例化AddCustomer命令,如加粗的代码所示。
public ViewModel()
{
	...
	this.LastCustomer = new Command(this.Last,...);
	this.AddCustomer = new Comand(this.Add,
		()=>{return this. CanBroase;>};
}
代码引用刚才创建的Add方法。如ViewModel建立了到Web服务的连接,而且处于Browsing模式,该命令就会启用（如果ViewModel 已处于 Adding 模式,则AddCustomer命令不会启用)。
10.在Methods for fetching and updating data 区域中,在 Add方法之后创建私有Customer变量oldCustomer,定义一个名为 Edit的方法。
//Edit the current customer
//save the exdsting details of the customer
//and put the form into Editing mode
private Customer oldCustomer;

private void Edit()
{
	this.oldCustomer = new Customer();
	this.CopyCustomer(this.Current,this.oldCustomer);
	this.IsEditing true;
}
该方法将当前客户的详细信息复制到oldCustomer变量,并将ViewModel设为Editing模式。用户可在这个模式中更改当前客户的资料。如果之后想放弃修改,原始教据可以从 oldCustomer复制问来。
11.将以下加粗的 Command变量添加到Viewodel类开头的列表中。
public class Viewodel:INotifyPropertyChanged
{
	...
	public Command AddCustomer { get;private set;}
	public Command EditCustomer{get;private set;}
	...
}
12.在ViewModel构造器中像下面这样实例化 EditCustomer命令。
public ViewModel()
{
	...
	this.AddCustomer= new Comand(this.Add,...);
	this.EditCustomer s new Command(this.Edit,()=>{return this.CanBrowse;});
	...
}
这些代码和AddCustomer命令的代码相似,只是引用Edit方法。
13. 还是在Methods for fetching and updating data 区域中,在Edit方法后添加 Discar方法。
// Discard changes made while in Adding or Editing mode
// and return the form to Browsing mode
private void Discard ()
{
	//If the user was adding a new customer,then remove it
	if(this.IsAdding)
	{
		this.customers.Remove(this. Current);
		this.OnPropertyChanged("Current");
	}

	// If the user was editing an existing customer,
	// then restore the saved details
	if(this.IsEditing)
	{
		this.CopyCustomer(this.oldCustomer, this.Current);
	}
	this,IsBrowsing = true;
}
方法作用是允许用户在Adding或Editing模式中放弃做出的任何更改。如ViewModel处于Adding模式,就将当前客户从列表中删除(这是由 Add方法创建的新客户)并引发PropertyChanged事件来指出客户列表的当前客户发生改变。如Viewodel处于Editing模式,就将oldCustomer变量中的原始资料复制回当前显示的客户。最后,ViewModel 回到Browsing模式。
14.在Viewodel类开头添加 Command 变量 DiscardChanges,更新构造器来实例化。
public class ViewAodel:INotifyPropertyChanged
{
	...
	public Comand EditCustomer{ get;private set;}
	public Comand DiscardChanges{ get; private set;}
	...
	public ViewModel()
	{
		...
		this.EditCustomer= new Comand(this.Edit,.….);
		this.DiscardChanges new Comand(this.Discard,
			()=>{return this.CansaveOrDiscardChanges;});
	}
	...
}
注意,只有CanSaveOrDiscardChanges属性为true时才启用DiscardChanges命令。也就是说,ViewModel要有到Web服务的连接,而且ViewModel处于Adding或Editing模式
15.还是在Methods for fetching and updating data区域中,在Discard方法后添加如下所示的SaveAsync方法。该方法应标记为 async。
private async vwid Savetsync()
{
	if(this. Validatecustomer(this. Gurrent))
	{
		try
		{
			AdventureiorksService service a new AMdventureiorksService();
			if(this.IsAdding)
			{
				//If the user is adting a new customer,post the details back to the web service
				var cust = aait service.CustomersOperations.PostCustomerAsync(this.Current)
				this.CopyCustomer(cust,this.Current);
				this.OnPropertyChanged(nameof(urrent)) 
				this.IsAdding = false;
				this.IsBrowsing = true;
			}
			else
			{
				//If the user is updating an exdisting customer,perform a PUT operation instead
				await service.Customersoperations.PutCustoerAsync(
				this.Current.CustomerID,this.Current); 
				this.IsAdding= false; 
				this.IsBrowsing= true;
			}
		}
		catch(Exception e)
		{
			//TOD0:Handle any error
		}
	}
}
ValidateCustomer方法确保应用当前显示的当前客户包含有效数据,比如名和姓不能为空,电子邮件地址正确格式化,且电话号码包含有效字符。如有效,try块中的代码继续判断用户当前是添加客户还是编辑现有客户。如果是添加,就使用RESTAPI客户端模型的PostCustomerAsync方法向Web服务发送POST消息。这个操作可能要花些时间,所以代码使用操作的异步版本防止UI假死。
注意,POST 请求是发送给 Web服务中的CustomersController类的PostCustomer方法。该方法要求获取一个Customer对象作为参数。客户资料以JSON 格式传输。你可能还记得,AdventureWorks 数据库的Customer 表的
CustomerID列包含自动生成的值。该值不是在创建客户由用户提供,而是由数据库自动生成。这样数据库才能确保每个客户都有唯一ID。RESTAPI客户端模型的PostCustomerAsync方法返回新建客户的详细信息,其中包括客户ID。你添加的代码负责用新数据更新Customers 应用显示的信息。
如编辑现有客户,应用就使用RESTAPI客户端模型的PutCustomerAsync方法生成一个PUT请求,将其传给Web服务的CustomersController类的PutCustomer方法。PutCustomerAsync方法更新数据库中现有客户的详细信息,要求获取客户ID和客户资料作为参数。同样地,数据以JSON 格式传给Web服务。
16.在ViewModel类开头的列表中添加如下所示的SaveChanges Command 变量,更新构造器来实例化。
public class Viewbdel:INotifypropertyChanged
{
	...
	public Comand DiscardChanges{get;private set;}
	public comand SaveChanges{get;private set;}
	...
	public ViewModel()
	{
		...
		this.DiscardChanges = new Command(this.Discard,...);
		this.SaveChanges = new Command(this. SaveAsync,
			()=>{return this.CansaveOrDiscardChanges;});
		...
	}
	...
}
17.选择"生成"|"生成解决方案",验证应用成功编译。
现在要更新 Web服务来支持编辑功能。具体地说,添加或编辑客户时应设置客户的ModifiedDate属性来反映修改日期。此外,创建新客户要先用一个新的GUID填充Customer对象的rowguid属性,然后才能保存。这是Customer表必须的一个列:AdventureWorks公司的其他应用通过该列跟踪客户资料。
注意 GUID是"全局唯一标识符"(Globally Unique IDdentifier)的简称.GUID是Windows生成的字符串,几乎可以保证它的唯一性(有极小的概率生成非唯一GUID,但概率小得可以忽略)。数据库经常将GUID作为健来标识单独的行.AdventureWorks 数据库的Customer表就是这样做的
更新 Web服务来支持添加和编辑功能
1.在解决方案资源管理器中展开AdventureWorksService项目的Controllers文件夹.双击CustomersController.cs 文件来显示它
2. 在 PostCustomer方法中,在向数据库保存新客户的语句前添加以下加粗的代码。
//POST api/Customers
[ResponseType(typeof(Custom))]
public async Task<IHttpActionResult> PostCustomer(Customer customer)
{
	if(IModelState.Isvalid)
	{
		...
	}
	customer.ModifiedDate = DateTime.Now;
	customer.rowguid = Guid.NewGuid();
 	db. Customers.Add(customer);
	await db.SaveChangesAsync();
	...
}
3.找到PutCustomer 方法,在指出客户已被修改的语句前更新客户的ModifiedDate属性,如加粗的语句所示
// PUT api/Customers/5
[ResponserType(typeof(void))]
public async Task<IHttpActionResult> PutCustomer(int id, Customer customer)
{
	...
	customer.ModifiedDate =DateTime.Now;
	db.Entry(customer).State = EntityState.Modified;
	...
}
4.将 Web 服务重新部署到云端。具体做法是在解决方案资源管理器中右击AdventureWorksService 项目并选择"发布".在发布页中单击"发布"来覆盖之前部署到Azure 的Web 服务。
纠正 REST API 客户端代码的问题
写作本书时我发现Visual Studio 为 RESTAPI客户端模型生成的代码有一个问题.具体是在成功添加新实体后,PostCustomerwithHttpMessagesAsync 方法不能正确处理REST Web服务传回的HTTP Created应答.目前 PostCustomerwithHttpMessagesAsync方法是构造一个HTTPPOST请求并发送给Web服务.它等待应答,如应答中的HTTP状
态码不是200(代表OK)就抛出异常,但RESTWeb服务允许传回其他2xx状态码,都代表成功.例如,一个POST请求可能返回状态码201(Created)而不是200(OK).
虽然之前建议过不要直接编辑VisualStudio为RESTAPI客户端模型生成的代码,但这个问题真的只能通过手动修改代码来解决,如下所示
1.展开 Customers项目的 AdventureWorksServicennnnnnnnn 文件夹,双击
CustomerOperations.cs文件将其打开。
2. 找到PostCustomerwithHttpMessagesAsync方法。
3.在方法中找到下面这行;
	if((int)_statusCode ！= 208]
4，按加粗的地方修改:
	if（(int)_statusCode ！=2008(int)_statusCode ！= 201)
5.还是在 PostCustomerwithHttpMessagesAsync方法中找到以下代码:
	//Deserlalfze response
	if（(int)_statusCode = 200
6.按加粗的地方修改:
	//Deserialize response
	if（(int)statuscode = 200 ||(int)_statusCode m 201)
7.选择"生成"|"重新生成解决方案".
	该问题将来可能随着VisualStudio的更新而修复。

报告错误和更新 UI
现已添加了用于添加、编辑和保存客户资料的命令。但如果中途发生错误,用户还是会摸不着头脑,因为ViewModel类没有包含任何错误报告功能。添加这种功能的一个办法是捕捉异常消息并作为VieModel类的一个属性来公开。视图可通过数据绑定连接到该属性并显示错误消息
为Viewodel类添加错误报告机制
1.返回Customers项目并显示ViewModel.cs 文件
2．在VieModel 构造器后添加私有_lastError字符串变量和公共LastError字符串属性。
private string_lastError = null;
public string LastError
{
	get => this._lastError;
	private set
	{
		this._lastError = value;
		this.OnPropertyChanged(nameof(LastError));
	}
}
3.找到ValidateCustomer方法,在 return语句前添加以下加粗显示的语句。
private bool ValidateCustomer(Customer customer)
{
	...
	this.LastError validationErrors;
	return IhasErrors
}
ValidateCustomer方法在 validationErrors变量中填充Customer对象的所有属性可能发生的错误信息。刚才添加的语句将该信息复制给LastError属性。
4.在SaveAsync方法中添加以下加粗显示的语句来捕捉所有错误和HTTPWeb服务错误,
private async void SaveAsync()
{
	//Validate the details of the Customer
	if(this.ValidateCustomer(this.Current)
	{
		...
		if(this.IsAdding)
		{
			...
			this.IsBrowsing = true;
			this.LastError= String.Empty;
		}
		else
		{
			...
			this.IsBrowsing = true; 
			this.LastError= String.Empty;
		}
	}
	catch(Exception e)
	{
		//TODO:Handle any errors 
		this.LastError = e.Message;
	}
}
5.找到Discard方法,在方法末尾添加以下加粗显示的语句。
private void Discard()
{
	...
	this.IsBrowsing = true; 
	this.LastError= String.Empty;
}
6．选择"生成"|"生成解决方案",验证应用成功生成。
viewModel现在就完成了。最后一步是将新的命令、状态信息和错误报告功能集成到Customers窗体提供的视图中。

为Customers 窗体集成添加和编辑功能
1.用设计视图打开 MainPage.xaml
MainPage窗体的XAML标记已进行了修改,在显示数据的Grid控件中添加了以下TextBlock控件
<Page 
	x:Classam"Customers.NainPage"
	...>
	<Grid Style="(StaticResource GridStyle)">
		...
		<Grid x:Name="customersSTabularView"...>
			...
			<Grid Grid.Row="2">
				...
				<TextBlock Grid.Row="6"Grid.Column="1"
Grid.Columnspan="7"Style="(StaticResource ErrorMessagestyle}"/>
			</Grid>
		</Grid>
		<Grid x:Name="customersColumarView"Margin="20,10,20,110""..>
			...
			<Grid Grid.Row="1">
				...
				<TextBlock Grid.Row="6"Grid.Column="0"
Grid.ColumnSpan="2"Styles"(StaticResource ErrorMessagesStyle}"/>
			</Grid>
		</Grid>
	...
	</Grid>
</Page>
这些TextBlock控件引用的 ErrorMessageStyle 在AppStyles.xaml文件中定义。
2. 设置两个 TextBlock控件的Text属性来绑定ViewModel的 LastError属性,如加粗的代码所示。
...
<TextBlock Grid.Rowl"6"Grid.Columns"1"Grid.ColumnSpans"7"
Style="(StaticResource Erroressagestyle}" Text="(Binding LastError}"/>
...
<TextBlock Grid.Row="6" Grid.Column="0" Grid.Columnspan="2'
Style="{StaticResource ErrorWessageStyle}" Text="{Binding LastError}"/>
3.窗体上显示客户数据的TextBox和ComboBox控件只有在ViewModel处于Adding或Editing模式时才允许修改数据:其他时候应该禁用。为所有这些控件添加IsEnabled属性,并绑定到ViewModel的IsAddingOrEditing属性,如下所示。
...
<TextBox Grid.Row="1"Grid.Columns="1"x:Name="id"
IsEnabled"{Binding IsAddingrEditing}".../> 
<TextBox Grid.Row="1"Grid.Column="5"x:Name="firstName"
IsEnabled"{Binding ISAddingOrEditing}".../> 
<TextBox Grid.Row="1"Grid.Columm="7"x:Name="lastName"
IsEnableds"{Binding ISAddingorEditing)".../> 
<ComboBox Grid.Row="1"Grid.Columns="3"x:Name="title"
IsEnabled="{Binding IsAddingorEditing}".../>
...
<TextBox Grld.Row="3"Grid.Columns="3"x:Name="email"
IsEnabledm"{Binding IsAddingOrEditing}".../>
...
<TextBox Grid.Row="5"Grid.Column="3"X:Name="phone"
IsEnabledm"{Binding IsAddingOrEditing}".../>
...
...
<TextBox Grid.Row="0"Grid.Colums"1"x:Name="cId"/>
IsEnabled="(Binding IsAddingOrEditing}".../> 
<TextBox Grid.Row="2"Grid.Column="1"x:Name="cFirstName"
IsEnabledu"(Binding IsAddingOrtditing)"./> 
<TextBox Grid.Row="3"Grld.Column="1"x:Namem"CLastName"
IsEnabled="(Binding IsAddingOrEditing)".../》 
<ComboBox Grid.ROwe"1"Grid.Column="1"x:Name="cTitle"
IsEnabled="(Binding IsAddingOriditing)".../>
...
<TextBox Grid.Rowe"4"Grld.olumns"1"x:Name="cEmail" 
IsEnabled="{Binding IsAddingOrEditing)".../>
...
<TextBox Grid.Rowe"5"Grid.Colun="1"x:Names"cPhone" 
IsEnabledm"(Binding IsAddingOrEditing}"../>
4.使用<Page.BottomAppBar>元素在页的底部添加命令栏。将该元素放到顶部命令栏后面。该命令栏应包含用于执行AddCustomer、EditCustomer、SaveChanges和DiscardChanges命令的按钮,如下所示。
<Page...>
	...
	<Page.TopAppBar>
		...
	</Page.TopAppBar>
 	<Page.BottomppBar>
 		<CommandBar>
 			<AppBarButton x:Name="addCustomer" Icon."Add"
Label="New Customer"Comand="{Binding Path=AddCustomer}"/>
		<AppBarButton x:Name="editCustomer"Icon="Edit"
Label="Edit Customer"Comand="{Binding Path=EditCustomer}"/>
		<AppBarButton x:Name="saveChanges"Icon="Save"
Label="Save Customer"Comand="{Binding Path=SaveCustomer}"/>
		<AppBarButton x:Name="discardChanges"Icon="Undo"
Label="Undo Customer"Comand="{Binding Path=DiscardChanges}"/>
		</CcormandBar>
	</Page.BottomtppBar>
</Page>
注意,按钮图标使用的是"空白应用"模板提供的标准图像。
用户单击Save Changes 时,和Web服务的交互或快或慢,具体取决于到Azure的HTTP连接速度和数据库负载。所以有必要让用户知道应用程序正在保存数据而非假死。UWP应用允许用ProgressRing(进度环)控件来提供这种视觉反馈。只有ViewModel忙于和Web 服务通信时才显示该控件,其他时候不显示。
为Customers 窗体添加"忙碌"指示器"
1.显示 ViewModel.cs 文件,在 LastError属性后添加私有_isBusy字段和公共ISBusy属性,如下所示:
private bool_isBusy;
public bool IsBusy
{
	get => this._isBusy;
	set
	{
		this.isBusy = value;
		this.OnPropertyOhanged(nameof(IsBusy));
	}
}
2. 修改 SaveAsync方法来添加以下加粗的语句,在if 语句前后设置和重置IsBusy标志。
private async void SaveAsync()
{
	this.IsBusy = true;
	if(this.ValidateCustomer(this. Current))
	{
		...
	}
	this.IsBusy = false;
}
3.以设计视图打开MainPage.xaml文件
4.在XAML窗格添加以下加粗的ProgressRing控件作为顶级Grid控件的第一项。
<Grid Style="{StaticResource Gridstyle}">
	<ProgressRing HorizontalAlignment="Center"
VerticalAlignment="Center"Foreground="AntiqueWhite"
Height="100" Width="100" IsActive="{Binding IsBusy}"
Canvas.ZIndex"1"/>
	<Grid x:Name="customersSTabularView"Margin="40,54,0,0"...>
	...
将Canvas.ZIndex属性设为"1"是为了保证 ProgressRing在Grid控件中的其他控件前面显示。
测试 Customers 应用程序
1.在"调试"菜单中选择"开始调试"生成并运行应用程序。
注意,等Customers 窗体出现时,所有TextBox和ComboBox控件都被禁用。这是由于视图处于Browsing模式。
2.验证窗体的上下命令栏都显示出来了。
可像往常那样使用上方命令栏中的First、Next、Previous和Last 按钮。记住,First和 Previous 按钮只有在离开第一个客户后才会启用。
3.单击底部命令栏上的EditCustomer按钮
4.顶部命令栏的按钮被禁用,因为ViewModel 现在进入 Editing模式。Add 按钮和Edit 按钮也被禁用,但 Save Changes 按钮和Undo Changes 按钮启用。此外,窗体上的数据输入控件都被启用了,用户现在可以修改客户资料
5. 修改客户资料,故意不填First Name,电子邮件地址输入Test,电话号码输入Test
2,单击Save。
这些数据违反了ValidateCustomer方法实现的校验规则。ValidateCustomer方法在ViewModel的LastError属性中填充校验消息,窗体上和LastError属性绑定的TextBlock 显示该消息
6.单击Undo Changes,验证窗体上会恢复原始数据,校验消息消失,ViewModel还原为Browsing模式。
7.单击Add。窗体上的输入控件应被清空(ID字段除外,它显示值0)。输入新客户的资料。注意输入 First Name 和Last Name、有效电子邮件地址(形如mame@organization.com)以及全数字电话号码(允许圆括号、连字号和空格)
8.单击 Save Changes。如数据有效(没有校验错误),数据应保存到数据库,会在ID字段看到为新客户生成的ID,ViewModel 应切换回 Browsing模式。
9.自由实验应用程序,尝试添加更多客户。注意,可以通过改变视图大小来显示列布局,窗体正常工作。
10.完成实验后返回VisualStudio并停止调试。



第I部分 Visual C#和VisualStudio 2017概述
第1章 欢迎进入C#编程世界
第2章 使用变量、操作符和表达式
第3章 方法和作用域
第4章 使用判断语句
第5章 使用复合赋值和循环语句
第6章 管理错误和异常

第II部分 理解C#对象模型
第7章 创建并管理类和对象
第8章 理解值和引用
第9章 使用枚举和结构创建值类型
第10章 使用数组
第11章 理解参数数组
第12章 使用继承
第13章 创建接口和定义抽象类
第14章 使用垃圾回收和资源管理

第Ⅲ部分 用用C#定义可扩展类型
第15章 实现属性以访问字段
第16章 处理二进制数据和使用索引器
第17章 泛型概述
第18章 使用集合
第19章 枚举集合
第20章 分离应用程序逻辑并处理事件
第21章 使用查询表达式来查询内存中的数据
第22章 操作符重载

第IV部分 用C#构建UWP应用
第24章 通过异步操作提高响应速度
第23章 使用任务提高吞吐量
第25章 实现 UWP应用的用户界面
第26章 在UWP应用中显示和搜索数据
第27章 在UWP应用中访问远程数据库